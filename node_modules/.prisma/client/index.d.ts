
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model Club
 * 
 */
export type Club = $Result.DefaultSelection<Prisma.$ClubPayload>
/**
 * Model ClubAdmin
 * 
 */
export type ClubAdmin = $Result.DefaultSelection<Prisma.$ClubAdminPayload>
/**
 * Model Coach
 * 
 */
export type Coach = $Result.DefaultSelection<Prisma.$CoachPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Pod
 * 
 */
export type Pod = $Result.DefaultSelection<Prisma.$PodPayload>
/**
 * Model PodHolder
 * 
 */
export type PodHolder = $Result.DefaultSelection<Prisma.$PodHolderPayload>
/**
 * Model PodHolderAudit
 * 
 */
export type PodHolderAudit = $Result.DefaultSelection<Prisma.$PodHolderAuditPayload>
/**
 * Model PodAllocation
 * 
 */
export type PodAllocation = $Result.DefaultSelection<Prisma.$PodAllocationPayload>
/**
 * Model CoachAssignment
 * 
 */
export type CoachAssignment = $Result.DefaultSelection<Prisma.$CoachAssignmentPayload>
/**
 * Model PlayerPod
 * 
 */
export type PlayerPod = $Result.DefaultSelection<Prisma.$PlayerPodPayload>
/**
 * Model PlayerPodHolder
 * 
 */
export type PlayerPodHolder = $Result.DefaultSelection<Prisma.$PlayerPodHolderPayload>
/**
 * Model PodStatus
 * 
 */
export type PodStatus = $Result.DefaultSelection<Prisma.$PodStatusPayload>
/**
 * Model PodHolderStatus
 * 
 */
export type PodHolderStatus = $Result.DefaultSelection<Prisma.$PodHolderStatusPayload>
/**
 * Model RawData
 * 
 */
export type RawData = $Result.DefaultSelection<Prisma.$RawDataPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventParticipant
 * 
 */
export type EventParticipant = $Result.DefaultSelection<Prisma.$EventParticipantPayload>
/**
 * Model PaymentPlan
 * 
 */
export type PaymentPlan = $Result.DefaultSelection<Prisma.$PaymentPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ServiceRequest
 * 
 */
export type ServiceRequest = $Result.DefaultSelection<Prisma.$ServiceRequestPayload>
/**
 * Model ActivityMetric
 * 
 */
export type ActivityMetric = $Result.DefaultSelection<Prisma.$ActivityMetricPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SuperAdmins
 * const superAdmins = await prisma.superAdmin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SuperAdmins
   * const superAdmins = await prisma.superAdmin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.club`: Exposes CRUD operations for the **Club** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clubs
    * const clubs = await prisma.club.findMany()
    * ```
    */
  get club(): Prisma.ClubDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubAdmin`: Exposes CRUD operations for the **ClubAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubAdmins
    * const clubAdmins = await prisma.clubAdmin.findMany()
    * ```
    */
  get clubAdmin(): Prisma.ClubAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coach`: Exposes CRUD operations for the **Coach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coaches
    * const coaches = await prisma.coach.findMany()
    * ```
    */
  get coach(): Prisma.CoachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pod`: Exposes CRUD operations for the **Pod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pods
    * const pods = await prisma.pod.findMany()
    * ```
    */
  get pod(): Prisma.PodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podHolder`: Exposes CRUD operations for the **PodHolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodHolders
    * const podHolders = await prisma.podHolder.findMany()
    * ```
    */
  get podHolder(): Prisma.PodHolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podHolderAudit`: Exposes CRUD operations for the **PodHolderAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodHolderAudits
    * const podHolderAudits = await prisma.podHolderAudit.findMany()
    * ```
    */
  get podHolderAudit(): Prisma.PodHolderAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podAllocation`: Exposes CRUD operations for the **PodAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodAllocations
    * const podAllocations = await prisma.podAllocation.findMany()
    * ```
    */
  get podAllocation(): Prisma.PodAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coachAssignment`: Exposes CRUD operations for the **CoachAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachAssignments
    * const coachAssignments = await prisma.coachAssignment.findMany()
    * ```
    */
  get coachAssignment(): Prisma.CoachAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerPod`: Exposes CRUD operations for the **PlayerPod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerPods
    * const playerPods = await prisma.playerPod.findMany()
    * ```
    */
  get playerPod(): Prisma.PlayerPodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerPodHolder`: Exposes CRUD operations for the **PlayerPodHolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerPodHolders
    * const playerPodHolders = await prisma.playerPodHolder.findMany()
    * ```
    */
  get playerPodHolder(): Prisma.PlayerPodHolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podStatus`: Exposes CRUD operations for the **PodStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodStatuses
    * const podStatuses = await prisma.podStatus.findMany()
    * ```
    */
  get podStatus(): Prisma.PodStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podHolderStatus`: Exposes CRUD operations for the **PodHolderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PodHolderStatuses
    * const podHolderStatuses = await prisma.podHolderStatus.findMany()
    * ```
    */
  get podHolderStatus(): Prisma.PodHolderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawData`: Exposes CRUD operations for the **RawData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawData
    * const rawData = await prisma.rawData.findMany()
    * ```
    */
  get rawData(): Prisma.RawDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventParticipant`: Exposes CRUD operations for the **EventParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventParticipants
    * const eventParticipants = await prisma.eventParticipant.findMany()
    * ```
    */
  get eventParticipant(): Prisma.EventParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentPlan`: Exposes CRUD operations for the **PaymentPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentPlans
    * const paymentPlans = await prisma.paymentPlan.findMany()
    * ```
    */
  get paymentPlan(): Prisma.PaymentPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRequest`: Exposes CRUD operations for the **ServiceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRequests
    * const serviceRequests = await prisma.serviceRequest.findMany()
    * ```
    */
  get serviceRequest(): Prisma.ServiceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityMetric`: Exposes CRUD operations for the **ActivityMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityMetrics
    * const activityMetrics = await prisma.activityMetric.findMany()
    * ```
    */
  get activityMetric(): Prisma.ActivityMetricDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SuperAdmin: 'SuperAdmin',
    Club: 'Club',
    ClubAdmin: 'ClubAdmin',
    Coach: 'Coach',
    Player: 'Player',
    Pod: 'Pod',
    PodHolder: 'PodHolder',
    PodHolderAudit: 'PodHolderAudit',
    PodAllocation: 'PodAllocation',
    CoachAssignment: 'CoachAssignment',
    PlayerPod: 'PlayerPod',
    PlayerPodHolder: 'PlayerPodHolder',
    PodStatus: 'PodStatus',
    PodHolderStatus: 'PodHolderStatus',
    RawData: 'RawData',
    Event: 'Event',
    EventParticipant: 'EventParticipant',
    PaymentPlan: 'PaymentPlan',
    Subscription: 'Subscription',
    Payment: 'Payment',
    ServiceRequest: 'ServiceRequest',
    ActivityMetric: 'ActivityMetric'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "superAdmin" | "club" | "clubAdmin" | "coach" | "player" | "pod" | "podHolder" | "podHolderAudit" | "podAllocation" | "coachAssignment" | "playerPod" | "playerPodHolder" | "podStatus" | "podHolderStatus" | "rawData" | "event" | "eventParticipant" | "paymentPlan" | "subscription" | "payment" | "serviceRequest" | "activityMetric"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Club: {
        payload: Prisma.$ClubPayload<ExtArgs>
        fields: Prisma.ClubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findFirst: {
            args: Prisma.ClubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findMany: {
            args: Prisma.ClubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          create: {
            args: Prisma.ClubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          createMany: {
            args: Prisma.ClubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          delete: {
            args: Prisma.ClubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          update: {
            args: Prisma.ClubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          deleteMany: {
            args: Prisma.ClubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          upsert: {
            args: Prisma.ClubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          aggregate: {
            args: Prisma.ClubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClub>
          }
          groupBy: {
            args: Prisma.ClubGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubCountArgs<ExtArgs>
            result: $Utils.Optional<ClubCountAggregateOutputType> | number
          }
        }
      }
      ClubAdmin: {
        payload: Prisma.$ClubAdminPayload<ExtArgs>
        fields: Prisma.ClubAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          findFirst: {
            args: Prisma.ClubAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          findMany: {
            args: Prisma.ClubAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>[]
          }
          create: {
            args: Prisma.ClubAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          createMany: {
            args: Prisma.ClubAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>[]
          }
          delete: {
            args: Prisma.ClubAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          update: {
            args: Prisma.ClubAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          deleteMany: {
            args: Prisma.ClubAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>[]
          }
          upsert: {
            args: Prisma.ClubAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubAdminPayload>
          }
          aggregate: {
            args: Prisma.ClubAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubAdmin>
          }
          groupBy: {
            args: Prisma.ClubAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubAdminCountArgs<ExtArgs>
            result: $Utils.Optional<ClubAdminCountAggregateOutputType> | number
          }
        }
      }
      Coach: {
        payload: Prisma.$CoachPayload<ExtArgs>
        fields: Prisma.CoachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          findFirst: {
            args: Prisma.CoachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          findMany: {
            args: Prisma.CoachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>[]
          }
          create: {
            args: Prisma.CoachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          createMany: {
            args: Prisma.CoachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>[]
          }
          delete: {
            args: Prisma.CoachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          update: {
            args: Prisma.CoachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          deleteMany: {
            args: Prisma.CoachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoachUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>[]
          }
          upsert: {
            args: Prisma.CoachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          aggregate: {
            args: Prisma.CoachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoach>
          }
          groupBy: {
            args: Prisma.CoachGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachCountArgs<ExtArgs>
            result: $Utils.Optional<CoachCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Pod: {
        payload: Prisma.$PodPayload<ExtArgs>
        fields: Prisma.PodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          findFirst: {
            args: Prisma.PodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          findMany: {
            args: Prisma.PodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          create: {
            args: Prisma.PodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          createMany: {
            args: Prisma.PodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          delete: {
            args: Prisma.PodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          update: {
            args: Prisma.PodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          deleteMany: {
            args: Prisma.PodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>[]
          }
          upsert: {
            args: Prisma.PodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodPayload>
          }
          aggregate: {
            args: Prisma.PodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePod>
          }
          groupBy: {
            args: Prisma.PodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodCountArgs<ExtArgs>
            result: $Utils.Optional<PodCountAggregateOutputType> | number
          }
        }
      }
      PodHolder: {
        payload: Prisma.$PodHolderPayload<ExtArgs>
        fields: Prisma.PodHolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodHolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodHolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          findFirst: {
            args: Prisma.PodHolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodHolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          findMany: {
            args: Prisma.PodHolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>[]
          }
          create: {
            args: Prisma.PodHolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          createMany: {
            args: Prisma.PodHolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodHolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>[]
          }
          delete: {
            args: Prisma.PodHolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          update: {
            args: Prisma.PodHolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          deleteMany: {
            args: Prisma.PodHolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodHolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodHolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>[]
          }
          upsert: {
            args: Prisma.PodHolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderPayload>
          }
          aggregate: {
            args: Prisma.PodHolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodHolder>
          }
          groupBy: {
            args: Prisma.PodHolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodHolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodHolderCountArgs<ExtArgs>
            result: $Utils.Optional<PodHolderCountAggregateOutputType> | number
          }
        }
      }
      PodHolderAudit: {
        payload: Prisma.$PodHolderAuditPayload<ExtArgs>
        fields: Prisma.PodHolderAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodHolderAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodHolderAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          findFirst: {
            args: Prisma.PodHolderAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodHolderAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          findMany: {
            args: Prisma.PodHolderAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>[]
          }
          create: {
            args: Prisma.PodHolderAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          createMany: {
            args: Prisma.PodHolderAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodHolderAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>[]
          }
          delete: {
            args: Prisma.PodHolderAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          update: {
            args: Prisma.PodHolderAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          deleteMany: {
            args: Prisma.PodHolderAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodHolderAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodHolderAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>[]
          }
          upsert: {
            args: Prisma.PodHolderAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderAuditPayload>
          }
          aggregate: {
            args: Prisma.PodHolderAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodHolderAudit>
          }
          groupBy: {
            args: Prisma.PodHolderAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodHolderAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodHolderAuditCountArgs<ExtArgs>
            result: $Utils.Optional<PodHolderAuditCountAggregateOutputType> | number
          }
        }
      }
      PodAllocation: {
        payload: Prisma.$PodAllocationPayload<ExtArgs>
        fields: Prisma.PodAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          findFirst: {
            args: Prisma.PodAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          findMany: {
            args: Prisma.PodAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>[]
          }
          create: {
            args: Prisma.PodAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          createMany: {
            args: Prisma.PodAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>[]
          }
          delete: {
            args: Prisma.PodAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          update: {
            args: Prisma.PodAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          deleteMany: {
            args: Prisma.PodAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>[]
          }
          upsert: {
            args: Prisma.PodAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodAllocationPayload>
          }
          aggregate: {
            args: Prisma.PodAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodAllocation>
          }
          groupBy: {
            args: Prisma.PodAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<PodAllocationCountAggregateOutputType> | number
          }
        }
      }
      CoachAssignment: {
        payload: Prisma.$CoachAssignmentPayload<ExtArgs>
        fields: Prisma.CoachAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          findFirst: {
            args: Prisma.CoachAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          findMany: {
            args: Prisma.CoachAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>[]
          }
          create: {
            args: Prisma.CoachAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          createMany: {
            args: Prisma.CoachAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>[]
          }
          delete: {
            args: Prisma.CoachAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          update: {
            args: Prisma.CoachAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.CoachAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoachAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.CoachAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAssignmentPayload>
          }
          aggregate: {
            args: Prisma.CoachAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachAssignment>
          }
          groupBy: {
            args: Prisma.CoachAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<CoachAssignmentCountAggregateOutputType> | number
          }
        }
      }
      PlayerPod: {
        payload: Prisma.$PlayerPodPayload<ExtArgs>
        fields: Prisma.PlayerPodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerPodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerPodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          findFirst: {
            args: Prisma.PlayerPodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerPodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          findMany: {
            args: Prisma.PlayerPodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>[]
          }
          create: {
            args: Prisma.PlayerPodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          createMany: {
            args: Prisma.PlayerPodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerPodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>[]
          }
          delete: {
            args: Prisma.PlayerPodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          update: {
            args: Prisma.PlayerPodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          deleteMany: {
            args: Prisma.PlayerPodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerPodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerPodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>[]
          }
          upsert: {
            args: Prisma.PlayerPodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodPayload>
          }
          aggregate: {
            args: Prisma.PlayerPodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerPod>
          }
          groupBy: {
            args: Prisma.PlayerPodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerPodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerPodCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerPodCountAggregateOutputType> | number
          }
        }
      }
      PlayerPodHolder: {
        payload: Prisma.$PlayerPodHolderPayload<ExtArgs>
        fields: Prisma.PlayerPodHolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerPodHolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerPodHolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          findFirst: {
            args: Prisma.PlayerPodHolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerPodHolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          findMany: {
            args: Prisma.PlayerPodHolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>[]
          }
          create: {
            args: Prisma.PlayerPodHolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          createMany: {
            args: Prisma.PlayerPodHolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerPodHolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>[]
          }
          delete: {
            args: Prisma.PlayerPodHolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          update: {
            args: Prisma.PlayerPodHolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          deleteMany: {
            args: Prisma.PlayerPodHolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerPodHolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerPodHolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>[]
          }
          upsert: {
            args: Prisma.PlayerPodHolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPodHolderPayload>
          }
          aggregate: {
            args: Prisma.PlayerPodHolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerPodHolder>
          }
          groupBy: {
            args: Prisma.PlayerPodHolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerPodHolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerPodHolderCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerPodHolderCountAggregateOutputType> | number
          }
        }
      }
      PodStatus: {
        payload: Prisma.$PodStatusPayload<ExtArgs>
        fields: Prisma.PodStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          findFirst: {
            args: Prisma.PodStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          findMany: {
            args: Prisma.PodStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>[]
          }
          create: {
            args: Prisma.PodStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          createMany: {
            args: Prisma.PodStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>[]
          }
          delete: {
            args: Prisma.PodStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          update: {
            args: Prisma.PodStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          deleteMany: {
            args: Prisma.PodStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>[]
          }
          upsert: {
            args: Prisma.PodStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodStatusPayload>
          }
          aggregate: {
            args: Prisma.PodStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodStatus>
          }
          groupBy: {
            args: Prisma.PodStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PodStatusCountAggregateOutputType> | number
          }
        }
      }
      PodHolderStatus: {
        payload: Prisma.$PodHolderStatusPayload<ExtArgs>
        fields: Prisma.PodHolderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PodHolderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PodHolderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          findFirst: {
            args: Prisma.PodHolderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PodHolderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          findMany: {
            args: Prisma.PodHolderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>[]
          }
          create: {
            args: Prisma.PodHolderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          createMany: {
            args: Prisma.PodHolderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PodHolderStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>[]
          }
          delete: {
            args: Prisma.PodHolderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          update: {
            args: Prisma.PodHolderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          deleteMany: {
            args: Prisma.PodHolderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PodHolderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PodHolderStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>[]
          }
          upsert: {
            args: Prisma.PodHolderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PodHolderStatusPayload>
          }
          aggregate: {
            args: Prisma.PodHolderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodHolderStatus>
          }
          groupBy: {
            args: Prisma.PodHolderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodHolderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PodHolderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PodHolderStatusCountAggregateOutputType> | number
          }
        }
      }
      RawData: {
        payload: Prisma.$RawDataPayload<ExtArgs>
        fields: Prisma.RawDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          findFirst: {
            args: Prisma.RawDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          findMany: {
            args: Prisma.RawDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>[]
          }
          create: {
            args: Prisma.RawDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          createMany: {
            args: Prisma.RawDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>[]
          }
          delete: {
            args: Prisma.RawDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          update: {
            args: Prisma.RawDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          deleteMany: {
            args: Prisma.RawDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RawDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>[]
          }
          upsert: {
            args: Prisma.RawDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDataPayload>
          }
          aggregate: {
            args: Prisma.RawDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawData>
          }
          groupBy: {
            args: Prisma.RawDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawDataCountArgs<ExtArgs>
            result: $Utils.Optional<RawDataCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventParticipant: {
        payload: Prisma.$EventParticipantPayload<ExtArgs>
        fields: Prisma.EventParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          findFirst: {
            args: Prisma.EventParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          findMany: {
            args: Prisma.EventParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[]
          }
          create: {
            args: Prisma.EventParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          createMany: {
            args: Prisma.EventParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[]
          }
          delete: {
            args: Prisma.EventParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          update: {
            args: Prisma.EventParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          deleteMany: {
            args: Prisma.EventParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[]
          }
          upsert: {
            args: Prisma.EventParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>
          }
          aggregate: {
            args: Prisma.EventParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventParticipant>
          }
          groupBy: {
            args: Prisma.EventParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<EventParticipantCountAggregateOutputType> | number
          }
        }
      }
      PaymentPlan: {
        payload: Prisma.$PaymentPlanPayload<ExtArgs>
        fields: Prisma.PaymentPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          findFirst: {
            args: Prisma.PaymentPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          findMany: {
            args: Prisma.PaymentPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          create: {
            args: Prisma.PaymentPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          createMany: {
            args: Prisma.PaymentPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          delete: {
            args: Prisma.PaymentPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          update: {
            args: Prisma.PaymentPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          deleteMany: {
            args: Prisma.PaymentPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          upsert: {
            args: Prisma.PaymentPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          aggregate: {
            args: Prisma.PaymentPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentPlan>
          }
          groupBy: {
            args: Prisma.PaymentPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ServiceRequest: {
        payload: Prisma.$ServiceRequestPayload<ExtArgs>
        fields: Prisma.ServiceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findFirst: {
            args: Prisma.ServiceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findMany: {
            args: Prisma.ServiceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          create: {
            args: Prisma.ServiceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          createMany: {
            args: Prisma.ServiceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          delete: {
            args: Prisma.ServiceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          update: {
            args: Prisma.ServiceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          upsert: {
            args: Prisma.ServiceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          aggregate: {
            args: Prisma.ServiceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRequest>
          }
          groupBy: {
            args: Prisma.ServiceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestCountAggregateOutputType> | number
          }
        }
      }
      ActivityMetric: {
        payload: Prisma.$ActivityMetricPayload<ExtArgs>
        fields: Prisma.ActivityMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          findFirst: {
            args: Prisma.ActivityMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          findMany: {
            args: Prisma.ActivityMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>[]
          }
          create: {
            args: Prisma.ActivityMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          createMany: {
            args: Prisma.ActivityMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>[]
          }
          delete: {
            args: Prisma.ActivityMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          update: {
            args: Prisma.ActivityMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          deleteMany: {
            args: Prisma.ActivityMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>[]
          }
          upsert: {
            args: Prisma.ActivityMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityMetricPayload>
          }
          aggregate: {
            args: Prisma.ActivityMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityMetric>
          }
          groupBy: {
            args: Prisma.ActivityMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityMetricCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    superAdmin?: SuperAdminOmit
    club?: ClubOmit
    clubAdmin?: ClubAdminOmit
    coach?: CoachOmit
    player?: PlayerOmit
    pod?: PodOmit
    podHolder?: PodHolderOmit
    podHolderAudit?: PodHolderAuditOmit
    podAllocation?: PodAllocationOmit
    coachAssignment?: CoachAssignmentOmit
    playerPod?: PlayerPodOmit
    playerPodHolder?: PlayerPodHolderOmit
    podStatus?: PodStatusOmit
    podHolderStatus?: PodHolderStatusOmit
    rawData?: RawDataOmit
    event?: EventOmit
    eventParticipant?: EventParticipantOmit
    paymentPlan?: PaymentPlanOmit
    subscription?: SubscriptionOmit
    payment?: PaymentOmit
    serviceRequest?: ServiceRequestOmit
    activityMetric?: ActivityMetricOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SuperAdminCountOutputType
   */

  export type SuperAdminCountOutputType = {
    clubs: number
  }

  export type SuperAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubs?: boolean | SuperAdminCountOutputTypeCountClubsArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminCountOutputType
     */
    select?: SuperAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeCountClubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
  }


  /**
   * Count Type ClubCountOutputType
   */

  export type ClubCountOutputType = {
    club_admins: number
    pod_holders: number
    coaches: number
    events: number
    players: number
    serviceRequests: number
    subscriptions: number
  }

  export type ClubCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club_admins?: boolean | ClubCountOutputTypeCountClub_adminsArgs
    pod_holders?: boolean | ClubCountOutputTypeCountPod_holdersArgs
    coaches?: boolean | ClubCountOutputTypeCountCoachesArgs
    events?: boolean | ClubCountOutputTypeCountEventsArgs
    players?: boolean | ClubCountOutputTypeCountPlayersArgs
    serviceRequests?: boolean | ClubCountOutputTypeCountServiceRequestsArgs
    subscriptions?: boolean | ClubCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubCountOutputType
     */
    select?: ClubCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountClub_adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubAdminWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountPod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type CoachCountOutputType
   */

  export type CoachCountOutputType = {
    coach_assignments: number
    event_participants: number
    pod_allocations: number
  }

  export type CoachCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach_assignments?: boolean | CoachCountOutputTypeCountCoach_assignmentsArgs
    event_participants?: boolean | CoachCountOutputTypeCountEvent_participantsArgs
    pod_allocations?: boolean | CoachCountOutputTypeCountPod_allocationsArgs
  }

  // Custom InputTypes
  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCountOutputType
     */
    select?: CoachCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountCoach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAssignmentWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountEvent_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountPod_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodAllocationWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    activity_metrics: number
    coach_assignments: number
    event_participants: number
    player_pod_holders: number
    player_pods: number
    raw_data: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_metrics?: boolean | PlayerCountOutputTypeCountActivity_metricsArgs
    coach_assignments?: boolean | PlayerCountOutputTypeCountCoach_assignmentsArgs
    event_participants?: boolean | PlayerCountOutputTypeCountEvent_participantsArgs
    player_pod_holders?: boolean | PlayerCountOutputTypeCountPlayer_pod_holdersArgs
    player_pods?: boolean | PlayerCountOutputTypeCountPlayer_podsArgs
    raw_data?: boolean | PlayerCountOutputTypeCountRaw_dataArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountActivity_metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityMetricWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCoach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAssignmentWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountEvent_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_pod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodHolderWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountRaw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawDataWhereInput
  }


  /**
   * Count Type PodCountOutputType
   */

  export type PodCountOutputType = {
    coach_assignments: number
    player_pods: number
    pod_allocations: number
    pod_statuses: number
    raw_data: number
  }

  export type PodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach_assignments?: boolean | PodCountOutputTypeCountCoach_assignmentsArgs
    player_pods?: boolean | PodCountOutputTypeCountPlayer_podsArgs
    pod_allocations?: boolean | PodCountOutputTypeCountPod_allocationsArgs
    pod_statuses?: boolean | PodCountOutputTypeCountPod_statusesArgs
    raw_data?: boolean | PodCountOutputTypeCountRaw_dataArgs
  }

  // Custom InputTypes
  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodCountOutputType
     */
    select?: PodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountCoach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAssignmentWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountPlayer_podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountPod_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodAllocationWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountPod_statusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodStatusWhereInput
  }

  /**
   * PodCountOutputType without action
   */
  export type PodCountOutputTypeCountRaw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawDataWhereInput
  }


  /**
   * Count Type PodHolderCountOutputType
   */

  export type PodHolderCountOutputType = {
    audits: number
    coach_assignments: number
    player_pod_holders: number
    pod_holder_statuses: number
  }

  export type PodHolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | PodHolderCountOutputTypeCountAuditsArgs
    coach_assignments?: boolean | PodHolderCountOutputTypeCountCoach_assignmentsArgs
    player_pod_holders?: boolean | PodHolderCountOutputTypeCountPlayer_pod_holdersArgs
    pod_holder_statuses?: boolean | PodHolderCountOutputTypeCountPod_holder_statusesArgs
  }

  // Custom InputTypes
  /**
   * PodHolderCountOutputType without action
   */
  export type PodHolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderCountOutputType
     */
    select?: PodHolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PodHolderCountOutputType without action
   */
  export type PodHolderCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderAuditWhereInput
  }

  /**
   * PodHolderCountOutputType without action
   */
  export type PodHolderCountOutputTypeCountCoach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAssignmentWhereInput
  }

  /**
   * PodHolderCountOutputType without action
   */
  export type PodHolderCountOutputTypeCountPlayer_pod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodHolderWhereInput
  }

  /**
   * PodHolderCountOutputType without action
   */
  export type PodHolderCountOutputTypeCountPod_holder_statusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderStatusWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    event_participants: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event_participants?: boolean | EventCountOutputTypeCountEvent_participantsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEvent_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
  }


  /**
   * Count Type PaymentPlanCountOutputType
   */

  export type PaymentPlanCountOutputType = {
    subscriptions: number
  }

  export type PaymentPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PaymentPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PaymentPlanCountOutputType without action
   */
  export type PaymentPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlanCountOutputType
     */
    select?: PaymentPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentPlanCountOutputType without action
   */
  export type PaymentPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    super_admin_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    profile_image: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    super_admin_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password_hash: string | null
    profile_image: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type SuperAdminCountAggregateOutputType = {
    super_admin_id: number
    name: number
    email: number
    phone: number
    password_hash: number
    profile_image: number
    created_at: number
    updated_at: number
    reset_token: number
    reset_token_expires: number
    login_otp: number
    login_otp_expires: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    super_admin_id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    super_admin_id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type SuperAdminCountAggregateInputType = {
    super_admin_id?: true
    name?: true
    email?: true
    phone?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    super_admin_id: string
    name: string | null
    email: string
    phone: string | null
    password_hash: string
    profile_image: string | null
    created_at: Date
    updated_at: Date
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    super_admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    clubs?: boolean | SuperAdmin$clubsArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    super_admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    super_admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectScalar = {
    super_admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"super_admin_id" | "name" | "email" | "phone" | "password_hash" | "profile_image" | "created_at" | "updated_at" | "reset_token" | "reset_token_expires" | "login_otp" | "login_otp_expires", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubs?: boolean | SuperAdmin$clubsArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      clubs: Prisma.$ClubPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      super_admin_id: string
      name: string | null
      email: string
      phone: string | null
      password_hash: string
      profile_image: string | null
      created_at: Date
      updated_at: Date
      reset_token: string | null
      reset_token_expires: Date | null
      login_otp: string | null
      login_otp_expires: Date | null
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `super_admin_id`
     * const superAdminWithSuper_admin_idOnly = await prisma.superAdmin.findMany({ select: { super_admin_id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {SuperAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `super_admin_id`
     * const superAdminWithSuper_admin_idOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { super_admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {SuperAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `super_admin_id`
     * const superAdminWithSuper_admin_idOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { super_admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clubs<T extends SuperAdmin$clubsArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$clubsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly super_admin_id: FieldRef<"SuperAdmin", 'String'>
    readonly name: FieldRef<"SuperAdmin", 'String'>
    readonly email: FieldRef<"SuperAdmin", 'String'>
    readonly phone: FieldRef<"SuperAdmin", 'String'>
    readonly password_hash: FieldRef<"SuperAdmin", 'String'>
    readonly profile_image: FieldRef<"SuperAdmin", 'String'>
    readonly created_at: FieldRef<"SuperAdmin", 'DateTime'>
    readonly updated_at: FieldRef<"SuperAdmin", 'DateTime'>
    readonly reset_token: FieldRef<"SuperAdmin", 'String'>
    readonly reset_token_expires: FieldRef<"SuperAdmin", 'DateTime'>
    readonly login_otp: FieldRef<"SuperAdmin", 'String'>
    readonly login_otp_expires: FieldRef<"SuperAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin createManyAndReturn
   */
  export type SuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin updateManyAndReturn
   */
  export type SuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.clubs
   */
  export type SuperAdmin$clubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    cursor?: ClubWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Club
   */

  export type AggregateClub = {
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  export type ClubMinAggregateOutputType = {
    club_id: string | null
    super_admin_id: string | null
    club_name: string | null
    address: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    sport: string | null
  }

  export type ClubMaxAggregateOutputType = {
    club_id: string | null
    super_admin_id: string | null
    club_name: string | null
    address: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    sport: string | null
  }

  export type ClubCountAggregateOutputType = {
    club_id: number
    super_admin_id: number
    club_name: number
    address: number
    status: number
    created_at: number
    updated_at: number
    sport: number
    _all: number
  }


  export type ClubMinAggregateInputType = {
    club_id?: true
    super_admin_id?: true
    club_name?: true
    address?: true
    status?: true
    created_at?: true
    updated_at?: true
    sport?: true
  }

  export type ClubMaxAggregateInputType = {
    club_id?: true
    super_admin_id?: true
    club_name?: true
    address?: true
    status?: true
    created_at?: true
    updated_at?: true
    sport?: true
  }

  export type ClubCountAggregateInputType = {
    club_id?: true
    super_admin_id?: true
    club_name?: true
    address?: true
    status?: true
    created_at?: true
    updated_at?: true
    sport?: true
    _all?: true
  }

  export type ClubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Club to aggregate.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clubs
    **/
    _count?: true | ClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubMaxAggregateInputType
  }

  export type GetClubAggregateType<T extends ClubAggregateArgs> = {
        [P in keyof T & keyof AggregateClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClub[P]>
      : GetScalarType<T[P], AggregateClub[P]>
  }




  export type ClubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithAggregationInput | ClubOrderByWithAggregationInput[]
    by: ClubScalarFieldEnum[] | ClubScalarFieldEnum
    having?: ClubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubCountAggregateInputType | true
    _min?: ClubMinAggregateInputType
    _max?: ClubMaxAggregateInputType
  }

  export type ClubGroupByOutputType = {
    club_id: string
    super_admin_id: string | null
    club_name: string | null
    address: string | null
    status: string | null
    created_at: Date
    updated_at: Date
    sport: string | null
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  type GetClubGroupByPayload<T extends ClubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubGroupByOutputType[P]>
            : GetScalarType<T[P], ClubGroupByOutputType[P]>
        }
      >
    >


  export type ClubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    club_id?: boolean
    super_admin_id?: boolean
    club_name?: boolean
    address?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sport?: boolean
    club_admins?: boolean | Club$club_adminsArgs<ExtArgs>
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
    pod_holders?: boolean | Club$pod_holdersArgs<ExtArgs>
    coaches?: boolean | Club$coachesArgs<ExtArgs>
    events?: boolean | Club$eventsArgs<ExtArgs>
    players?: boolean | Club$playersArgs<ExtArgs>
    serviceRequests?: boolean | Club$serviceRequestsArgs<ExtArgs>
    subscriptions?: boolean | Club$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    club_id?: boolean
    super_admin_id?: boolean
    club_name?: boolean
    address?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sport?: boolean
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    club_id?: boolean
    super_admin_id?: boolean
    club_name?: boolean
    address?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sport?: boolean
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectScalar = {
    club_id?: boolean
    super_admin_id?: boolean
    club_name?: boolean
    address?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sport?: boolean
  }

  export type ClubOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"club_id" | "super_admin_id" | "club_name" | "address" | "status" | "created_at" | "updated_at" | "sport", ExtArgs["result"]["club"]>
  export type ClubInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club_admins?: boolean | Club$club_adminsArgs<ExtArgs>
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
    pod_holders?: boolean | Club$pod_holdersArgs<ExtArgs>
    coaches?: boolean | Club$coachesArgs<ExtArgs>
    events?: boolean | Club$eventsArgs<ExtArgs>
    players?: boolean | Club$playersArgs<ExtArgs>
    serviceRequests?: boolean | Club$serviceRequestsArgs<ExtArgs>
    subscriptions?: boolean | Club$subscriptionsArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClubIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
  }
  export type ClubIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    super_admin?: boolean | Club$super_adminArgs<ExtArgs>
  }

  export type $ClubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Club"
    objects: {
      club_admins: Prisma.$ClubAdminPayload<ExtArgs>[]
      super_admin: Prisma.$SuperAdminPayload<ExtArgs> | null
      pod_holders: Prisma.$PodHolderPayload<ExtArgs>[]
      coaches: Prisma.$CoachPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      players: Prisma.$PlayerPayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      club_id: string
      super_admin_id: string | null
      club_name: string | null
      address: string | null
      status: string | null
      created_at: Date
      updated_at: Date
      sport: string | null
    }, ExtArgs["result"]["club"]>
    composites: {}
  }

  type ClubGetPayload<S extends boolean | null | undefined | ClubDefaultArgs> = $Result.GetResult<Prisma.$ClubPayload, S>

  type ClubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubCountAggregateInputType | true
    }

  export interface ClubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Club'], meta: { name: 'Club' } }
    /**
     * Find zero or one Club that matches the filter.
     * @param {ClubFindUniqueArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubFindUniqueArgs>(args: SelectSubset<T, ClubFindUniqueArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Club that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubFindUniqueOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubFindFirstArgs>(args?: SelectSubset<T, ClubFindFirstArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clubs
     * const clubs = await prisma.club.findMany()
     * 
     * // Get first 10 Clubs
     * const clubs = await prisma.club.findMany({ take: 10 })
     * 
     * // Only select the `club_id`
     * const clubWithClub_idOnly = await prisma.club.findMany({ select: { club_id: true } })
     * 
     */
    findMany<T extends ClubFindManyArgs>(args?: SelectSubset<T, ClubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Club.
     * @param {ClubCreateArgs} args - Arguments to create a Club.
     * @example
     * // Create one Club
     * const Club = await prisma.club.create({
     *   data: {
     *     // ... data to create a Club
     *   }
     * })
     * 
     */
    create<T extends ClubCreateArgs>(args: SelectSubset<T, ClubCreateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clubs.
     * @param {ClubCreateManyArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubCreateManyArgs>(args?: SelectSubset<T, ClubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clubs and returns the data saved in the database.
     * @param {ClubCreateManyAndReturnArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clubs and only return the `club_id`
     * const clubWithClub_idOnly = await prisma.club.createManyAndReturn({
     *   select: { club_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Club.
     * @param {ClubDeleteArgs} args - Arguments to delete one Club.
     * @example
     * // Delete one Club
     * const Club = await prisma.club.delete({
     *   where: {
     *     // ... filter to delete one Club
     *   }
     * })
     * 
     */
    delete<T extends ClubDeleteArgs>(args: SelectSubset<T, ClubDeleteArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Club.
     * @param {ClubUpdateArgs} args - Arguments to update one Club.
     * @example
     * // Update one Club
     * const club = await prisma.club.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubUpdateArgs>(args: SelectSubset<T, ClubUpdateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clubs.
     * @param {ClubDeleteManyArgs} args - Arguments to filter Clubs to delete.
     * @example
     * // Delete a few Clubs
     * const { count } = await prisma.club.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubDeleteManyArgs>(args?: SelectSubset<T, ClubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubUpdateManyArgs>(args: SelectSubset<T, ClubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs and returns the data updated in the database.
     * @param {ClubUpdateManyAndReturnArgs} args - Arguments to update many Clubs.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clubs and only return the `club_id`
     * const clubWithClub_idOnly = await prisma.club.updateManyAndReturn({
     *   select: { club_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Club.
     * @param {ClubUpsertArgs} args - Arguments to update or create a Club.
     * @example
     * // Update or create a Club
     * const club = await prisma.club.upsert({
     *   create: {
     *     // ... data to create a Club
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Club we want to update
     *   }
     * })
     */
    upsert<T extends ClubUpsertArgs>(args: SelectSubset<T, ClubUpsertArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubCountArgs} args - Arguments to filter Clubs to count.
     * @example
     * // Count the number of Clubs
     * const count = await prisma.club.count({
     *   where: {
     *     // ... the filter for the Clubs we want to count
     *   }
     * })
    **/
    count<T extends ClubCountArgs>(
      args?: Subset<T, ClubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubAggregateArgs>(args: Subset<T, ClubAggregateArgs>): Prisma.PrismaPromise<GetClubAggregateType<T>>

    /**
     * Group by Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubGroupByArgs['orderBy'] }
        : { orderBy?: ClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Club model
   */
  readonly fields: ClubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Club.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club_admins<T extends Club$club_adminsArgs<ExtArgs> = {}>(args?: Subset<T, Club$club_adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    super_admin<T extends Club$super_adminArgs<ExtArgs> = {}>(args?: Subset<T, Club$super_adminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pod_holders<T extends Club$pod_holdersArgs<ExtArgs> = {}>(args?: Subset<T, Club$pod_holdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coaches<T extends Club$coachesArgs<ExtArgs> = {}>(args?: Subset<T, Club$coachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Club$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Club$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    players<T extends Club$playersArgs<ExtArgs> = {}>(args?: Subset<T, Club$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceRequests<T extends Club$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Club$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Club$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Club$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Club model
   */
  interface ClubFieldRefs {
    readonly club_id: FieldRef<"Club", 'String'>
    readonly super_admin_id: FieldRef<"Club", 'String'>
    readonly club_name: FieldRef<"Club", 'String'>
    readonly address: FieldRef<"Club", 'String'>
    readonly status: FieldRef<"Club", 'String'>
    readonly created_at: FieldRef<"Club", 'DateTime'>
    readonly updated_at: FieldRef<"Club", 'DateTime'>
    readonly sport: FieldRef<"Club", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Club findUnique
   */
  export type ClubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findUniqueOrThrow
   */
  export type ClubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findFirst
   */
  export type ClubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findFirstOrThrow
   */
  export type ClubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findMany
   */
  export type ClubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Clubs to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club create
   */
  export type ClubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to create a Club.
     */
    data?: XOR<ClubCreateInput, ClubUncheckedCreateInput>
  }

  /**
   * Club createMany
   */
  export type ClubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Club createManyAndReturn
   */
  export type ClubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club update
   */
  export type ClubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to update a Club.
     */
    data: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
    /**
     * Choose, which Club to update.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club updateMany
   */
  export type ClubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
  }

  /**
   * Club updateManyAndReturn
   */
  export type ClubUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club upsert
   */
  export type ClubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The filter to search for the Club to update in case it exists.
     */
    where: ClubWhereUniqueInput
    /**
     * In case the Club found by the `where` argument doesn't exist, create a new Club with this data.
     */
    create: XOR<ClubCreateInput, ClubUncheckedCreateInput>
    /**
     * In case the Club was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
  }

  /**
   * Club delete
   */
  export type ClubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter which Club to delete.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club deleteMany
   */
  export type ClubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clubs to delete
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to delete.
     */
    limit?: number
  }

  /**
   * Club.club_admins
   */
  export type Club$club_adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    where?: ClubAdminWhereInput
    orderBy?: ClubAdminOrderByWithRelationInput | ClubAdminOrderByWithRelationInput[]
    cursor?: ClubAdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubAdminScalarFieldEnum | ClubAdminScalarFieldEnum[]
  }

  /**
   * Club.super_admin
   */
  export type Club$super_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * Club.pod_holders
   */
  export type Club$pod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    where?: PodHolderWhereInput
    orderBy?: PodHolderOrderByWithRelationInput | PodHolderOrderByWithRelationInput[]
    cursor?: PodHolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodHolderScalarFieldEnum | PodHolderScalarFieldEnum[]
  }

  /**
   * Club.coaches
   */
  export type Club$coachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    cursor?: CoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Club.events
   */
  export type Club$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Club.players
   */
  export type Club$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Club.serviceRequests
   */
  export type Club$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Club.subscriptions
   */
  export type Club$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Club without action
   */
  export type ClubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
  }


  /**
   * Model ClubAdmin
   */

  export type AggregateClubAdmin = {
    _count: ClubAdminCountAggregateOutputType | null
    _min: ClubAdminMinAggregateOutputType | null
    _max: ClubAdminMaxAggregateOutputType | null
  }

  export type ClubAdminMinAggregateOutputType = {
    admin_id: string | null
    club_id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    profile_image: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type ClubAdminMaxAggregateOutputType = {
    admin_id: string | null
    club_id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    profile_image: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type ClubAdminCountAggregateOutputType = {
    admin_id: number
    club_id: number
    name: number
    phone: number
    email: number
    password_hash: number
    profile_image: number
    created_at: number
    updated_at: number
    reset_token: number
    reset_token_expires: number
    login_otp: number
    login_otp_expires: number
    _all: number
  }


  export type ClubAdminMinAggregateInputType = {
    admin_id?: true
    club_id?: true
    name?: true
    phone?: true
    email?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type ClubAdminMaxAggregateInputType = {
    admin_id?: true
    club_id?: true
    name?: true
    phone?: true
    email?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type ClubAdminCountAggregateInputType = {
    admin_id?: true
    club_id?: true
    name?: true
    phone?: true
    email?: true
    password_hash?: true
    profile_image?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
    _all?: true
  }

  export type ClubAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubAdmin to aggregate.
     */
    where?: ClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubAdmins to fetch.
     */
    orderBy?: ClubAdminOrderByWithRelationInput | ClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubAdmins
    **/
    _count?: true | ClubAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubAdminMaxAggregateInputType
  }

  export type GetClubAdminAggregateType<T extends ClubAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateClubAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubAdmin[P]>
      : GetScalarType<T[P], AggregateClubAdmin[P]>
  }




  export type ClubAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubAdminWhereInput
    orderBy?: ClubAdminOrderByWithAggregationInput | ClubAdminOrderByWithAggregationInput[]
    by: ClubAdminScalarFieldEnum[] | ClubAdminScalarFieldEnum
    having?: ClubAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubAdminCountAggregateInputType | true
    _min?: ClubAdminMinAggregateInputType
    _max?: ClubAdminMaxAggregateInputType
  }

  export type ClubAdminGroupByOutputType = {
    admin_id: string
    club_id: string
    name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    profile_image: string | null
    created_at: Date
    updated_at: Date
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
    _count: ClubAdminCountAggregateOutputType | null
    _min: ClubAdminMinAggregateOutputType | null
    _max: ClubAdminMaxAggregateOutputType | null
  }

  type GetClubAdminGroupByPayload<T extends ClubAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubAdminGroupByOutputType[P]>
            : GetScalarType<T[P], ClubAdminGroupByOutputType[P]>
        }
      >
    >


  export type ClubAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    club_id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubAdmin"]>

  export type ClubAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    club_id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubAdmin"]>

  export type ClubAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    club_id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubAdmin"]>

  export type ClubAdminSelectScalar = {
    admin_id?: boolean
    club_id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    profile_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
  }

  export type ClubAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"admin_id" | "club_id" | "name" | "phone" | "email" | "password_hash" | "profile_image" | "created_at" | "updated_at" | "reset_token" | "reset_token_expires" | "login_otp" | "login_otp_expires", ExtArgs["result"]["clubAdmin"]>
  export type ClubAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type ClubAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type ClubAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }

  export type $ClubAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubAdmin"
    objects: {
      club: Prisma.$ClubPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      admin_id: string
      club_id: string
      name: string | null
      phone: string | null
      email: string | null
      password_hash: string | null
      profile_image: string | null
      created_at: Date
      updated_at: Date
      reset_token: string | null
      reset_token_expires: Date | null
      login_otp: string | null
      login_otp_expires: Date | null
    }, ExtArgs["result"]["clubAdmin"]>
    composites: {}
  }

  type ClubAdminGetPayload<S extends boolean | null | undefined | ClubAdminDefaultArgs> = $Result.GetResult<Prisma.$ClubAdminPayload, S>

  type ClubAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubAdminCountAggregateInputType | true
    }

  export interface ClubAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubAdmin'], meta: { name: 'ClubAdmin' } }
    /**
     * Find zero or one ClubAdmin that matches the filter.
     * @param {ClubAdminFindUniqueArgs} args - Arguments to find a ClubAdmin
     * @example
     * // Get one ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubAdminFindUniqueArgs>(args: SelectSubset<T, ClubAdminFindUniqueArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubAdminFindUniqueOrThrowArgs} args - Arguments to find a ClubAdmin
     * @example
     * // Get one ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminFindFirstArgs} args - Arguments to find a ClubAdmin
     * @example
     * // Get one ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubAdminFindFirstArgs>(args?: SelectSubset<T, ClubAdminFindFirstArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminFindFirstOrThrowArgs} args - Arguments to find a ClubAdmin
     * @example
     * // Get one ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubAdmins
     * const clubAdmins = await prisma.clubAdmin.findMany()
     * 
     * // Get first 10 ClubAdmins
     * const clubAdmins = await prisma.clubAdmin.findMany({ take: 10 })
     * 
     * // Only select the `admin_id`
     * const clubAdminWithAdmin_idOnly = await prisma.clubAdmin.findMany({ select: { admin_id: true } })
     * 
     */
    findMany<T extends ClubAdminFindManyArgs>(args?: SelectSubset<T, ClubAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubAdmin.
     * @param {ClubAdminCreateArgs} args - Arguments to create a ClubAdmin.
     * @example
     * // Create one ClubAdmin
     * const ClubAdmin = await prisma.clubAdmin.create({
     *   data: {
     *     // ... data to create a ClubAdmin
     *   }
     * })
     * 
     */
    create<T extends ClubAdminCreateArgs>(args: SelectSubset<T, ClubAdminCreateArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubAdmins.
     * @param {ClubAdminCreateManyArgs} args - Arguments to create many ClubAdmins.
     * @example
     * // Create many ClubAdmins
     * const clubAdmin = await prisma.clubAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubAdminCreateManyArgs>(args?: SelectSubset<T, ClubAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubAdmins and returns the data saved in the database.
     * @param {ClubAdminCreateManyAndReturnArgs} args - Arguments to create many ClubAdmins.
     * @example
     * // Create many ClubAdmins
     * const clubAdmin = await prisma.clubAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubAdmins and only return the `admin_id`
     * const clubAdminWithAdmin_idOnly = await prisma.clubAdmin.createManyAndReturn({
     *   select: { admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubAdmin.
     * @param {ClubAdminDeleteArgs} args - Arguments to delete one ClubAdmin.
     * @example
     * // Delete one ClubAdmin
     * const ClubAdmin = await prisma.clubAdmin.delete({
     *   where: {
     *     // ... filter to delete one ClubAdmin
     *   }
     * })
     * 
     */
    delete<T extends ClubAdminDeleteArgs>(args: SelectSubset<T, ClubAdminDeleteArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubAdmin.
     * @param {ClubAdminUpdateArgs} args - Arguments to update one ClubAdmin.
     * @example
     * // Update one ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubAdminUpdateArgs>(args: SelectSubset<T, ClubAdminUpdateArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubAdmins.
     * @param {ClubAdminDeleteManyArgs} args - Arguments to filter ClubAdmins to delete.
     * @example
     * // Delete a few ClubAdmins
     * const { count } = await prisma.clubAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubAdminDeleteManyArgs>(args?: SelectSubset<T, ClubAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubAdmins
     * const clubAdmin = await prisma.clubAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubAdminUpdateManyArgs>(args: SelectSubset<T, ClubAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubAdmins and returns the data updated in the database.
     * @param {ClubAdminUpdateManyAndReturnArgs} args - Arguments to update many ClubAdmins.
     * @example
     * // Update many ClubAdmins
     * const clubAdmin = await prisma.clubAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubAdmins and only return the `admin_id`
     * const clubAdminWithAdmin_idOnly = await prisma.clubAdmin.updateManyAndReturn({
     *   select: { admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubAdmin.
     * @param {ClubAdminUpsertArgs} args - Arguments to update or create a ClubAdmin.
     * @example
     * // Update or create a ClubAdmin
     * const clubAdmin = await prisma.clubAdmin.upsert({
     *   create: {
     *     // ... data to create a ClubAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubAdmin we want to update
     *   }
     * })
     */
    upsert<T extends ClubAdminUpsertArgs>(args: SelectSubset<T, ClubAdminUpsertArgs<ExtArgs>>): Prisma__ClubAdminClient<$Result.GetResult<Prisma.$ClubAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminCountArgs} args - Arguments to filter ClubAdmins to count.
     * @example
     * // Count the number of ClubAdmins
     * const count = await prisma.clubAdmin.count({
     *   where: {
     *     // ... the filter for the ClubAdmins we want to count
     *   }
     * })
    **/
    count<T extends ClubAdminCountArgs>(
      args?: Subset<T, ClubAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubAdminAggregateArgs>(args: Subset<T, ClubAdminAggregateArgs>): Prisma.PrismaPromise<GetClubAdminAggregateType<T>>

    /**
     * Group by ClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubAdminGroupByArgs['orderBy'] }
        : { orderBy?: ClubAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubAdmin model
   */
  readonly fields: ClubAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubAdmin model
   */
  interface ClubAdminFieldRefs {
    readonly admin_id: FieldRef<"ClubAdmin", 'String'>
    readonly club_id: FieldRef<"ClubAdmin", 'String'>
    readonly name: FieldRef<"ClubAdmin", 'String'>
    readonly phone: FieldRef<"ClubAdmin", 'String'>
    readonly email: FieldRef<"ClubAdmin", 'String'>
    readonly password_hash: FieldRef<"ClubAdmin", 'String'>
    readonly profile_image: FieldRef<"ClubAdmin", 'String'>
    readonly created_at: FieldRef<"ClubAdmin", 'DateTime'>
    readonly updated_at: FieldRef<"ClubAdmin", 'DateTime'>
    readonly reset_token: FieldRef<"ClubAdmin", 'String'>
    readonly reset_token_expires: FieldRef<"ClubAdmin", 'DateTime'>
    readonly login_otp: FieldRef<"ClubAdmin", 'String'>
    readonly login_otp_expires: FieldRef<"ClubAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubAdmin findUnique
   */
  export type ClubAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClubAdmin to fetch.
     */
    where: ClubAdminWhereUniqueInput
  }

  /**
   * ClubAdmin findUniqueOrThrow
   */
  export type ClubAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClubAdmin to fetch.
     */
    where: ClubAdminWhereUniqueInput
  }

  /**
   * ClubAdmin findFirst
   */
  export type ClubAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClubAdmin to fetch.
     */
    where?: ClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubAdmins to fetch.
     */
    orderBy?: ClubAdminOrderByWithRelationInput | ClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubAdmins.
     */
    cursor?: ClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubAdmins.
     */
    distinct?: ClubAdminScalarFieldEnum | ClubAdminScalarFieldEnum[]
  }

  /**
   * ClubAdmin findFirstOrThrow
   */
  export type ClubAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClubAdmin to fetch.
     */
    where?: ClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubAdmins to fetch.
     */
    orderBy?: ClubAdminOrderByWithRelationInput | ClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubAdmins.
     */
    cursor?: ClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubAdmins.
     */
    distinct?: ClubAdminScalarFieldEnum | ClubAdminScalarFieldEnum[]
  }

  /**
   * ClubAdmin findMany
   */
  export type ClubAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClubAdmins to fetch.
     */
    where?: ClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubAdmins to fetch.
     */
    orderBy?: ClubAdminOrderByWithRelationInput | ClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubAdmins.
     */
    cursor?: ClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubAdmins.
     */
    skip?: number
    distinct?: ClubAdminScalarFieldEnum | ClubAdminScalarFieldEnum[]
  }

  /**
   * ClubAdmin create
   */
  export type ClubAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubAdmin.
     */
    data: XOR<ClubAdminCreateInput, ClubAdminUncheckedCreateInput>
  }

  /**
   * ClubAdmin createMany
   */
  export type ClubAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubAdmins.
     */
    data: ClubAdminCreateManyInput | ClubAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClubAdmin createManyAndReturn
   */
  export type ClubAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * The data used to create many ClubAdmins.
     */
    data: ClubAdminCreateManyInput | ClubAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubAdmin update
   */
  export type ClubAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubAdmin.
     */
    data: XOR<ClubAdminUpdateInput, ClubAdminUncheckedUpdateInput>
    /**
     * Choose, which ClubAdmin to update.
     */
    where: ClubAdminWhereUniqueInput
  }

  /**
   * ClubAdmin updateMany
   */
  export type ClubAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubAdmins.
     */
    data: XOR<ClubAdminUpdateManyMutationInput, ClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which ClubAdmins to update
     */
    where?: ClubAdminWhereInput
    /**
     * Limit how many ClubAdmins to update.
     */
    limit?: number
  }

  /**
   * ClubAdmin updateManyAndReturn
   */
  export type ClubAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * The data used to update ClubAdmins.
     */
    data: XOR<ClubAdminUpdateManyMutationInput, ClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which ClubAdmins to update
     */
    where?: ClubAdminWhereInput
    /**
     * Limit how many ClubAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubAdmin upsert
   */
  export type ClubAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubAdmin to update in case it exists.
     */
    where: ClubAdminWhereUniqueInput
    /**
     * In case the ClubAdmin found by the `where` argument doesn't exist, create a new ClubAdmin with this data.
     */
    create: XOR<ClubAdminCreateInput, ClubAdminUncheckedCreateInput>
    /**
     * In case the ClubAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubAdminUpdateInput, ClubAdminUncheckedUpdateInput>
  }

  /**
   * ClubAdmin delete
   */
  export type ClubAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
    /**
     * Filter which ClubAdmin to delete.
     */
    where: ClubAdminWhereUniqueInput
  }

  /**
   * ClubAdmin deleteMany
   */
  export type ClubAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubAdmins to delete
     */
    where?: ClubAdminWhereInput
    /**
     * Limit how many ClubAdmins to delete.
     */
    limit?: number
  }

  /**
   * ClubAdmin without action
   */
  export type ClubAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubAdmin
     */
    select?: ClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubAdmin
     */
    omit?: ClubAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubAdminInclude<ExtArgs> | null
  }


  /**
   * Model Coach
   */

  export type AggregateCoach = {
    _count: CoachCountAggregateOutputType | null
    _min: CoachMinAggregateOutputType | null
    _max: CoachMaxAggregateOutputType | null
  }

  export type CoachMinAggregateOutputType = {
    coach_id: string | null
    club_id: string | null
    coach_name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    coach_image: string | null
    location: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type CoachMaxAggregateOutputType = {
    coach_id: string | null
    club_id: string | null
    coach_name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    coach_image: string | null
    location: string | null
    created_at: Date | null
    updated_at: Date | null
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
  }

  export type CoachCountAggregateOutputType = {
    coach_id: number
    club_id: number
    coach_name: number
    phone: number
    email: number
    password_hash: number
    role: number
    coach_image: number
    location: number
    created_at: number
    updated_at: number
    reset_token: number
    reset_token_expires: number
    login_otp: number
    login_otp_expires: number
    _all: number
  }


  export type CoachMinAggregateInputType = {
    coach_id?: true
    club_id?: true
    coach_name?: true
    phone?: true
    email?: true
    password_hash?: true
    role?: true
    coach_image?: true
    location?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type CoachMaxAggregateInputType = {
    coach_id?: true
    club_id?: true
    coach_name?: true
    phone?: true
    email?: true
    password_hash?: true
    role?: true
    coach_image?: true
    location?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
  }

  export type CoachCountAggregateInputType = {
    coach_id?: true
    club_id?: true
    coach_name?: true
    phone?: true
    email?: true
    password_hash?: true
    role?: true
    coach_image?: true
    location?: true
    created_at?: true
    updated_at?: true
    reset_token?: true
    reset_token_expires?: true
    login_otp?: true
    login_otp_expires?: true
    _all?: true
  }

  export type CoachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coach to aggregate.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coaches
    **/
    _count?: true | CoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachMaxAggregateInputType
  }

  export type GetCoachAggregateType<T extends CoachAggregateArgs> = {
        [P in keyof T & keyof AggregateCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoach[P]>
      : GetScalarType<T[P], AggregateCoach[P]>
  }




  export type CoachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachWhereInput
    orderBy?: CoachOrderByWithAggregationInput | CoachOrderByWithAggregationInput[]
    by: CoachScalarFieldEnum[] | CoachScalarFieldEnum
    having?: CoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachCountAggregateInputType | true
    _min?: CoachMinAggregateInputType
    _max?: CoachMaxAggregateInputType
  }

  export type CoachGroupByOutputType = {
    coach_id: string
    club_id: string
    coach_name: string | null
    phone: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    coach_image: string | null
    location: string | null
    created_at: Date
    updated_at: Date
    reset_token: string | null
    reset_token_expires: Date | null
    login_otp: string | null
    login_otp_expires: Date | null
    _count: CoachCountAggregateOutputType | null
    _min: CoachMinAggregateOutputType | null
    _max: CoachMaxAggregateOutputType | null
  }

  type GetCoachGroupByPayload<T extends CoachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachGroupByOutputType[P]>
            : GetScalarType<T[P], CoachGroupByOutputType[P]>
        }
      >
    >


  export type CoachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    coach_id?: boolean
    club_id?: boolean
    coach_name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    coach_image?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    coach_assignments?: boolean | Coach$coach_assignmentsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    event_participants?: boolean | Coach$event_participantsArgs<ExtArgs>
    pod_allocations?: boolean | Coach$pod_allocationsArgs<ExtArgs>
    _count?: boolean | CoachCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coach"]>

  export type CoachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    coach_id?: boolean
    club_id?: boolean
    coach_name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    coach_image?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coach"]>

  export type CoachSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    coach_id?: boolean
    club_id?: boolean
    coach_name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    coach_image?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coach"]>

  export type CoachSelectScalar = {
    coach_id?: boolean
    club_id?: boolean
    coach_name?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    coach_image?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    login_otp?: boolean
    login_otp_expires?: boolean
  }

  export type CoachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"coach_id" | "club_id" | "coach_name" | "phone" | "email" | "password_hash" | "role" | "coach_image" | "location" | "created_at" | "updated_at" | "reset_token" | "reset_token_expires" | "login_otp" | "login_otp_expires", ExtArgs["result"]["coach"]>
  export type CoachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach_assignments?: boolean | Coach$coach_assignmentsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    event_participants?: boolean | Coach$event_participantsArgs<ExtArgs>
    pod_allocations?: boolean | Coach$pod_allocationsArgs<ExtArgs>
    _count?: boolean | CoachCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type CoachIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }

  export type $CoachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coach"
    objects: {
      coach_assignments: Prisma.$CoachAssignmentPayload<ExtArgs>[]
      club: Prisma.$ClubPayload<ExtArgs>
      event_participants: Prisma.$EventParticipantPayload<ExtArgs>[]
      pod_allocations: Prisma.$PodAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      coach_id: string
      club_id: string
      coach_name: string | null
      phone: string | null
      email: string | null
      password_hash: string | null
      role: string | null
      coach_image: string | null
      location: string | null
      created_at: Date
      updated_at: Date
      reset_token: string | null
      reset_token_expires: Date | null
      login_otp: string | null
      login_otp_expires: Date | null
    }, ExtArgs["result"]["coach"]>
    composites: {}
  }

  type CoachGetPayload<S extends boolean | null | undefined | CoachDefaultArgs> = $Result.GetResult<Prisma.$CoachPayload, S>

  type CoachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoachCountAggregateInputType | true
    }

  export interface CoachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coach'], meta: { name: 'Coach' } }
    /**
     * Find zero or one Coach that matches the filter.
     * @param {CoachFindUniqueArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachFindUniqueArgs>(args: SelectSubset<T, CoachFindUniqueArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoachFindUniqueOrThrowArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindFirstArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachFindFirstArgs>(args?: SelectSubset<T, CoachFindFirstArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindFirstOrThrowArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coaches
     * const coaches = await prisma.coach.findMany()
     * 
     * // Get first 10 Coaches
     * const coaches = await prisma.coach.findMany({ take: 10 })
     * 
     * // Only select the `coach_id`
     * const coachWithCoach_idOnly = await prisma.coach.findMany({ select: { coach_id: true } })
     * 
     */
    findMany<T extends CoachFindManyArgs>(args?: SelectSubset<T, CoachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coach.
     * @param {CoachCreateArgs} args - Arguments to create a Coach.
     * @example
     * // Create one Coach
     * const Coach = await prisma.coach.create({
     *   data: {
     *     // ... data to create a Coach
     *   }
     * })
     * 
     */
    create<T extends CoachCreateArgs>(args: SelectSubset<T, CoachCreateArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coaches.
     * @param {CoachCreateManyArgs} args - Arguments to create many Coaches.
     * @example
     * // Create many Coaches
     * const coach = await prisma.coach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachCreateManyArgs>(args?: SelectSubset<T, CoachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coaches and returns the data saved in the database.
     * @param {CoachCreateManyAndReturnArgs} args - Arguments to create many Coaches.
     * @example
     * // Create many Coaches
     * const coach = await prisma.coach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coaches and only return the `coach_id`
     * const coachWithCoach_idOnly = await prisma.coach.createManyAndReturn({
     *   select: { coach_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coach.
     * @param {CoachDeleteArgs} args - Arguments to delete one Coach.
     * @example
     * // Delete one Coach
     * const Coach = await prisma.coach.delete({
     *   where: {
     *     // ... filter to delete one Coach
     *   }
     * })
     * 
     */
    delete<T extends CoachDeleteArgs>(args: SelectSubset<T, CoachDeleteArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coach.
     * @param {CoachUpdateArgs} args - Arguments to update one Coach.
     * @example
     * // Update one Coach
     * const coach = await prisma.coach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachUpdateArgs>(args: SelectSubset<T, CoachUpdateArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coaches.
     * @param {CoachDeleteManyArgs} args - Arguments to filter Coaches to delete.
     * @example
     * // Delete a few Coaches
     * const { count } = await prisma.coach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachDeleteManyArgs>(args?: SelectSubset<T, CoachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coaches
     * const coach = await prisma.coach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachUpdateManyArgs>(args: SelectSubset<T, CoachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coaches and returns the data updated in the database.
     * @param {CoachUpdateManyAndReturnArgs} args - Arguments to update many Coaches.
     * @example
     * // Update many Coaches
     * const coach = await prisma.coach.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coaches and only return the `coach_id`
     * const coachWithCoach_idOnly = await prisma.coach.updateManyAndReturn({
     *   select: { coach_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoachUpdateManyAndReturnArgs>(args: SelectSubset<T, CoachUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coach.
     * @param {CoachUpsertArgs} args - Arguments to update or create a Coach.
     * @example
     * // Update or create a Coach
     * const coach = await prisma.coach.upsert({
     *   create: {
     *     // ... data to create a Coach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coach we want to update
     *   }
     * })
     */
    upsert<T extends CoachUpsertArgs>(args: SelectSubset<T, CoachUpsertArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCountArgs} args - Arguments to filter Coaches to count.
     * @example
     * // Count the number of Coaches
     * const count = await prisma.coach.count({
     *   where: {
     *     // ... the filter for the Coaches we want to count
     *   }
     * })
    **/
    count<T extends CoachCountArgs>(
      args?: Subset<T, CoachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachAggregateArgs>(args: Subset<T, CoachAggregateArgs>): Prisma.PrismaPromise<GetCoachAggregateType<T>>

    /**
     * Group by Coach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachGroupByArgs['orderBy'] }
        : { orderBy?: CoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coach model
   */
  readonly fields: CoachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach_assignments<T extends Coach$coach_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$coach_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event_participants<T extends Coach$event_participantsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$event_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pod_allocations<T extends Coach$pod_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$pod_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coach model
   */
  interface CoachFieldRefs {
    readonly coach_id: FieldRef<"Coach", 'String'>
    readonly club_id: FieldRef<"Coach", 'String'>
    readonly coach_name: FieldRef<"Coach", 'String'>
    readonly phone: FieldRef<"Coach", 'String'>
    readonly email: FieldRef<"Coach", 'String'>
    readonly password_hash: FieldRef<"Coach", 'String'>
    readonly role: FieldRef<"Coach", 'String'>
    readonly coach_image: FieldRef<"Coach", 'String'>
    readonly location: FieldRef<"Coach", 'String'>
    readonly created_at: FieldRef<"Coach", 'DateTime'>
    readonly updated_at: FieldRef<"Coach", 'DateTime'>
    readonly reset_token: FieldRef<"Coach", 'String'>
    readonly reset_token_expires: FieldRef<"Coach", 'DateTime'>
    readonly login_otp: FieldRef<"Coach", 'String'>
    readonly login_otp_expires: FieldRef<"Coach", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coach findUnique
   */
  export type CoachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach findUniqueOrThrow
   */
  export type CoachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach findFirst
   */
  export type CoachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coaches.
     */
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach findFirstOrThrow
   */
  export type CoachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coaches.
     */
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach findMany
   */
  export type CoachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coaches to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach create
   */
  export type CoachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The data needed to create a Coach.
     */
    data: XOR<CoachCreateInput, CoachUncheckedCreateInput>
  }

  /**
   * Coach createMany
   */
  export type CoachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coaches.
     */
    data: CoachCreateManyInput | CoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coach createManyAndReturn
   */
  export type CoachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * The data used to create many Coaches.
     */
    data: CoachCreateManyInput | CoachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coach update
   */
  export type CoachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The data needed to update a Coach.
     */
    data: XOR<CoachUpdateInput, CoachUncheckedUpdateInput>
    /**
     * Choose, which Coach to update.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach updateMany
   */
  export type CoachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coaches.
     */
    data: XOR<CoachUpdateManyMutationInput, CoachUncheckedUpdateManyInput>
    /**
     * Filter which Coaches to update
     */
    where?: CoachWhereInput
    /**
     * Limit how many Coaches to update.
     */
    limit?: number
  }

  /**
   * Coach updateManyAndReturn
   */
  export type CoachUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * The data used to update Coaches.
     */
    data: XOR<CoachUpdateManyMutationInput, CoachUncheckedUpdateManyInput>
    /**
     * Filter which Coaches to update
     */
    where?: CoachWhereInput
    /**
     * Limit how many Coaches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coach upsert
   */
  export type CoachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The filter to search for the Coach to update in case it exists.
     */
    where: CoachWhereUniqueInput
    /**
     * In case the Coach found by the `where` argument doesn't exist, create a new Coach with this data.
     */
    create: XOR<CoachCreateInput, CoachUncheckedCreateInput>
    /**
     * In case the Coach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachUpdateInput, CoachUncheckedUpdateInput>
  }

  /**
   * Coach delete
   */
  export type CoachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter which Coach to delete.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach deleteMany
   */
  export type CoachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coaches to delete
     */
    where?: CoachWhereInput
    /**
     * Limit how many Coaches to delete.
     */
    limit?: number
  }

  /**
   * Coach.coach_assignments
   */
  export type Coach$coach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    where?: CoachAssignmentWhereInput
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    cursor?: CoachAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * Coach.event_participants
   */
  export type Coach$event_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    cursor?: EventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * Coach.pod_allocations
   */
  export type Coach$pod_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    where?: PodAllocationWhereInput
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    cursor?: PodAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodAllocationScalarFieldEnum | PodAllocationScalarFieldEnum[]
  }

  /**
   * Coach without action
   */
  export type CoachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    jersey_number: number | null
    age: number | null
  }

  export type PlayerSumAggregateOutputType = {
    jersey_number: number | null
    age: number | null
  }

  export type PlayerMinAggregateOutputType = {
    player_id: string | null
    club_id: string | null
    player_name: string | null
    jersey_number: number | null
    age: number | null
    position: string | null
    phone: string | null
    player_image: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    player_id: string | null
    club_id: string | null
    player_name: string | null
    jersey_number: number | null
    age: number | null
    position: string | null
    phone: string | null
    player_image: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    player_id: number
    club_id: number
    player_name: number
    jersey_number: number
    age: number
    position: number
    phone: number
    player_image: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    jersey_number?: true
    age?: true
  }

  export type PlayerSumAggregateInputType = {
    jersey_number?: true
    age?: true
  }

  export type PlayerMinAggregateInputType = {
    player_id?: true
    club_id?: true
    player_name?: true
    jersey_number?: true
    age?: true
    position?: true
    phone?: true
    player_image?: true
    created_at?: true
    updated_at?: true
  }

  export type PlayerMaxAggregateInputType = {
    player_id?: true
    club_id?: true
    player_name?: true
    jersey_number?: true
    age?: true
    position?: true
    phone?: true
    player_image?: true
    created_at?: true
    updated_at?: true
  }

  export type PlayerCountAggregateInputType = {
    player_id?: true
    club_id?: true
    player_name?: true
    jersey_number?: true
    age?: true
    position?: true
    phone?: true
    player_image?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    player_id: string
    club_id: string
    player_name: string | null
    jersey_number: number | null
    age: number | null
    position: string | null
    phone: string | null
    player_image: string | null
    created_at: Date
    updated_at: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    club_id?: boolean
    player_name?: boolean
    jersey_number?: boolean
    age?: boolean
    position?: boolean
    phone?: boolean
    player_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity_metrics?: boolean | Player$activity_metricsArgs<ExtArgs>
    coach_assignments?: boolean | Player$coach_assignmentsArgs<ExtArgs>
    event_participants?: boolean | Player$event_participantsArgs<ExtArgs>
    player_pod_holders?: boolean | Player$player_pod_holdersArgs<ExtArgs>
    player_pods?: boolean | Player$player_podsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    raw_data?: boolean | Player$raw_dataArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    club_id?: boolean
    player_name?: boolean
    jersey_number?: boolean
    age?: boolean
    position?: boolean
    phone?: boolean
    player_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    club_id?: boolean
    player_name?: boolean
    jersey_number?: boolean
    age?: boolean
    position?: boolean
    phone?: boolean
    player_image?: boolean
    created_at?: boolean
    updated_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    player_id?: boolean
    club_id?: boolean
    player_name?: boolean
    jersey_number?: boolean
    age?: boolean
    position?: boolean
    phone?: boolean
    player_image?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"player_id" | "club_id" | "player_name" | "jersey_number" | "age" | "position" | "phone" | "player_image" | "created_at" | "updated_at", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_metrics?: boolean | Player$activity_metricsArgs<ExtArgs>
    coach_assignments?: boolean | Player$coach_assignmentsArgs<ExtArgs>
    event_participants?: boolean | Player$event_participantsArgs<ExtArgs>
    player_pod_holders?: boolean | Player$player_pod_holdersArgs<ExtArgs>
    player_pods?: boolean | Player$player_podsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    raw_data?: boolean | Player$raw_dataArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      activity_metrics: Prisma.$ActivityMetricPayload<ExtArgs>[]
      coach_assignments: Prisma.$CoachAssignmentPayload<ExtArgs>[]
      event_participants: Prisma.$EventParticipantPayload<ExtArgs>[]
      player_pod_holders: Prisma.$PlayerPodHolderPayload<ExtArgs>[]
      player_pods: Prisma.$PlayerPodPayload<ExtArgs>[]
      club: Prisma.$ClubPayload<ExtArgs>
      raw_data: Prisma.$RawDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      player_id: string
      club_id: string
      player_name: string | null
      jersey_number: number | null
      age: number | null
      position: string | null
      phone: string | null
      player_image: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const playerWithPlayer_idOnly = await prisma.player.findMany({ select: { player_id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `player_id`
     * const playerWithPlayer_idOnly = await prisma.player.createManyAndReturn({
     *   select: { player_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `player_id`
     * const playerWithPlayer_idOnly = await prisma.player.updateManyAndReturn({
     *   select: { player_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity_metrics<T extends Player$activity_metricsArgs<ExtArgs> = {}>(args?: Subset<T, Player$activity_metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coach_assignments<T extends Player$coach_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Player$coach_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event_participants<T extends Player$event_participantsArgs<ExtArgs> = {}>(args?: Subset<T, Player$event_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player_pod_holders<T extends Player$player_pod_holdersArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_pod_holdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player_pods<T extends Player$player_podsArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_podsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raw_data<T extends Player$raw_dataArgs<ExtArgs> = {}>(args?: Subset<T, Player$raw_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly player_id: FieldRef<"Player", 'String'>
    readonly club_id: FieldRef<"Player", 'String'>
    readonly player_name: FieldRef<"Player", 'String'>
    readonly jersey_number: FieldRef<"Player", 'Int'>
    readonly age: FieldRef<"Player", 'Int'>
    readonly position: FieldRef<"Player", 'String'>
    readonly phone: FieldRef<"Player", 'String'>
    readonly player_image: FieldRef<"Player", 'String'>
    readonly created_at: FieldRef<"Player", 'DateTime'>
    readonly updated_at: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.activity_metrics
   */
  export type Player$activity_metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    where?: ActivityMetricWhereInput
    orderBy?: ActivityMetricOrderByWithRelationInput | ActivityMetricOrderByWithRelationInput[]
    cursor?: ActivityMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityMetricScalarFieldEnum | ActivityMetricScalarFieldEnum[]
  }

  /**
   * Player.coach_assignments
   */
  export type Player$coach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    where?: CoachAssignmentWhereInput
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    cursor?: CoachAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * Player.event_participants
   */
  export type Player$event_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    cursor?: EventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * Player.player_pod_holders
   */
  export type Player$player_pod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    where?: PlayerPodHolderWhereInput
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    cursor?: PlayerPodHolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPodHolderScalarFieldEnum | PlayerPodHolderScalarFieldEnum[]
  }

  /**
   * Player.player_pods
   */
  export type Player$player_podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    where?: PlayerPodWhereInput
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    cursor?: PlayerPodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPodScalarFieldEnum | PlayerPodScalarFieldEnum[]
  }

  /**
   * Player.raw_data
   */
  export type Player$raw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    where?: RawDataWhereInput
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    cursor?: RawDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawDataScalarFieldEnum | RawDataScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Pod
   */

  export type AggregatePod = {
    _count: PodCountAggregateOutputType | null
    _min: PodMinAggregateOutputType | null
    _max: PodMaxAggregateOutputType | null
  }

  export type PodMinAggregateOutputType = {
    pod_id: string | null
    serial_number: string | null
    model: string | null
    firmware: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PodMaxAggregateOutputType = {
    pod_id: string | null
    serial_number: string | null
    model: string | null
    firmware: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PodCountAggregateOutputType = {
    pod_id: number
    serial_number: number
    model: number
    firmware: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PodMinAggregateInputType = {
    pod_id?: true
    serial_number?: true
    model?: true
    firmware?: true
    created_at?: true
    updated_at?: true
  }

  export type PodMaxAggregateInputType = {
    pod_id?: true
    serial_number?: true
    model?: true
    firmware?: true
    created_at?: true
    updated_at?: true
  }

  export type PodCountAggregateInputType = {
    pod_id?: true
    serial_number?: true
    model?: true
    firmware?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pod to aggregate.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pods
    **/
    _count?: true | PodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodMaxAggregateInputType
  }

  export type GetPodAggregateType<T extends PodAggregateArgs> = {
        [P in keyof T & keyof AggregatePod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePod[P]>
      : GetScalarType<T[P], AggregatePod[P]>
  }




  export type PodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodWhereInput
    orderBy?: PodOrderByWithAggregationInput | PodOrderByWithAggregationInput[]
    by: PodScalarFieldEnum[] | PodScalarFieldEnum
    having?: PodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodCountAggregateInputType | true
    _min?: PodMinAggregateInputType
    _max?: PodMaxAggregateInputType
  }

  export type PodGroupByOutputType = {
    pod_id: string
    serial_number: string | null
    model: string | null
    firmware: string | null
    created_at: Date
    updated_at: Date
    _count: PodCountAggregateOutputType | null
    _min: PodMinAggregateOutputType | null
    _max: PodMaxAggregateOutputType | null
  }

  type GetPodGroupByPayload<T extends PodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodGroupByOutputType[P]>
            : GetScalarType<T[P], PodGroupByOutputType[P]>
        }
      >
    >


  export type PodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_id?: boolean
    serial_number?: boolean
    model?: boolean
    firmware?: boolean
    created_at?: boolean
    updated_at?: boolean
    coach_assignments?: boolean | Pod$coach_assignmentsArgs<ExtArgs>
    player_pods?: boolean | Pod$player_podsArgs<ExtArgs>
    pod_allocations?: boolean | Pod$pod_allocationsArgs<ExtArgs>
    pod_statuses?: boolean | Pod$pod_statusesArgs<ExtArgs>
    raw_data?: boolean | Pod$raw_dataArgs<ExtArgs>
    _count?: boolean | PodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pod"]>

  export type PodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_id?: boolean
    serial_number?: boolean
    model?: boolean
    firmware?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["pod"]>

  export type PodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_id?: boolean
    serial_number?: boolean
    model?: boolean
    firmware?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["pod"]>

  export type PodSelectScalar = {
    pod_id?: boolean
    serial_number?: boolean
    model?: boolean
    firmware?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pod_id" | "serial_number" | "model" | "firmware" | "created_at" | "updated_at", ExtArgs["result"]["pod"]>
  export type PodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach_assignments?: boolean | Pod$coach_assignmentsArgs<ExtArgs>
    player_pods?: boolean | Pod$player_podsArgs<ExtArgs>
    pod_allocations?: boolean | Pod$pod_allocationsArgs<ExtArgs>
    pod_statuses?: boolean | Pod$pod_statusesArgs<ExtArgs>
    raw_data?: boolean | Pod$raw_dataArgs<ExtArgs>
    _count?: boolean | PodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pod"
    objects: {
      coach_assignments: Prisma.$CoachAssignmentPayload<ExtArgs>[]
      player_pods: Prisma.$PlayerPodPayload<ExtArgs>[]
      pod_allocations: Prisma.$PodAllocationPayload<ExtArgs>[]
      pod_statuses: Prisma.$PodStatusPayload<ExtArgs>[]
      raw_data: Prisma.$RawDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      pod_id: string
      serial_number: string | null
      model: string | null
      firmware: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["pod"]>
    composites: {}
  }

  type PodGetPayload<S extends boolean | null | undefined | PodDefaultArgs> = $Result.GetResult<Prisma.$PodPayload, S>

  type PodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodCountAggregateInputType | true
    }

  export interface PodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pod'], meta: { name: 'Pod' } }
    /**
     * Find zero or one Pod that matches the filter.
     * @param {PodFindUniqueArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodFindUniqueArgs>(args: SelectSubset<T, PodFindUniqueArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodFindUniqueOrThrowArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodFindUniqueOrThrowArgs>(args: SelectSubset<T, PodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindFirstArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodFindFirstArgs>(args?: SelectSubset<T, PodFindFirstArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindFirstOrThrowArgs} args - Arguments to find a Pod
     * @example
     * // Get one Pod
     * const pod = await prisma.pod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodFindFirstOrThrowArgs>(args?: SelectSubset<T, PodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pods
     * const pods = await prisma.pod.findMany()
     * 
     * // Get first 10 Pods
     * const pods = await prisma.pod.findMany({ take: 10 })
     * 
     * // Only select the `pod_id`
     * const podWithPod_idOnly = await prisma.pod.findMany({ select: { pod_id: true } })
     * 
     */
    findMany<T extends PodFindManyArgs>(args?: SelectSubset<T, PodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pod.
     * @param {PodCreateArgs} args - Arguments to create a Pod.
     * @example
     * // Create one Pod
     * const Pod = await prisma.pod.create({
     *   data: {
     *     // ... data to create a Pod
     *   }
     * })
     * 
     */
    create<T extends PodCreateArgs>(args: SelectSubset<T, PodCreateArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pods.
     * @param {PodCreateManyArgs} args - Arguments to create many Pods.
     * @example
     * // Create many Pods
     * const pod = await prisma.pod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodCreateManyArgs>(args?: SelectSubset<T, PodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pods and returns the data saved in the database.
     * @param {PodCreateManyAndReturnArgs} args - Arguments to create many Pods.
     * @example
     * // Create many Pods
     * const pod = await prisma.pod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pods and only return the `pod_id`
     * const podWithPod_idOnly = await prisma.pod.createManyAndReturn({
     *   select: { pod_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodCreateManyAndReturnArgs>(args?: SelectSubset<T, PodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pod.
     * @param {PodDeleteArgs} args - Arguments to delete one Pod.
     * @example
     * // Delete one Pod
     * const Pod = await prisma.pod.delete({
     *   where: {
     *     // ... filter to delete one Pod
     *   }
     * })
     * 
     */
    delete<T extends PodDeleteArgs>(args: SelectSubset<T, PodDeleteArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pod.
     * @param {PodUpdateArgs} args - Arguments to update one Pod.
     * @example
     * // Update one Pod
     * const pod = await prisma.pod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodUpdateArgs>(args: SelectSubset<T, PodUpdateArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pods.
     * @param {PodDeleteManyArgs} args - Arguments to filter Pods to delete.
     * @example
     * // Delete a few Pods
     * const { count } = await prisma.pod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodDeleteManyArgs>(args?: SelectSubset<T, PodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pods
     * const pod = await prisma.pod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodUpdateManyArgs>(args: SelectSubset<T, PodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pods and returns the data updated in the database.
     * @param {PodUpdateManyAndReturnArgs} args - Arguments to update many Pods.
     * @example
     * // Update many Pods
     * const pod = await prisma.pod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pods and only return the `pod_id`
     * const podWithPod_idOnly = await prisma.pod.updateManyAndReturn({
     *   select: { pod_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodUpdateManyAndReturnArgs>(args: SelectSubset<T, PodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pod.
     * @param {PodUpsertArgs} args - Arguments to update or create a Pod.
     * @example
     * // Update or create a Pod
     * const pod = await prisma.pod.upsert({
     *   create: {
     *     // ... data to create a Pod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pod we want to update
     *   }
     * })
     */
    upsert<T extends PodUpsertArgs>(args: SelectSubset<T, PodUpsertArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodCountArgs} args - Arguments to filter Pods to count.
     * @example
     * // Count the number of Pods
     * const count = await prisma.pod.count({
     *   where: {
     *     // ... the filter for the Pods we want to count
     *   }
     * })
    **/
    count<T extends PodCountArgs>(
      args?: Subset<T, PodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodAggregateArgs>(args: Subset<T, PodAggregateArgs>): Prisma.PrismaPromise<GetPodAggregateType<T>>

    /**
     * Group by Pod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodGroupByArgs['orderBy'] }
        : { orderBy?: PodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pod model
   */
  readonly fields: PodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach_assignments<T extends Pod$coach_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Pod$coach_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player_pods<T extends Pod$player_podsArgs<ExtArgs> = {}>(args?: Subset<T, Pod$player_podsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pod_allocations<T extends Pod$pod_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Pod$pod_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pod_statuses<T extends Pod$pod_statusesArgs<ExtArgs> = {}>(args?: Subset<T, Pod$pod_statusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raw_data<T extends Pod$raw_dataArgs<ExtArgs> = {}>(args?: Subset<T, Pod$raw_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pod model
   */
  interface PodFieldRefs {
    readonly pod_id: FieldRef<"Pod", 'String'>
    readonly serial_number: FieldRef<"Pod", 'String'>
    readonly model: FieldRef<"Pod", 'String'>
    readonly firmware: FieldRef<"Pod", 'String'>
    readonly created_at: FieldRef<"Pod", 'DateTime'>
    readonly updated_at: FieldRef<"Pod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pod findUnique
   */
  export type PodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod findUniqueOrThrow
   */
  export type PodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod findFirst
   */
  export type PodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pods.
     */
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod findFirstOrThrow
   */
  export type PodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pod to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pods.
     */
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod findMany
   */
  export type PodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter, which Pods to fetch.
     */
    where?: PodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pods to fetch.
     */
    orderBy?: PodOrderByWithRelationInput | PodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pods.
     */
    cursor?: PodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pods.
     */
    skip?: number
    distinct?: PodScalarFieldEnum | PodScalarFieldEnum[]
  }

  /**
   * Pod create
   */
  export type PodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The data needed to create a Pod.
     */
    data?: XOR<PodCreateInput, PodUncheckedCreateInput>
  }

  /**
   * Pod createMany
   */
  export type PodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pods.
     */
    data: PodCreateManyInput | PodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pod createManyAndReturn
   */
  export type PodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * The data used to create many Pods.
     */
    data: PodCreateManyInput | PodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pod update
   */
  export type PodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The data needed to update a Pod.
     */
    data: XOR<PodUpdateInput, PodUncheckedUpdateInput>
    /**
     * Choose, which Pod to update.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod updateMany
   */
  export type PodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pods.
     */
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyInput>
    /**
     * Filter which Pods to update
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to update.
     */
    limit?: number
  }

  /**
   * Pod updateManyAndReturn
   */
  export type PodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * The data used to update Pods.
     */
    data: XOR<PodUpdateManyMutationInput, PodUncheckedUpdateManyInput>
    /**
     * Filter which Pods to update
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to update.
     */
    limit?: number
  }

  /**
   * Pod upsert
   */
  export type PodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * The filter to search for the Pod to update in case it exists.
     */
    where: PodWhereUniqueInput
    /**
     * In case the Pod found by the `where` argument doesn't exist, create a new Pod with this data.
     */
    create: XOR<PodCreateInput, PodUncheckedCreateInput>
    /**
     * In case the Pod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodUpdateInput, PodUncheckedUpdateInput>
  }

  /**
   * Pod delete
   */
  export type PodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    /**
     * Filter which Pod to delete.
     */
    where: PodWhereUniqueInput
  }

  /**
   * Pod deleteMany
   */
  export type PodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pods to delete
     */
    where?: PodWhereInput
    /**
     * Limit how many Pods to delete.
     */
    limit?: number
  }

  /**
   * Pod.coach_assignments
   */
  export type Pod$coach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    where?: CoachAssignmentWhereInput
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    cursor?: CoachAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * Pod.player_pods
   */
  export type Pod$player_podsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    where?: PlayerPodWhereInput
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    cursor?: PlayerPodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPodScalarFieldEnum | PlayerPodScalarFieldEnum[]
  }

  /**
   * Pod.pod_allocations
   */
  export type Pod$pod_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    where?: PodAllocationWhereInput
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    cursor?: PodAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodAllocationScalarFieldEnum | PodAllocationScalarFieldEnum[]
  }

  /**
   * Pod.pod_statuses
   */
  export type Pod$pod_statusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    where?: PodStatusWhereInput
    orderBy?: PodStatusOrderByWithRelationInput | PodStatusOrderByWithRelationInput[]
    cursor?: PodStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodStatusScalarFieldEnum | PodStatusScalarFieldEnum[]
  }

  /**
   * Pod.raw_data
   */
  export type Pod$raw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    where?: RawDataWhereInput
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    cursor?: RawDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawDataScalarFieldEnum | RawDataScalarFieldEnum[]
  }

  /**
   * Pod without action
   */
  export type PodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
  }


  /**
   * Model PodHolder
   */

  export type AggregatePodHolder = {
    _count: PodHolderCountAggregateOutputType | null
    _min: PodHolderMinAggregateOutputType | null
    _max: PodHolderMaxAggregateOutputType | null
  }

  export type PodHolderMinAggregateOutputType = {
    pod_holder_id: string | null
    serial_number: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
    club_id: string | null
  }

  export type PodHolderMaxAggregateOutputType = {
    pod_holder_id: string | null
    serial_number: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
    club_id: string | null
  }

  export type PodHolderCountAggregateOutputType = {
    pod_holder_id: number
    serial_number: number
    model: number
    created_at: number
    updated_at: number
    club_id: number
    _all: number
  }


  export type PodHolderMinAggregateInputType = {
    pod_holder_id?: true
    serial_number?: true
    model?: true
    created_at?: true
    updated_at?: true
    club_id?: true
  }

  export type PodHolderMaxAggregateInputType = {
    pod_holder_id?: true
    serial_number?: true
    model?: true
    created_at?: true
    updated_at?: true
    club_id?: true
  }

  export type PodHolderCountAggregateInputType = {
    pod_holder_id?: true
    serial_number?: true
    model?: true
    created_at?: true
    updated_at?: true
    club_id?: true
    _all?: true
  }

  export type PodHolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolder to aggregate.
     */
    where?: PodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolders to fetch.
     */
    orderBy?: PodHolderOrderByWithRelationInput | PodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodHolders
    **/
    _count?: true | PodHolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodHolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodHolderMaxAggregateInputType
  }

  export type GetPodHolderAggregateType<T extends PodHolderAggregateArgs> = {
        [P in keyof T & keyof AggregatePodHolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodHolder[P]>
      : GetScalarType<T[P], AggregatePodHolder[P]>
  }




  export type PodHolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderWhereInput
    orderBy?: PodHolderOrderByWithAggregationInput | PodHolderOrderByWithAggregationInput[]
    by: PodHolderScalarFieldEnum[] | PodHolderScalarFieldEnum
    having?: PodHolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodHolderCountAggregateInputType | true
    _min?: PodHolderMinAggregateInputType
    _max?: PodHolderMaxAggregateInputType
  }

  export type PodHolderGroupByOutputType = {
    pod_holder_id: string
    serial_number: string | null
    model: string | null
    created_at: Date
    updated_at: Date
    club_id: string | null
    _count: PodHolderCountAggregateOutputType | null
    _min: PodHolderMinAggregateOutputType | null
    _max: PodHolderMaxAggregateOutputType | null
  }

  type GetPodHolderGroupByPayload<T extends PodHolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodHolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodHolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodHolderGroupByOutputType[P]>
            : GetScalarType<T[P], PodHolderGroupByOutputType[P]>
        }
      >
    >


  export type PodHolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_holder_id?: boolean
    serial_number?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    club_id?: boolean
    club?: boolean | PodHolder$clubArgs<ExtArgs>
    audits?: boolean | PodHolder$auditsArgs<ExtArgs>
    coach_assignments?: boolean | PodHolder$coach_assignmentsArgs<ExtArgs>
    player_pod_holders?: boolean | PodHolder$player_pod_holdersArgs<ExtArgs>
    pod_holder_statuses?: boolean | PodHolder$pod_holder_statusesArgs<ExtArgs>
    _count?: boolean | PodHolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolder"]>

  export type PodHolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_holder_id?: boolean
    serial_number?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    club_id?: boolean
    club?: boolean | PodHolder$clubArgs<ExtArgs>
  }, ExtArgs["result"]["podHolder"]>

  export type PodHolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pod_holder_id?: boolean
    serial_number?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    club_id?: boolean
    club?: boolean | PodHolder$clubArgs<ExtArgs>
  }, ExtArgs["result"]["podHolder"]>

  export type PodHolderSelectScalar = {
    pod_holder_id?: boolean
    serial_number?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    club_id?: boolean
  }

  export type PodHolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pod_holder_id" | "serial_number" | "model" | "created_at" | "updated_at" | "club_id", ExtArgs["result"]["podHolder"]>
  export type PodHolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | PodHolder$clubArgs<ExtArgs>
    audits?: boolean | PodHolder$auditsArgs<ExtArgs>
    coach_assignments?: boolean | PodHolder$coach_assignmentsArgs<ExtArgs>
    player_pod_holders?: boolean | PodHolder$player_pod_holdersArgs<ExtArgs>
    pod_holder_statuses?: boolean | PodHolder$pod_holder_statusesArgs<ExtArgs>
    _count?: boolean | PodHolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PodHolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | PodHolder$clubArgs<ExtArgs>
  }
  export type PodHolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | PodHolder$clubArgs<ExtArgs>
  }

  export type $PodHolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodHolder"
    objects: {
      club: Prisma.$ClubPayload<ExtArgs> | null
      audits: Prisma.$PodHolderAuditPayload<ExtArgs>[]
      coach_assignments: Prisma.$CoachAssignmentPayload<ExtArgs>[]
      player_pod_holders: Prisma.$PlayerPodHolderPayload<ExtArgs>[]
      pod_holder_statuses: Prisma.$PodHolderStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      pod_holder_id: string
      serial_number: string | null
      model: string | null
      created_at: Date
      updated_at: Date
      club_id: string | null
    }, ExtArgs["result"]["podHolder"]>
    composites: {}
  }

  type PodHolderGetPayload<S extends boolean | null | undefined | PodHolderDefaultArgs> = $Result.GetResult<Prisma.$PodHolderPayload, S>

  type PodHolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodHolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodHolderCountAggregateInputType | true
    }

  export interface PodHolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodHolder'], meta: { name: 'PodHolder' } }
    /**
     * Find zero or one PodHolder that matches the filter.
     * @param {PodHolderFindUniqueArgs} args - Arguments to find a PodHolder
     * @example
     * // Get one PodHolder
     * const podHolder = await prisma.podHolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodHolderFindUniqueArgs>(args: SelectSubset<T, PodHolderFindUniqueArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodHolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodHolderFindUniqueOrThrowArgs} args - Arguments to find a PodHolder
     * @example
     * // Get one PodHolder
     * const podHolder = await prisma.podHolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodHolderFindUniqueOrThrowArgs>(args: SelectSubset<T, PodHolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderFindFirstArgs} args - Arguments to find a PodHolder
     * @example
     * // Get one PodHolder
     * const podHolder = await prisma.podHolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodHolderFindFirstArgs>(args?: SelectSubset<T, PodHolderFindFirstArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderFindFirstOrThrowArgs} args - Arguments to find a PodHolder
     * @example
     * // Get one PodHolder
     * const podHolder = await prisma.podHolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodHolderFindFirstOrThrowArgs>(args?: SelectSubset<T, PodHolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodHolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodHolders
     * const podHolders = await prisma.podHolder.findMany()
     * 
     * // Get first 10 PodHolders
     * const podHolders = await prisma.podHolder.findMany({ take: 10 })
     * 
     * // Only select the `pod_holder_id`
     * const podHolderWithPod_holder_idOnly = await prisma.podHolder.findMany({ select: { pod_holder_id: true } })
     * 
     */
    findMany<T extends PodHolderFindManyArgs>(args?: SelectSubset<T, PodHolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodHolder.
     * @param {PodHolderCreateArgs} args - Arguments to create a PodHolder.
     * @example
     * // Create one PodHolder
     * const PodHolder = await prisma.podHolder.create({
     *   data: {
     *     // ... data to create a PodHolder
     *   }
     * })
     * 
     */
    create<T extends PodHolderCreateArgs>(args: SelectSubset<T, PodHolderCreateArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodHolders.
     * @param {PodHolderCreateManyArgs} args - Arguments to create many PodHolders.
     * @example
     * // Create many PodHolders
     * const podHolder = await prisma.podHolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodHolderCreateManyArgs>(args?: SelectSubset<T, PodHolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodHolders and returns the data saved in the database.
     * @param {PodHolderCreateManyAndReturnArgs} args - Arguments to create many PodHolders.
     * @example
     * // Create many PodHolders
     * const podHolder = await prisma.podHolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodHolders and only return the `pod_holder_id`
     * const podHolderWithPod_holder_idOnly = await prisma.podHolder.createManyAndReturn({
     *   select: { pod_holder_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodHolderCreateManyAndReturnArgs>(args?: SelectSubset<T, PodHolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodHolder.
     * @param {PodHolderDeleteArgs} args - Arguments to delete one PodHolder.
     * @example
     * // Delete one PodHolder
     * const PodHolder = await prisma.podHolder.delete({
     *   where: {
     *     // ... filter to delete one PodHolder
     *   }
     * })
     * 
     */
    delete<T extends PodHolderDeleteArgs>(args: SelectSubset<T, PodHolderDeleteArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodHolder.
     * @param {PodHolderUpdateArgs} args - Arguments to update one PodHolder.
     * @example
     * // Update one PodHolder
     * const podHolder = await prisma.podHolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodHolderUpdateArgs>(args: SelectSubset<T, PodHolderUpdateArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodHolders.
     * @param {PodHolderDeleteManyArgs} args - Arguments to filter PodHolders to delete.
     * @example
     * // Delete a few PodHolders
     * const { count } = await prisma.podHolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodHolderDeleteManyArgs>(args?: SelectSubset<T, PodHolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodHolders
     * const podHolder = await prisma.podHolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodHolderUpdateManyArgs>(args: SelectSubset<T, PodHolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolders and returns the data updated in the database.
     * @param {PodHolderUpdateManyAndReturnArgs} args - Arguments to update many PodHolders.
     * @example
     * // Update many PodHolders
     * const podHolder = await prisma.podHolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodHolders and only return the `pod_holder_id`
     * const podHolderWithPod_holder_idOnly = await prisma.podHolder.updateManyAndReturn({
     *   select: { pod_holder_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodHolderUpdateManyAndReturnArgs>(args: SelectSubset<T, PodHolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodHolder.
     * @param {PodHolderUpsertArgs} args - Arguments to update or create a PodHolder.
     * @example
     * // Update or create a PodHolder
     * const podHolder = await prisma.podHolder.upsert({
     *   create: {
     *     // ... data to create a PodHolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodHolder we want to update
     *   }
     * })
     */
    upsert<T extends PodHolderUpsertArgs>(args: SelectSubset<T, PodHolderUpsertArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderCountArgs} args - Arguments to filter PodHolders to count.
     * @example
     * // Count the number of PodHolders
     * const count = await prisma.podHolder.count({
     *   where: {
     *     // ... the filter for the PodHolders we want to count
     *   }
     * })
    **/
    count<T extends PodHolderCountArgs>(
      args?: Subset<T, PodHolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodHolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodHolderAggregateArgs>(args: Subset<T, PodHolderAggregateArgs>): Prisma.PrismaPromise<GetPodHolderAggregateType<T>>

    /**
     * Group by PodHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodHolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodHolderGroupByArgs['orderBy'] }
        : { orderBy?: PodHolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodHolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodHolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodHolder model
   */
  readonly fields: PodHolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodHolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodHolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club<T extends PodHolder$clubArgs<ExtArgs> = {}>(args?: Subset<T, PodHolder$clubArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audits<T extends PodHolder$auditsArgs<ExtArgs> = {}>(args?: Subset<T, PodHolder$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coach_assignments<T extends PodHolder$coach_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, PodHolder$coach_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player_pod_holders<T extends PodHolder$player_pod_holdersArgs<ExtArgs> = {}>(args?: Subset<T, PodHolder$player_pod_holdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pod_holder_statuses<T extends PodHolder$pod_holder_statusesArgs<ExtArgs> = {}>(args?: Subset<T, PodHolder$pod_holder_statusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodHolder model
   */
  interface PodHolderFieldRefs {
    readonly pod_holder_id: FieldRef<"PodHolder", 'String'>
    readonly serial_number: FieldRef<"PodHolder", 'String'>
    readonly model: FieldRef<"PodHolder", 'String'>
    readonly created_at: FieldRef<"PodHolder", 'DateTime'>
    readonly updated_at: FieldRef<"PodHolder", 'DateTime'>
    readonly club_id: FieldRef<"PodHolder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PodHolder findUnique
   */
  export type PodHolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PodHolder to fetch.
     */
    where: PodHolderWhereUniqueInput
  }

  /**
   * PodHolder findUniqueOrThrow
   */
  export type PodHolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PodHolder to fetch.
     */
    where: PodHolderWhereUniqueInput
  }

  /**
   * PodHolder findFirst
   */
  export type PodHolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PodHolder to fetch.
     */
    where?: PodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolders to fetch.
     */
    orderBy?: PodHolderOrderByWithRelationInput | PodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolders.
     */
    cursor?: PodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolders.
     */
    distinct?: PodHolderScalarFieldEnum | PodHolderScalarFieldEnum[]
  }

  /**
   * PodHolder findFirstOrThrow
   */
  export type PodHolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PodHolder to fetch.
     */
    where?: PodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolders to fetch.
     */
    orderBy?: PodHolderOrderByWithRelationInput | PodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolders.
     */
    cursor?: PodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolders.
     */
    distinct?: PodHolderScalarFieldEnum | PodHolderScalarFieldEnum[]
  }

  /**
   * PodHolder findMany
   */
  export type PodHolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PodHolders to fetch.
     */
    where?: PodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolders to fetch.
     */
    orderBy?: PodHolderOrderByWithRelationInput | PodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodHolders.
     */
    cursor?: PodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolders.
     */
    skip?: number
    distinct?: PodHolderScalarFieldEnum | PodHolderScalarFieldEnum[]
  }

  /**
   * PodHolder create
   */
  export type PodHolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * The data needed to create a PodHolder.
     */
    data?: XOR<PodHolderCreateInput, PodHolderUncheckedCreateInput>
  }

  /**
   * PodHolder createMany
   */
  export type PodHolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodHolders.
     */
    data: PodHolderCreateManyInput | PodHolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodHolder createManyAndReturn
   */
  export type PodHolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * The data used to create many PodHolders.
     */
    data: PodHolderCreateManyInput | PodHolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolder update
   */
  export type PodHolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * The data needed to update a PodHolder.
     */
    data: XOR<PodHolderUpdateInput, PodHolderUncheckedUpdateInput>
    /**
     * Choose, which PodHolder to update.
     */
    where: PodHolderWhereUniqueInput
  }

  /**
   * PodHolder updateMany
   */
  export type PodHolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodHolders.
     */
    data: XOR<PodHolderUpdateManyMutationInput, PodHolderUncheckedUpdateManyInput>
    /**
     * Filter which PodHolders to update
     */
    where?: PodHolderWhereInput
    /**
     * Limit how many PodHolders to update.
     */
    limit?: number
  }

  /**
   * PodHolder updateManyAndReturn
   */
  export type PodHolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * The data used to update PodHolders.
     */
    data: XOR<PodHolderUpdateManyMutationInput, PodHolderUncheckedUpdateManyInput>
    /**
     * Filter which PodHolders to update
     */
    where?: PodHolderWhereInput
    /**
     * Limit how many PodHolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolder upsert
   */
  export type PodHolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * The filter to search for the PodHolder to update in case it exists.
     */
    where: PodHolderWhereUniqueInput
    /**
     * In case the PodHolder found by the `where` argument doesn't exist, create a new PodHolder with this data.
     */
    create: XOR<PodHolderCreateInput, PodHolderUncheckedCreateInput>
    /**
     * In case the PodHolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodHolderUpdateInput, PodHolderUncheckedUpdateInput>
  }

  /**
   * PodHolder delete
   */
  export type PodHolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    /**
     * Filter which PodHolder to delete.
     */
    where: PodHolderWhereUniqueInput
  }

  /**
   * PodHolder deleteMany
   */
  export type PodHolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolders to delete
     */
    where?: PodHolderWhereInput
    /**
     * Limit how many PodHolders to delete.
     */
    limit?: number
  }

  /**
   * PodHolder.club
   */
  export type PodHolder$clubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
  }

  /**
   * PodHolder.audits
   */
  export type PodHolder$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    where?: PodHolderAuditWhereInput
    orderBy?: PodHolderAuditOrderByWithRelationInput | PodHolderAuditOrderByWithRelationInput[]
    cursor?: PodHolderAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodHolderAuditScalarFieldEnum | PodHolderAuditScalarFieldEnum[]
  }

  /**
   * PodHolder.coach_assignments
   */
  export type PodHolder$coach_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    where?: CoachAssignmentWhereInput
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    cursor?: CoachAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * PodHolder.player_pod_holders
   */
  export type PodHolder$player_pod_holdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    where?: PlayerPodHolderWhereInput
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    cursor?: PlayerPodHolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerPodHolderScalarFieldEnum | PlayerPodHolderScalarFieldEnum[]
  }

  /**
   * PodHolder.pod_holder_statuses
   */
  export type PodHolder$pod_holder_statusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    where?: PodHolderStatusWhereInput
    orderBy?: PodHolderStatusOrderByWithRelationInput | PodHolderStatusOrderByWithRelationInput[]
    cursor?: PodHolderStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PodHolderStatusScalarFieldEnum | PodHolderStatusScalarFieldEnum[]
  }

  /**
   * PodHolder without action
   */
  export type PodHolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
  }


  /**
   * Model PodHolderAudit
   */

  export type AggregatePodHolderAudit = {
    _count: PodHolderAuditCountAggregateOutputType | null
    _min: PodHolderAuditMinAggregateOutputType | null
    _max: PodHolderAuditMaxAggregateOutputType | null
  }

  export type PodHolderAuditMinAggregateOutputType = {
    audit_id: string | null
    pod_holder_id: string | null
    from_club_id: string | null
    to_club_id: string | null
    action: string | null
    performed_by: string | null
    created_at: Date | null
  }

  export type PodHolderAuditMaxAggregateOutputType = {
    audit_id: string | null
    pod_holder_id: string | null
    from_club_id: string | null
    to_club_id: string | null
    action: string | null
    performed_by: string | null
    created_at: Date | null
  }

  export type PodHolderAuditCountAggregateOutputType = {
    audit_id: number
    pod_holder_id: number
    from_club_id: number
    to_club_id: number
    action: number
    performed_by: number
    created_at: number
    _all: number
  }


  export type PodHolderAuditMinAggregateInputType = {
    audit_id?: true
    pod_holder_id?: true
    from_club_id?: true
    to_club_id?: true
    action?: true
    performed_by?: true
    created_at?: true
  }

  export type PodHolderAuditMaxAggregateInputType = {
    audit_id?: true
    pod_holder_id?: true
    from_club_id?: true
    to_club_id?: true
    action?: true
    performed_by?: true
    created_at?: true
  }

  export type PodHolderAuditCountAggregateInputType = {
    audit_id?: true
    pod_holder_id?: true
    from_club_id?: true
    to_club_id?: true
    action?: true
    performed_by?: true
    created_at?: true
    _all?: true
  }

  export type PodHolderAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolderAudit to aggregate.
     */
    where?: PodHolderAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderAudits to fetch.
     */
    orderBy?: PodHolderAuditOrderByWithRelationInput | PodHolderAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodHolderAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodHolderAudits
    **/
    _count?: true | PodHolderAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodHolderAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodHolderAuditMaxAggregateInputType
  }

  export type GetPodHolderAuditAggregateType<T extends PodHolderAuditAggregateArgs> = {
        [P in keyof T & keyof AggregatePodHolderAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodHolderAudit[P]>
      : GetScalarType<T[P], AggregatePodHolderAudit[P]>
  }




  export type PodHolderAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderAuditWhereInput
    orderBy?: PodHolderAuditOrderByWithAggregationInput | PodHolderAuditOrderByWithAggregationInput[]
    by: PodHolderAuditScalarFieldEnum[] | PodHolderAuditScalarFieldEnum
    having?: PodHolderAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodHolderAuditCountAggregateInputType | true
    _min?: PodHolderAuditMinAggregateInputType
    _max?: PodHolderAuditMaxAggregateInputType
  }

  export type PodHolderAuditGroupByOutputType = {
    audit_id: string
    pod_holder_id: string
    from_club_id: string | null
    to_club_id: string | null
    action: string
    performed_by: string
    created_at: Date
    _count: PodHolderAuditCountAggregateOutputType | null
    _min: PodHolderAuditMinAggregateOutputType | null
    _max: PodHolderAuditMaxAggregateOutputType | null
  }

  type GetPodHolderAuditGroupByPayload<T extends PodHolderAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodHolderAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodHolderAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodHolderAuditGroupByOutputType[P]>
            : GetScalarType<T[P], PodHolderAuditGroupByOutputType[P]>
        }
      >
    >


  export type PodHolderAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    audit_id?: boolean
    pod_holder_id?: boolean
    from_club_id?: boolean
    to_club_id?: boolean
    action?: boolean
    performed_by?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderAudit"]>

  export type PodHolderAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    audit_id?: boolean
    pod_holder_id?: boolean
    from_club_id?: boolean
    to_club_id?: boolean
    action?: boolean
    performed_by?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderAudit"]>

  export type PodHolderAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    audit_id?: boolean
    pod_holder_id?: boolean
    from_club_id?: boolean
    to_club_id?: boolean
    action?: boolean
    performed_by?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderAudit"]>

  export type PodHolderAuditSelectScalar = {
    audit_id?: boolean
    pod_holder_id?: boolean
    from_club_id?: boolean
    to_club_id?: boolean
    action?: boolean
    performed_by?: boolean
    created_at?: boolean
  }

  export type PodHolderAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"audit_id" | "pod_holder_id" | "from_club_id" | "to_club_id" | "action" | "performed_by" | "created_at", ExtArgs["result"]["podHolderAudit"]>
  export type PodHolderAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PodHolderAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PodHolderAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }

  export type $PodHolderAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodHolderAudit"
    objects: {
      pod_holder: Prisma.$PodHolderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      audit_id: string
      pod_holder_id: string
      from_club_id: string | null
      to_club_id: string | null
      action: string
      performed_by: string
      created_at: Date
    }, ExtArgs["result"]["podHolderAudit"]>
    composites: {}
  }

  type PodHolderAuditGetPayload<S extends boolean | null | undefined | PodHolderAuditDefaultArgs> = $Result.GetResult<Prisma.$PodHolderAuditPayload, S>

  type PodHolderAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodHolderAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodHolderAuditCountAggregateInputType | true
    }

  export interface PodHolderAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodHolderAudit'], meta: { name: 'PodHolderAudit' } }
    /**
     * Find zero or one PodHolderAudit that matches the filter.
     * @param {PodHolderAuditFindUniqueArgs} args - Arguments to find a PodHolderAudit
     * @example
     * // Get one PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodHolderAuditFindUniqueArgs>(args: SelectSubset<T, PodHolderAuditFindUniqueArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodHolderAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodHolderAuditFindUniqueOrThrowArgs} args - Arguments to find a PodHolderAudit
     * @example
     * // Get one PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodHolderAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, PodHolderAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolderAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditFindFirstArgs} args - Arguments to find a PodHolderAudit
     * @example
     * // Get one PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodHolderAuditFindFirstArgs>(args?: SelectSubset<T, PodHolderAuditFindFirstArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolderAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditFindFirstOrThrowArgs} args - Arguments to find a PodHolderAudit
     * @example
     * // Get one PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodHolderAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, PodHolderAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodHolderAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodHolderAudits
     * const podHolderAudits = await prisma.podHolderAudit.findMany()
     * 
     * // Get first 10 PodHolderAudits
     * const podHolderAudits = await prisma.podHolderAudit.findMany({ take: 10 })
     * 
     * // Only select the `audit_id`
     * const podHolderAuditWithAudit_idOnly = await prisma.podHolderAudit.findMany({ select: { audit_id: true } })
     * 
     */
    findMany<T extends PodHolderAuditFindManyArgs>(args?: SelectSubset<T, PodHolderAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodHolderAudit.
     * @param {PodHolderAuditCreateArgs} args - Arguments to create a PodHolderAudit.
     * @example
     * // Create one PodHolderAudit
     * const PodHolderAudit = await prisma.podHolderAudit.create({
     *   data: {
     *     // ... data to create a PodHolderAudit
     *   }
     * })
     * 
     */
    create<T extends PodHolderAuditCreateArgs>(args: SelectSubset<T, PodHolderAuditCreateArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodHolderAudits.
     * @param {PodHolderAuditCreateManyArgs} args - Arguments to create many PodHolderAudits.
     * @example
     * // Create many PodHolderAudits
     * const podHolderAudit = await prisma.podHolderAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodHolderAuditCreateManyArgs>(args?: SelectSubset<T, PodHolderAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodHolderAudits and returns the data saved in the database.
     * @param {PodHolderAuditCreateManyAndReturnArgs} args - Arguments to create many PodHolderAudits.
     * @example
     * // Create many PodHolderAudits
     * const podHolderAudit = await prisma.podHolderAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodHolderAudits and only return the `audit_id`
     * const podHolderAuditWithAudit_idOnly = await prisma.podHolderAudit.createManyAndReturn({
     *   select: { audit_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodHolderAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, PodHolderAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodHolderAudit.
     * @param {PodHolderAuditDeleteArgs} args - Arguments to delete one PodHolderAudit.
     * @example
     * // Delete one PodHolderAudit
     * const PodHolderAudit = await prisma.podHolderAudit.delete({
     *   where: {
     *     // ... filter to delete one PodHolderAudit
     *   }
     * })
     * 
     */
    delete<T extends PodHolderAuditDeleteArgs>(args: SelectSubset<T, PodHolderAuditDeleteArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodHolderAudit.
     * @param {PodHolderAuditUpdateArgs} args - Arguments to update one PodHolderAudit.
     * @example
     * // Update one PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodHolderAuditUpdateArgs>(args: SelectSubset<T, PodHolderAuditUpdateArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodHolderAudits.
     * @param {PodHolderAuditDeleteManyArgs} args - Arguments to filter PodHolderAudits to delete.
     * @example
     * // Delete a few PodHolderAudits
     * const { count } = await prisma.podHolderAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodHolderAuditDeleteManyArgs>(args?: SelectSubset<T, PodHolderAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolderAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodHolderAudits
     * const podHolderAudit = await prisma.podHolderAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodHolderAuditUpdateManyArgs>(args: SelectSubset<T, PodHolderAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolderAudits and returns the data updated in the database.
     * @param {PodHolderAuditUpdateManyAndReturnArgs} args - Arguments to update many PodHolderAudits.
     * @example
     * // Update many PodHolderAudits
     * const podHolderAudit = await prisma.podHolderAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodHolderAudits and only return the `audit_id`
     * const podHolderAuditWithAudit_idOnly = await prisma.podHolderAudit.updateManyAndReturn({
     *   select: { audit_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodHolderAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, PodHolderAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodHolderAudit.
     * @param {PodHolderAuditUpsertArgs} args - Arguments to update or create a PodHolderAudit.
     * @example
     * // Update or create a PodHolderAudit
     * const podHolderAudit = await prisma.podHolderAudit.upsert({
     *   create: {
     *     // ... data to create a PodHolderAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodHolderAudit we want to update
     *   }
     * })
     */
    upsert<T extends PodHolderAuditUpsertArgs>(args: SelectSubset<T, PodHolderAuditUpsertArgs<ExtArgs>>): Prisma__PodHolderAuditClient<$Result.GetResult<Prisma.$PodHolderAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodHolderAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditCountArgs} args - Arguments to filter PodHolderAudits to count.
     * @example
     * // Count the number of PodHolderAudits
     * const count = await prisma.podHolderAudit.count({
     *   where: {
     *     // ... the filter for the PodHolderAudits we want to count
     *   }
     * })
    **/
    count<T extends PodHolderAuditCountArgs>(
      args?: Subset<T, PodHolderAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodHolderAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodHolderAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodHolderAuditAggregateArgs>(args: Subset<T, PodHolderAuditAggregateArgs>): Prisma.PrismaPromise<GetPodHolderAuditAggregateType<T>>

    /**
     * Group by PodHolderAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodHolderAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodHolderAuditGroupByArgs['orderBy'] }
        : { orderBy?: PodHolderAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodHolderAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodHolderAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodHolderAudit model
   */
  readonly fields: PodHolderAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodHolderAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodHolderAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod_holder<T extends PodHolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodHolderDefaultArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodHolderAudit model
   */
  interface PodHolderAuditFieldRefs {
    readonly audit_id: FieldRef<"PodHolderAudit", 'String'>
    readonly pod_holder_id: FieldRef<"PodHolderAudit", 'String'>
    readonly from_club_id: FieldRef<"PodHolderAudit", 'String'>
    readonly to_club_id: FieldRef<"PodHolderAudit", 'String'>
    readonly action: FieldRef<"PodHolderAudit", 'String'>
    readonly performed_by: FieldRef<"PodHolderAudit", 'String'>
    readonly created_at: FieldRef<"PodHolderAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodHolderAudit findUnique
   */
  export type PodHolderAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderAudit to fetch.
     */
    where: PodHolderAuditWhereUniqueInput
  }

  /**
   * PodHolderAudit findUniqueOrThrow
   */
  export type PodHolderAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderAudit to fetch.
     */
    where: PodHolderAuditWhereUniqueInput
  }

  /**
   * PodHolderAudit findFirst
   */
  export type PodHolderAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderAudit to fetch.
     */
    where?: PodHolderAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderAudits to fetch.
     */
    orderBy?: PodHolderAuditOrderByWithRelationInput | PodHolderAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolderAudits.
     */
    cursor?: PodHolderAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolderAudits.
     */
    distinct?: PodHolderAuditScalarFieldEnum | PodHolderAuditScalarFieldEnum[]
  }

  /**
   * PodHolderAudit findFirstOrThrow
   */
  export type PodHolderAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderAudit to fetch.
     */
    where?: PodHolderAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderAudits to fetch.
     */
    orderBy?: PodHolderAuditOrderByWithRelationInput | PodHolderAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolderAudits.
     */
    cursor?: PodHolderAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolderAudits.
     */
    distinct?: PodHolderAuditScalarFieldEnum | PodHolderAuditScalarFieldEnum[]
  }

  /**
   * PodHolderAudit findMany
   */
  export type PodHolderAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderAudits to fetch.
     */
    where?: PodHolderAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderAudits to fetch.
     */
    orderBy?: PodHolderAuditOrderByWithRelationInput | PodHolderAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodHolderAudits.
     */
    cursor?: PodHolderAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderAudits.
     */
    skip?: number
    distinct?: PodHolderAuditScalarFieldEnum | PodHolderAuditScalarFieldEnum[]
  }

  /**
   * PodHolderAudit create
   */
  export type PodHolderAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a PodHolderAudit.
     */
    data: XOR<PodHolderAuditCreateInput, PodHolderAuditUncheckedCreateInput>
  }

  /**
   * PodHolderAudit createMany
   */
  export type PodHolderAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodHolderAudits.
     */
    data: PodHolderAuditCreateManyInput | PodHolderAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodHolderAudit createManyAndReturn
   */
  export type PodHolderAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * The data used to create many PodHolderAudits.
     */
    data: PodHolderAuditCreateManyInput | PodHolderAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolderAudit update
   */
  export type PodHolderAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a PodHolderAudit.
     */
    data: XOR<PodHolderAuditUpdateInput, PodHolderAuditUncheckedUpdateInput>
    /**
     * Choose, which PodHolderAudit to update.
     */
    where: PodHolderAuditWhereUniqueInput
  }

  /**
   * PodHolderAudit updateMany
   */
  export type PodHolderAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodHolderAudits.
     */
    data: XOR<PodHolderAuditUpdateManyMutationInput, PodHolderAuditUncheckedUpdateManyInput>
    /**
     * Filter which PodHolderAudits to update
     */
    where?: PodHolderAuditWhereInput
    /**
     * Limit how many PodHolderAudits to update.
     */
    limit?: number
  }

  /**
   * PodHolderAudit updateManyAndReturn
   */
  export type PodHolderAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * The data used to update PodHolderAudits.
     */
    data: XOR<PodHolderAuditUpdateManyMutationInput, PodHolderAuditUncheckedUpdateManyInput>
    /**
     * Filter which PodHolderAudits to update
     */
    where?: PodHolderAuditWhereInput
    /**
     * Limit how many PodHolderAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolderAudit upsert
   */
  export type PodHolderAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the PodHolderAudit to update in case it exists.
     */
    where: PodHolderAuditWhereUniqueInput
    /**
     * In case the PodHolderAudit found by the `where` argument doesn't exist, create a new PodHolderAudit with this data.
     */
    create: XOR<PodHolderAuditCreateInput, PodHolderAuditUncheckedCreateInput>
    /**
     * In case the PodHolderAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodHolderAuditUpdateInput, PodHolderAuditUncheckedUpdateInput>
  }

  /**
   * PodHolderAudit delete
   */
  export type PodHolderAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
    /**
     * Filter which PodHolderAudit to delete.
     */
    where: PodHolderAuditWhereUniqueInput
  }

  /**
   * PodHolderAudit deleteMany
   */
  export type PodHolderAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolderAudits to delete
     */
    where?: PodHolderAuditWhereInput
    /**
     * Limit how many PodHolderAudits to delete.
     */
    limit?: number
  }

  /**
   * PodHolderAudit without action
   */
  export type PodHolderAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderAudit
     */
    select?: PodHolderAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderAudit
     */
    omit?: PodHolderAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderAuditInclude<ExtArgs> | null
  }


  /**
   * Model PodAllocation
   */

  export type AggregatePodAllocation = {
    _count: PodAllocationCountAggregateOutputType | null
    _avg: PodAllocationAvgAggregateOutputType | null
    _sum: PodAllocationSumAggregateOutputType | null
    _min: PodAllocationMinAggregateOutputType | null
    _max: PodAllocationMaxAggregateOutputType | null
  }

  export type PodAllocationAvgAggregateOutputType = {
    battery_level: number | null
  }

  export type PodAllocationSumAggregateOutputType = {
    battery_level: number | null
  }

  export type PodAllocationMinAggregateOutputType = {
    allocation_id: string | null
    coach_id: string | null
    pod_id: string | null
    battery_level: number | null
    health_status: string | null
    assigned_at: Date | null
  }

  export type PodAllocationMaxAggregateOutputType = {
    allocation_id: string | null
    coach_id: string | null
    pod_id: string | null
    battery_level: number | null
    health_status: string | null
    assigned_at: Date | null
  }

  export type PodAllocationCountAggregateOutputType = {
    allocation_id: number
    coach_id: number
    pod_id: number
    battery_level: number
    health_status: number
    assigned_at: number
    _all: number
  }


  export type PodAllocationAvgAggregateInputType = {
    battery_level?: true
  }

  export type PodAllocationSumAggregateInputType = {
    battery_level?: true
  }

  export type PodAllocationMinAggregateInputType = {
    allocation_id?: true
    coach_id?: true
    pod_id?: true
    battery_level?: true
    health_status?: true
    assigned_at?: true
  }

  export type PodAllocationMaxAggregateInputType = {
    allocation_id?: true
    coach_id?: true
    pod_id?: true
    battery_level?: true
    health_status?: true
    assigned_at?: true
  }

  export type PodAllocationCountAggregateInputType = {
    allocation_id?: true
    coach_id?: true
    pod_id?: true
    battery_level?: true
    health_status?: true
    assigned_at?: true
    _all?: true
  }

  export type PodAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodAllocation to aggregate.
     */
    where?: PodAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodAllocations to fetch.
     */
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodAllocations
    **/
    _count?: true | PodAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodAllocationMaxAggregateInputType
  }

  export type GetPodAllocationAggregateType<T extends PodAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePodAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodAllocation[P]>
      : GetScalarType<T[P], AggregatePodAllocation[P]>
  }




  export type PodAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodAllocationWhereInput
    orderBy?: PodAllocationOrderByWithAggregationInput | PodAllocationOrderByWithAggregationInput[]
    by: PodAllocationScalarFieldEnum[] | PodAllocationScalarFieldEnum
    having?: PodAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodAllocationCountAggregateInputType | true
    _avg?: PodAllocationAvgAggregateInputType
    _sum?: PodAllocationSumAggregateInputType
    _min?: PodAllocationMinAggregateInputType
    _max?: PodAllocationMaxAggregateInputType
  }

  export type PodAllocationGroupByOutputType = {
    allocation_id: string
    coach_id: string | null
    pod_id: string
    battery_level: number | null
    health_status: string | null
    assigned_at: Date
    _count: PodAllocationCountAggregateOutputType | null
    _avg: PodAllocationAvgAggregateOutputType | null
    _sum: PodAllocationSumAggregateOutputType | null
    _min: PodAllocationMinAggregateOutputType | null
    _max: PodAllocationMaxAggregateOutputType | null
  }

  type GetPodAllocationGroupByPayload<T extends PodAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], PodAllocationGroupByOutputType[P]>
        }
      >
    >


  export type PodAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    allocation_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    battery_level?: boolean
    health_status?: boolean
    assigned_at?: boolean
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podAllocation"]>

  export type PodAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    allocation_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    battery_level?: boolean
    health_status?: boolean
    assigned_at?: boolean
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podAllocation"]>

  export type PodAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    allocation_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    battery_level?: boolean
    health_status?: boolean
    assigned_at?: boolean
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podAllocation"]>

  export type PodAllocationSelectScalar = {
    allocation_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    battery_level?: boolean
    health_status?: boolean
    assigned_at?: boolean
  }

  export type PodAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"allocation_id" | "coach_id" | "pod_id" | "battery_level" | "health_status" | "assigned_at", ExtArgs["result"]["podAllocation"]>
  export type PodAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | PodAllocation$coachArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $PodAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodAllocation"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs> | null
      pod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      allocation_id: string
      coach_id: string | null
      pod_id: string
      battery_level: number | null
      health_status: string | null
      assigned_at: Date
    }, ExtArgs["result"]["podAllocation"]>
    composites: {}
  }

  type PodAllocationGetPayload<S extends boolean | null | undefined | PodAllocationDefaultArgs> = $Result.GetResult<Prisma.$PodAllocationPayload, S>

  type PodAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodAllocationCountAggregateInputType | true
    }

  export interface PodAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodAllocation'], meta: { name: 'PodAllocation' } }
    /**
     * Find zero or one PodAllocation that matches the filter.
     * @param {PodAllocationFindUniqueArgs} args - Arguments to find a PodAllocation
     * @example
     * // Get one PodAllocation
     * const podAllocation = await prisma.podAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodAllocationFindUniqueArgs>(args: SelectSubset<T, PodAllocationFindUniqueArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodAllocationFindUniqueOrThrowArgs} args - Arguments to find a PodAllocation
     * @example
     * // Get one PodAllocation
     * const podAllocation = await prisma.podAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PodAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationFindFirstArgs} args - Arguments to find a PodAllocation
     * @example
     * // Get one PodAllocation
     * const podAllocation = await prisma.podAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodAllocationFindFirstArgs>(args?: SelectSubset<T, PodAllocationFindFirstArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationFindFirstOrThrowArgs} args - Arguments to find a PodAllocation
     * @example
     * // Get one PodAllocation
     * const podAllocation = await prisma.podAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PodAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodAllocations
     * const podAllocations = await prisma.podAllocation.findMany()
     * 
     * // Get first 10 PodAllocations
     * const podAllocations = await prisma.podAllocation.findMany({ take: 10 })
     * 
     * // Only select the `allocation_id`
     * const podAllocationWithAllocation_idOnly = await prisma.podAllocation.findMany({ select: { allocation_id: true } })
     * 
     */
    findMany<T extends PodAllocationFindManyArgs>(args?: SelectSubset<T, PodAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodAllocation.
     * @param {PodAllocationCreateArgs} args - Arguments to create a PodAllocation.
     * @example
     * // Create one PodAllocation
     * const PodAllocation = await prisma.podAllocation.create({
     *   data: {
     *     // ... data to create a PodAllocation
     *   }
     * })
     * 
     */
    create<T extends PodAllocationCreateArgs>(args: SelectSubset<T, PodAllocationCreateArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodAllocations.
     * @param {PodAllocationCreateManyArgs} args - Arguments to create many PodAllocations.
     * @example
     * // Create many PodAllocations
     * const podAllocation = await prisma.podAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodAllocationCreateManyArgs>(args?: SelectSubset<T, PodAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodAllocations and returns the data saved in the database.
     * @param {PodAllocationCreateManyAndReturnArgs} args - Arguments to create many PodAllocations.
     * @example
     * // Create many PodAllocations
     * const podAllocation = await prisma.podAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodAllocations and only return the `allocation_id`
     * const podAllocationWithAllocation_idOnly = await prisma.podAllocation.createManyAndReturn({
     *   select: { allocation_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PodAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodAllocation.
     * @param {PodAllocationDeleteArgs} args - Arguments to delete one PodAllocation.
     * @example
     * // Delete one PodAllocation
     * const PodAllocation = await prisma.podAllocation.delete({
     *   where: {
     *     // ... filter to delete one PodAllocation
     *   }
     * })
     * 
     */
    delete<T extends PodAllocationDeleteArgs>(args: SelectSubset<T, PodAllocationDeleteArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodAllocation.
     * @param {PodAllocationUpdateArgs} args - Arguments to update one PodAllocation.
     * @example
     * // Update one PodAllocation
     * const podAllocation = await prisma.podAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodAllocationUpdateArgs>(args: SelectSubset<T, PodAllocationUpdateArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodAllocations.
     * @param {PodAllocationDeleteManyArgs} args - Arguments to filter PodAllocations to delete.
     * @example
     * // Delete a few PodAllocations
     * const { count } = await prisma.podAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodAllocationDeleteManyArgs>(args?: SelectSubset<T, PodAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodAllocations
     * const podAllocation = await prisma.podAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodAllocationUpdateManyArgs>(args: SelectSubset<T, PodAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodAllocations and returns the data updated in the database.
     * @param {PodAllocationUpdateManyAndReturnArgs} args - Arguments to update many PodAllocations.
     * @example
     * // Update many PodAllocations
     * const podAllocation = await prisma.podAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodAllocations and only return the `allocation_id`
     * const podAllocationWithAllocation_idOnly = await prisma.podAllocation.updateManyAndReturn({
     *   select: { allocation_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, PodAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodAllocation.
     * @param {PodAllocationUpsertArgs} args - Arguments to update or create a PodAllocation.
     * @example
     * // Update or create a PodAllocation
     * const podAllocation = await prisma.podAllocation.upsert({
     *   create: {
     *     // ... data to create a PodAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodAllocation we want to update
     *   }
     * })
     */
    upsert<T extends PodAllocationUpsertArgs>(args: SelectSubset<T, PodAllocationUpsertArgs<ExtArgs>>): Prisma__PodAllocationClient<$Result.GetResult<Prisma.$PodAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationCountArgs} args - Arguments to filter PodAllocations to count.
     * @example
     * // Count the number of PodAllocations
     * const count = await prisma.podAllocation.count({
     *   where: {
     *     // ... the filter for the PodAllocations we want to count
     *   }
     * })
    **/
    count<T extends PodAllocationCountArgs>(
      args?: Subset<T, PodAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodAllocationAggregateArgs>(args: Subset<T, PodAllocationAggregateArgs>): Prisma.PrismaPromise<GetPodAllocationAggregateType<T>>

    /**
     * Group by PodAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodAllocationGroupByArgs['orderBy'] }
        : { orderBy?: PodAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodAllocation model
   */
  readonly fields: PodAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends PodAllocation$coachArgs<ExtArgs> = {}>(args?: Subset<T, PodAllocation$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodAllocation model
   */
  interface PodAllocationFieldRefs {
    readonly allocation_id: FieldRef<"PodAllocation", 'String'>
    readonly coach_id: FieldRef<"PodAllocation", 'String'>
    readonly pod_id: FieldRef<"PodAllocation", 'String'>
    readonly battery_level: FieldRef<"PodAllocation", 'Int'>
    readonly health_status: FieldRef<"PodAllocation", 'String'>
    readonly assigned_at: FieldRef<"PodAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodAllocation findUnique
   */
  export type PodAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PodAllocation to fetch.
     */
    where: PodAllocationWhereUniqueInput
  }

  /**
   * PodAllocation findUniqueOrThrow
   */
  export type PodAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PodAllocation to fetch.
     */
    where: PodAllocationWhereUniqueInput
  }

  /**
   * PodAllocation findFirst
   */
  export type PodAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PodAllocation to fetch.
     */
    where?: PodAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodAllocations to fetch.
     */
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodAllocations.
     */
    cursor?: PodAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodAllocations.
     */
    distinct?: PodAllocationScalarFieldEnum | PodAllocationScalarFieldEnum[]
  }

  /**
   * PodAllocation findFirstOrThrow
   */
  export type PodAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PodAllocation to fetch.
     */
    where?: PodAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodAllocations to fetch.
     */
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodAllocations.
     */
    cursor?: PodAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodAllocations.
     */
    distinct?: PodAllocationScalarFieldEnum | PodAllocationScalarFieldEnum[]
  }

  /**
   * PodAllocation findMany
   */
  export type PodAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PodAllocations to fetch.
     */
    where?: PodAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodAllocations to fetch.
     */
    orderBy?: PodAllocationOrderByWithRelationInput | PodAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodAllocations.
     */
    cursor?: PodAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodAllocations.
     */
    skip?: number
    distinct?: PodAllocationScalarFieldEnum | PodAllocationScalarFieldEnum[]
  }

  /**
   * PodAllocation create
   */
  export type PodAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PodAllocation.
     */
    data: XOR<PodAllocationCreateInput, PodAllocationUncheckedCreateInput>
  }

  /**
   * PodAllocation createMany
   */
  export type PodAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodAllocations.
     */
    data: PodAllocationCreateManyInput | PodAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodAllocation createManyAndReturn
   */
  export type PodAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many PodAllocations.
     */
    data: PodAllocationCreateManyInput | PodAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodAllocation update
   */
  export type PodAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PodAllocation.
     */
    data: XOR<PodAllocationUpdateInput, PodAllocationUncheckedUpdateInput>
    /**
     * Choose, which PodAllocation to update.
     */
    where: PodAllocationWhereUniqueInput
  }

  /**
   * PodAllocation updateMany
   */
  export type PodAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodAllocations.
     */
    data: XOR<PodAllocationUpdateManyMutationInput, PodAllocationUncheckedUpdateManyInput>
    /**
     * Filter which PodAllocations to update
     */
    where?: PodAllocationWhereInput
    /**
     * Limit how many PodAllocations to update.
     */
    limit?: number
  }

  /**
   * PodAllocation updateManyAndReturn
   */
  export type PodAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * The data used to update PodAllocations.
     */
    data: XOR<PodAllocationUpdateManyMutationInput, PodAllocationUncheckedUpdateManyInput>
    /**
     * Filter which PodAllocations to update
     */
    where?: PodAllocationWhereInput
    /**
     * Limit how many PodAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodAllocation upsert
   */
  export type PodAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PodAllocation to update in case it exists.
     */
    where: PodAllocationWhereUniqueInput
    /**
     * In case the PodAllocation found by the `where` argument doesn't exist, create a new PodAllocation with this data.
     */
    create: XOR<PodAllocationCreateInput, PodAllocationUncheckedCreateInput>
    /**
     * In case the PodAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodAllocationUpdateInput, PodAllocationUncheckedUpdateInput>
  }

  /**
   * PodAllocation delete
   */
  export type PodAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
    /**
     * Filter which PodAllocation to delete.
     */
    where: PodAllocationWhereUniqueInput
  }

  /**
   * PodAllocation deleteMany
   */
  export type PodAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodAllocations to delete
     */
    where?: PodAllocationWhereInput
    /**
     * Limit how many PodAllocations to delete.
     */
    limit?: number
  }

  /**
   * PodAllocation.coach
   */
  export type PodAllocation$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * PodAllocation without action
   */
  export type PodAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodAllocation
     */
    select?: PodAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodAllocation
     */
    omit?: PodAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodAllocationInclude<ExtArgs> | null
  }


  /**
   * Model CoachAssignment
   */

  export type AggregateCoachAssignment = {
    _count: CoachAssignmentCountAggregateOutputType | null
    _min: CoachAssignmentMinAggregateOutputType | null
    _max: CoachAssignmentMaxAggregateOutputType | null
  }

  export type CoachAssignmentMinAggregateOutputType = {
    assignment_id: string | null
    coach_id: string | null
    pod_id: string | null
    pod_holder_id: string | null
    player_id: string | null
    assigned_at: Date | null
  }

  export type CoachAssignmentMaxAggregateOutputType = {
    assignment_id: string | null
    coach_id: string | null
    pod_id: string | null
    pod_holder_id: string | null
    player_id: string | null
    assigned_at: Date | null
  }

  export type CoachAssignmentCountAggregateOutputType = {
    assignment_id: number
    coach_id: number
    pod_id: number
    pod_holder_id: number
    player_id: number
    assigned_at: number
    _all: number
  }


  export type CoachAssignmentMinAggregateInputType = {
    assignment_id?: true
    coach_id?: true
    pod_id?: true
    pod_holder_id?: true
    player_id?: true
    assigned_at?: true
  }

  export type CoachAssignmentMaxAggregateInputType = {
    assignment_id?: true
    coach_id?: true
    pod_id?: true
    pod_holder_id?: true
    player_id?: true
    assigned_at?: true
  }

  export type CoachAssignmentCountAggregateInputType = {
    assignment_id?: true
    coach_id?: true
    pod_id?: true
    pod_holder_id?: true
    player_id?: true
    assigned_at?: true
    _all?: true
  }

  export type CoachAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachAssignment to aggregate.
     */
    where?: CoachAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAssignments to fetch.
     */
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachAssignments
    **/
    _count?: true | CoachAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachAssignmentMaxAggregateInputType
  }

  export type GetCoachAssignmentAggregateType<T extends CoachAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachAssignment[P]>
      : GetScalarType<T[P], AggregateCoachAssignment[P]>
  }




  export type CoachAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAssignmentWhereInput
    orderBy?: CoachAssignmentOrderByWithAggregationInput | CoachAssignmentOrderByWithAggregationInput[]
    by: CoachAssignmentScalarFieldEnum[] | CoachAssignmentScalarFieldEnum
    having?: CoachAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachAssignmentCountAggregateInputType | true
    _min?: CoachAssignmentMinAggregateInputType
    _max?: CoachAssignmentMaxAggregateInputType
  }

  export type CoachAssignmentGroupByOutputType = {
    assignment_id: string
    coach_id: string | null
    pod_id: string | null
    pod_holder_id: string | null
    player_id: string | null
    assigned_at: Date
    _count: CoachAssignmentCountAggregateOutputType | null
    _min: CoachAssignmentMinAggregateOutputType | null
    _max: CoachAssignmentMaxAggregateOutputType | null
  }

  type GetCoachAssignmentGroupByPayload<T extends CoachAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], CoachAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type CoachAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    pod_holder_id?: boolean
    player_id?: boolean
    assigned_at?: boolean
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }, ExtArgs["result"]["coachAssignment"]>

  export type CoachAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    pod_holder_id?: boolean
    player_id?: boolean
    assigned_at?: boolean
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }, ExtArgs["result"]["coachAssignment"]>

  export type CoachAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    pod_holder_id?: boolean
    player_id?: boolean
    assigned_at?: boolean
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }, ExtArgs["result"]["coachAssignment"]>

  export type CoachAssignmentSelectScalar = {
    assignment_id?: boolean
    coach_id?: boolean
    pod_id?: boolean
    pod_holder_id?: boolean
    player_id?: boolean
    assigned_at?: boolean
  }

  export type CoachAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"assignment_id" | "coach_id" | "pod_id" | "pod_holder_id" | "player_id" | "assigned_at", ExtArgs["result"]["coachAssignment"]>
  export type CoachAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }
  export type CoachAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }
  export type CoachAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachAssignment$coachArgs<ExtArgs>
    player?: boolean | CoachAssignment$playerArgs<ExtArgs>
    pod_holder?: boolean | CoachAssignment$pod_holderArgs<ExtArgs>
    pod?: boolean | CoachAssignment$podArgs<ExtArgs>
  }

  export type $CoachAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachAssignment"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs> | null
      player: Prisma.$PlayerPayload<ExtArgs> | null
      pod_holder: Prisma.$PodHolderPayload<ExtArgs> | null
      pod: Prisma.$PodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_id: string
      coach_id: string | null
      pod_id: string | null
      pod_holder_id: string | null
      player_id: string | null
      assigned_at: Date
    }, ExtArgs["result"]["coachAssignment"]>
    composites: {}
  }

  type CoachAssignmentGetPayload<S extends boolean | null | undefined | CoachAssignmentDefaultArgs> = $Result.GetResult<Prisma.$CoachAssignmentPayload, S>

  type CoachAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoachAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoachAssignmentCountAggregateInputType | true
    }

  export interface CoachAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachAssignment'], meta: { name: 'CoachAssignment' } }
    /**
     * Find zero or one CoachAssignment that matches the filter.
     * @param {CoachAssignmentFindUniqueArgs} args - Arguments to find a CoachAssignment
     * @example
     * // Get one CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachAssignmentFindUniqueArgs>(args: SelectSubset<T, CoachAssignmentFindUniqueArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoachAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoachAssignmentFindUniqueOrThrowArgs} args - Arguments to find a CoachAssignment
     * @example
     * // Get one CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoachAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentFindFirstArgs} args - Arguments to find a CoachAssignment
     * @example
     * // Get one CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachAssignmentFindFirstArgs>(args?: SelectSubset<T, CoachAssignmentFindFirstArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoachAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentFindFirstOrThrowArgs} args - Arguments to find a CoachAssignment
     * @example
     * // Get one CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoachAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachAssignments
     * const coachAssignments = await prisma.coachAssignment.findMany()
     * 
     * // Get first 10 CoachAssignments
     * const coachAssignments = await prisma.coachAssignment.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const coachAssignmentWithAssignment_idOnly = await prisma.coachAssignment.findMany({ select: { assignment_id: true } })
     * 
     */
    findMany<T extends CoachAssignmentFindManyArgs>(args?: SelectSubset<T, CoachAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoachAssignment.
     * @param {CoachAssignmentCreateArgs} args - Arguments to create a CoachAssignment.
     * @example
     * // Create one CoachAssignment
     * const CoachAssignment = await prisma.coachAssignment.create({
     *   data: {
     *     // ... data to create a CoachAssignment
     *   }
     * })
     * 
     */
    create<T extends CoachAssignmentCreateArgs>(args: SelectSubset<T, CoachAssignmentCreateArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoachAssignments.
     * @param {CoachAssignmentCreateManyArgs} args - Arguments to create many CoachAssignments.
     * @example
     * // Create many CoachAssignments
     * const coachAssignment = await prisma.coachAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachAssignmentCreateManyArgs>(args?: SelectSubset<T, CoachAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachAssignments and returns the data saved in the database.
     * @param {CoachAssignmentCreateManyAndReturnArgs} args - Arguments to create many CoachAssignments.
     * @example
     * // Create many CoachAssignments
     * const coachAssignment = await prisma.coachAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachAssignments and only return the `assignment_id`
     * const coachAssignmentWithAssignment_idOnly = await prisma.coachAssignment.createManyAndReturn({
     *   select: { assignment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoachAssignment.
     * @param {CoachAssignmentDeleteArgs} args - Arguments to delete one CoachAssignment.
     * @example
     * // Delete one CoachAssignment
     * const CoachAssignment = await prisma.coachAssignment.delete({
     *   where: {
     *     // ... filter to delete one CoachAssignment
     *   }
     * })
     * 
     */
    delete<T extends CoachAssignmentDeleteArgs>(args: SelectSubset<T, CoachAssignmentDeleteArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoachAssignment.
     * @param {CoachAssignmentUpdateArgs} args - Arguments to update one CoachAssignment.
     * @example
     * // Update one CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachAssignmentUpdateArgs>(args: SelectSubset<T, CoachAssignmentUpdateArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoachAssignments.
     * @param {CoachAssignmentDeleteManyArgs} args - Arguments to filter CoachAssignments to delete.
     * @example
     * // Delete a few CoachAssignments
     * const { count } = await prisma.coachAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachAssignmentDeleteManyArgs>(args?: SelectSubset<T, CoachAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachAssignments
     * const coachAssignment = await prisma.coachAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachAssignmentUpdateManyArgs>(args: SelectSubset<T, CoachAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachAssignments and returns the data updated in the database.
     * @param {CoachAssignmentUpdateManyAndReturnArgs} args - Arguments to update many CoachAssignments.
     * @example
     * // Update many CoachAssignments
     * const coachAssignment = await prisma.coachAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoachAssignments and only return the `assignment_id`
     * const coachAssignmentWithAssignment_idOnly = await prisma.coachAssignment.updateManyAndReturn({
     *   select: { assignment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoachAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CoachAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoachAssignment.
     * @param {CoachAssignmentUpsertArgs} args - Arguments to update or create a CoachAssignment.
     * @example
     * // Update or create a CoachAssignment
     * const coachAssignment = await prisma.coachAssignment.upsert({
     *   create: {
     *     // ... data to create a CoachAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachAssignment we want to update
     *   }
     * })
     */
    upsert<T extends CoachAssignmentUpsertArgs>(args: SelectSubset<T, CoachAssignmentUpsertArgs<ExtArgs>>): Prisma__CoachAssignmentClient<$Result.GetResult<Prisma.$CoachAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoachAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentCountArgs} args - Arguments to filter CoachAssignments to count.
     * @example
     * // Count the number of CoachAssignments
     * const count = await prisma.coachAssignment.count({
     *   where: {
     *     // ... the filter for the CoachAssignments we want to count
     *   }
     * })
    **/
    count<T extends CoachAssignmentCountArgs>(
      args?: Subset<T, CoachAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachAssignmentAggregateArgs>(args: Subset<T, CoachAssignmentAggregateArgs>): Prisma.PrismaPromise<GetCoachAssignmentAggregateType<T>>

    /**
     * Group by CoachAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: CoachAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachAssignment model
   */
  readonly fields: CoachAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachAssignment$coachArgs<ExtArgs> = {}>(args?: Subset<T, CoachAssignment$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    player<T extends CoachAssignment$playerArgs<ExtArgs> = {}>(args?: Subset<T, CoachAssignment$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pod_holder<T extends CoachAssignment$pod_holderArgs<ExtArgs> = {}>(args?: Subset<T, CoachAssignment$pod_holderArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pod<T extends CoachAssignment$podArgs<ExtArgs> = {}>(args?: Subset<T, CoachAssignment$podArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachAssignment model
   */
  interface CoachAssignmentFieldRefs {
    readonly assignment_id: FieldRef<"CoachAssignment", 'String'>
    readonly coach_id: FieldRef<"CoachAssignment", 'String'>
    readonly pod_id: FieldRef<"CoachAssignment", 'String'>
    readonly pod_holder_id: FieldRef<"CoachAssignment", 'String'>
    readonly player_id: FieldRef<"CoachAssignment", 'String'>
    readonly assigned_at: FieldRef<"CoachAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachAssignment findUnique
   */
  export type CoachAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CoachAssignment to fetch.
     */
    where: CoachAssignmentWhereUniqueInput
  }

  /**
   * CoachAssignment findUniqueOrThrow
   */
  export type CoachAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CoachAssignment to fetch.
     */
    where: CoachAssignmentWhereUniqueInput
  }

  /**
   * CoachAssignment findFirst
   */
  export type CoachAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CoachAssignment to fetch.
     */
    where?: CoachAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAssignments to fetch.
     */
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachAssignments.
     */
    cursor?: CoachAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachAssignments.
     */
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * CoachAssignment findFirstOrThrow
   */
  export type CoachAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CoachAssignment to fetch.
     */
    where?: CoachAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAssignments to fetch.
     */
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachAssignments.
     */
    cursor?: CoachAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachAssignments.
     */
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * CoachAssignment findMany
   */
  export type CoachAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CoachAssignments to fetch.
     */
    where?: CoachAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAssignments to fetch.
     */
    orderBy?: CoachAssignmentOrderByWithRelationInput | CoachAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachAssignments.
     */
    cursor?: CoachAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAssignments.
     */
    skip?: number
    distinct?: CoachAssignmentScalarFieldEnum | CoachAssignmentScalarFieldEnum[]
  }

  /**
   * CoachAssignment create
   */
  export type CoachAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachAssignment.
     */
    data?: XOR<CoachAssignmentCreateInput, CoachAssignmentUncheckedCreateInput>
  }

  /**
   * CoachAssignment createMany
   */
  export type CoachAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachAssignments.
     */
    data: CoachAssignmentCreateManyInput | CoachAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachAssignment createManyAndReturn
   */
  export type CoachAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many CoachAssignments.
     */
    data: CoachAssignmentCreateManyInput | CoachAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachAssignment update
   */
  export type CoachAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachAssignment.
     */
    data: XOR<CoachAssignmentUpdateInput, CoachAssignmentUncheckedUpdateInput>
    /**
     * Choose, which CoachAssignment to update.
     */
    where: CoachAssignmentWhereUniqueInput
  }

  /**
   * CoachAssignment updateMany
   */
  export type CoachAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachAssignments.
     */
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CoachAssignments to update
     */
    where?: CoachAssignmentWhereInput
    /**
     * Limit how many CoachAssignments to update.
     */
    limit?: number
  }

  /**
   * CoachAssignment updateManyAndReturn
   */
  export type CoachAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update CoachAssignments.
     */
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CoachAssignments to update
     */
    where?: CoachAssignmentWhereInput
    /**
     * Limit how many CoachAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachAssignment upsert
   */
  export type CoachAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachAssignment to update in case it exists.
     */
    where: CoachAssignmentWhereUniqueInput
    /**
     * In case the CoachAssignment found by the `where` argument doesn't exist, create a new CoachAssignment with this data.
     */
    create: XOR<CoachAssignmentCreateInput, CoachAssignmentUncheckedCreateInput>
    /**
     * In case the CoachAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachAssignmentUpdateInput, CoachAssignmentUncheckedUpdateInput>
  }

  /**
   * CoachAssignment delete
   */
  export type CoachAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
    /**
     * Filter which CoachAssignment to delete.
     */
    where: CoachAssignmentWhereUniqueInput
  }

  /**
   * CoachAssignment deleteMany
   */
  export type CoachAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachAssignments to delete
     */
    where?: CoachAssignmentWhereInput
    /**
     * Limit how many CoachAssignments to delete.
     */
    limit?: number
  }

  /**
   * CoachAssignment.coach
   */
  export type CoachAssignment$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * CoachAssignment.player
   */
  export type CoachAssignment$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * CoachAssignment.pod_holder
   */
  export type CoachAssignment$pod_holderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolder
     */
    select?: PodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolder
     */
    omit?: PodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderInclude<ExtArgs> | null
    where?: PodHolderWhereInput
  }

  /**
   * CoachAssignment.pod
   */
  export type CoachAssignment$podArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pod
     */
    select?: PodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pod
     */
    omit?: PodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodInclude<ExtArgs> | null
    where?: PodWhereInput
  }

  /**
   * CoachAssignment without action
   */
  export type CoachAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAssignment
     */
    select?: CoachAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachAssignment
     */
    omit?: CoachAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model PlayerPod
   */

  export type AggregatePlayerPod = {
    _count: PlayerPodCountAggregateOutputType | null
    _min: PlayerPodMinAggregateOutputType | null
    _max: PlayerPodMaxAggregateOutputType | null
  }

  export type PlayerPodMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    pod_id: string | null
    assigned_date: Date | null
  }

  export type PlayerPodMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    pod_id: string | null
    assigned_date: Date | null
  }

  export type PlayerPodCountAggregateOutputType = {
    id: number
    player_id: number
    pod_id: number
    assigned_date: number
    _all: number
  }


  export type PlayerPodMinAggregateInputType = {
    id?: true
    player_id?: true
    pod_id?: true
    assigned_date?: true
  }

  export type PlayerPodMaxAggregateInputType = {
    id?: true
    player_id?: true
    pod_id?: true
    assigned_date?: true
  }

  export type PlayerPodCountAggregateInputType = {
    id?: true
    player_id?: true
    pod_id?: true
    assigned_date?: true
    _all?: true
  }

  export type PlayerPodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPod to aggregate.
     */
    where?: PlayerPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPods to fetch.
     */
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerPods
    **/
    _count?: true | PlayerPodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerPodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerPodMaxAggregateInputType
  }

  export type GetPlayerPodAggregateType<T extends PlayerPodAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerPod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerPod[P]>
      : GetScalarType<T[P], AggregatePlayerPod[P]>
  }




  export type PlayerPodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodWhereInput
    orderBy?: PlayerPodOrderByWithAggregationInput | PlayerPodOrderByWithAggregationInput[]
    by: PlayerPodScalarFieldEnum[] | PlayerPodScalarFieldEnum
    having?: PlayerPodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerPodCountAggregateInputType | true
    _min?: PlayerPodMinAggregateInputType
    _max?: PlayerPodMaxAggregateInputType
  }

  export type PlayerPodGroupByOutputType = {
    id: string
    player_id: string
    pod_id: string
    assigned_date: Date
    _count: PlayerPodCountAggregateOutputType | null
    _min: PlayerPodMinAggregateOutputType | null
    _max: PlayerPodMaxAggregateOutputType | null
  }

  type GetPlayerPodGroupByPayload<T extends PlayerPodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerPodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerPodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerPodGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerPodGroupByOutputType[P]>
        }
      >
    >


  export type PlayerPodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPod"]>

  export type PlayerPodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPod"]>

  export type PlayerPodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPod"]>

  export type PlayerPodSelectScalar = {
    id?: boolean
    player_id?: boolean
    pod_id?: boolean
    assigned_date?: boolean
  }

  export type PlayerPodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "pod_id" | "assigned_date", ExtArgs["result"]["playerPod"]>
  export type PlayerPodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PlayerPodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PlayerPodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $PlayerPodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerPod"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      pod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      pod_id: string
      assigned_date: Date
    }, ExtArgs["result"]["playerPod"]>
    composites: {}
  }

  type PlayerPodGetPayload<S extends boolean | null | undefined | PlayerPodDefaultArgs> = $Result.GetResult<Prisma.$PlayerPodPayload, S>

  type PlayerPodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerPodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerPodCountAggregateInputType | true
    }

  export interface PlayerPodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerPod'], meta: { name: 'PlayerPod' } }
    /**
     * Find zero or one PlayerPod that matches the filter.
     * @param {PlayerPodFindUniqueArgs} args - Arguments to find a PlayerPod
     * @example
     * // Get one PlayerPod
     * const playerPod = await prisma.playerPod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerPodFindUniqueArgs>(args: SelectSubset<T, PlayerPodFindUniqueArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerPod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerPodFindUniqueOrThrowArgs} args - Arguments to find a PlayerPod
     * @example
     * // Get one PlayerPod
     * const playerPod = await prisma.playerPod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerPodFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerPodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerPod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodFindFirstArgs} args - Arguments to find a PlayerPod
     * @example
     * // Get one PlayerPod
     * const playerPod = await prisma.playerPod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerPodFindFirstArgs>(args?: SelectSubset<T, PlayerPodFindFirstArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerPod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodFindFirstOrThrowArgs} args - Arguments to find a PlayerPod
     * @example
     * // Get one PlayerPod
     * const playerPod = await prisma.playerPod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerPodFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerPodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerPods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerPods
     * const playerPods = await prisma.playerPod.findMany()
     * 
     * // Get first 10 PlayerPods
     * const playerPods = await prisma.playerPod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerPodWithIdOnly = await prisma.playerPod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerPodFindManyArgs>(args?: SelectSubset<T, PlayerPodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerPod.
     * @param {PlayerPodCreateArgs} args - Arguments to create a PlayerPod.
     * @example
     * // Create one PlayerPod
     * const PlayerPod = await prisma.playerPod.create({
     *   data: {
     *     // ... data to create a PlayerPod
     *   }
     * })
     * 
     */
    create<T extends PlayerPodCreateArgs>(args: SelectSubset<T, PlayerPodCreateArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerPods.
     * @param {PlayerPodCreateManyArgs} args - Arguments to create many PlayerPods.
     * @example
     * // Create many PlayerPods
     * const playerPod = await prisma.playerPod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerPodCreateManyArgs>(args?: SelectSubset<T, PlayerPodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerPods and returns the data saved in the database.
     * @param {PlayerPodCreateManyAndReturnArgs} args - Arguments to create many PlayerPods.
     * @example
     * // Create many PlayerPods
     * const playerPod = await prisma.playerPod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerPods and only return the `id`
     * const playerPodWithIdOnly = await prisma.playerPod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerPodCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerPodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerPod.
     * @param {PlayerPodDeleteArgs} args - Arguments to delete one PlayerPod.
     * @example
     * // Delete one PlayerPod
     * const PlayerPod = await prisma.playerPod.delete({
     *   where: {
     *     // ... filter to delete one PlayerPod
     *   }
     * })
     * 
     */
    delete<T extends PlayerPodDeleteArgs>(args: SelectSubset<T, PlayerPodDeleteArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerPod.
     * @param {PlayerPodUpdateArgs} args - Arguments to update one PlayerPod.
     * @example
     * // Update one PlayerPod
     * const playerPod = await prisma.playerPod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerPodUpdateArgs>(args: SelectSubset<T, PlayerPodUpdateArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerPods.
     * @param {PlayerPodDeleteManyArgs} args - Arguments to filter PlayerPods to delete.
     * @example
     * // Delete a few PlayerPods
     * const { count } = await prisma.playerPod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerPodDeleteManyArgs>(args?: SelectSubset<T, PlayerPodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerPods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerPods
     * const playerPod = await prisma.playerPod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerPodUpdateManyArgs>(args: SelectSubset<T, PlayerPodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerPods and returns the data updated in the database.
     * @param {PlayerPodUpdateManyAndReturnArgs} args - Arguments to update many PlayerPods.
     * @example
     * // Update many PlayerPods
     * const playerPod = await prisma.playerPod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerPods and only return the `id`
     * const playerPodWithIdOnly = await prisma.playerPod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerPodUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerPodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerPod.
     * @param {PlayerPodUpsertArgs} args - Arguments to update or create a PlayerPod.
     * @example
     * // Update or create a PlayerPod
     * const playerPod = await prisma.playerPod.upsert({
     *   create: {
     *     // ... data to create a PlayerPod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerPod we want to update
     *   }
     * })
     */
    upsert<T extends PlayerPodUpsertArgs>(args: SelectSubset<T, PlayerPodUpsertArgs<ExtArgs>>): Prisma__PlayerPodClient<$Result.GetResult<Prisma.$PlayerPodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerPods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodCountArgs} args - Arguments to filter PlayerPods to count.
     * @example
     * // Count the number of PlayerPods
     * const count = await prisma.playerPod.count({
     *   where: {
     *     // ... the filter for the PlayerPods we want to count
     *   }
     * })
    **/
    count<T extends PlayerPodCountArgs>(
      args?: Subset<T, PlayerPodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerPodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerPod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerPodAggregateArgs>(args: Subset<T, PlayerPodAggregateArgs>): Prisma.PrismaPromise<GetPlayerPodAggregateType<T>>

    /**
     * Group by PlayerPod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerPodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerPodGroupByArgs['orderBy'] }
        : { orderBy?: PlayerPodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerPodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerPodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerPod model
   */
  readonly fields: PlayerPodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerPod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerPodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerPod model
   */
  interface PlayerPodFieldRefs {
    readonly id: FieldRef<"PlayerPod", 'String'>
    readonly player_id: FieldRef<"PlayerPod", 'String'>
    readonly pod_id: FieldRef<"PlayerPod", 'String'>
    readonly assigned_date: FieldRef<"PlayerPod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerPod findUnique
   */
  export type PlayerPodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPod to fetch.
     */
    where: PlayerPodWhereUniqueInput
  }

  /**
   * PlayerPod findUniqueOrThrow
   */
  export type PlayerPodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPod to fetch.
     */
    where: PlayerPodWhereUniqueInput
  }

  /**
   * PlayerPod findFirst
   */
  export type PlayerPodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPod to fetch.
     */
    where?: PlayerPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPods to fetch.
     */
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPods.
     */
    cursor?: PlayerPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPods.
     */
    distinct?: PlayerPodScalarFieldEnum | PlayerPodScalarFieldEnum[]
  }

  /**
   * PlayerPod findFirstOrThrow
   */
  export type PlayerPodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPod to fetch.
     */
    where?: PlayerPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPods to fetch.
     */
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPods.
     */
    cursor?: PlayerPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPods.
     */
    distinct?: PlayerPodScalarFieldEnum | PlayerPodScalarFieldEnum[]
  }

  /**
   * PlayerPod findMany
   */
  export type PlayerPodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPods to fetch.
     */
    where?: PlayerPodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPods to fetch.
     */
    orderBy?: PlayerPodOrderByWithRelationInput | PlayerPodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerPods.
     */
    cursor?: PlayerPodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPods.
     */
    skip?: number
    distinct?: PlayerPodScalarFieldEnum | PlayerPodScalarFieldEnum[]
  }

  /**
   * PlayerPod create
   */
  export type PlayerPodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerPod.
     */
    data: XOR<PlayerPodCreateInput, PlayerPodUncheckedCreateInput>
  }

  /**
   * PlayerPod createMany
   */
  export type PlayerPodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerPods.
     */
    data: PlayerPodCreateManyInput | PlayerPodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerPod createManyAndReturn
   */
  export type PlayerPodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerPods.
     */
    data: PlayerPodCreateManyInput | PlayerPodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerPod update
   */
  export type PlayerPodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerPod.
     */
    data: XOR<PlayerPodUpdateInput, PlayerPodUncheckedUpdateInput>
    /**
     * Choose, which PlayerPod to update.
     */
    where: PlayerPodWhereUniqueInput
  }

  /**
   * PlayerPod updateMany
   */
  export type PlayerPodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerPods.
     */
    data: XOR<PlayerPodUpdateManyMutationInput, PlayerPodUncheckedUpdateManyInput>
    /**
     * Filter which PlayerPods to update
     */
    where?: PlayerPodWhereInput
    /**
     * Limit how many PlayerPods to update.
     */
    limit?: number
  }

  /**
   * PlayerPod updateManyAndReturn
   */
  export type PlayerPodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * The data used to update PlayerPods.
     */
    data: XOR<PlayerPodUpdateManyMutationInput, PlayerPodUncheckedUpdateManyInput>
    /**
     * Filter which PlayerPods to update
     */
    where?: PlayerPodWhereInput
    /**
     * Limit how many PlayerPods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerPod upsert
   */
  export type PlayerPodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerPod to update in case it exists.
     */
    where: PlayerPodWhereUniqueInput
    /**
     * In case the PlayerPod found by the `where` argument doesn't exist, create a new PlayerPod with this data.
     */
    create: XOR<PlayerPodCreateInput, PlayerPodUncheckedCreateInput>
    /**
     * In case the PlayerPod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerPodUpdateInput, PlayerPodUncheckedUpdateInput>
  }

  /**
   * PlayerPod delete
   */
  export type PlayerPodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
    /**
     * Filter which PlayerPod to delete.
     */
    where: PlayerPodWhereUniqueInput
  }

  /**
   * PlayerPod deleteMany
   */
  export type PlayerPodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPods to delete
     */
    where?: PlayerPodWhereInput
    /**
     * Limit how many PlayerPods to delete.
     */
    limit?: number
  }

  /**
   * PlayerPod without action
   */
  export type PlayerPodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPod
     */
    select?: PlayerPodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPod
     */
    omit?: PlayerPodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodInclude<ExtArgs> | null
  }


  /**
   * Model PlayerPodHolder
   */

  export type AggregatePlayerPodHolder = {
    _count: PlayerPodHolderCountAggregateOutputType | null
    _min: PlayerPodHolderMinAggregateOutputType | null
    _max: PlayerPodHolderMaxAggregateOutputType | null
  }

  export type PlayerPodHolderMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    pod_holder_id: string | null
    assigned_date: Date | null
  }

  export type PlayerPodHolderMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    pod_holder_id: string | null
    assigned_date: Date | null
  }

  export type PlayerPodHolderCountAggregateOutputType = {
    id: number
    player_id: number
    pod_holder_id: number
    assigned_date: number
    _all: number
  }


  export type PlayerPodHolderMinAggregateInputType = {
    id?: true
    player_id?: true
    pod_holder_id?: true
    assigned_date?: true
  }

  export type PlayerPodHolderMaxAggregateInputType = {
    id?: true
    player_id?: true
    pod_holder_id?: true
    assigned_date?: true
  }

  export type PlayerPodHolderCountAggregateInputType = {
    id?: true
    player_id?: true
    pod_holder_id?: true
    assigned_date?: true
    _all?: true
  }

  export type PlayerPodHolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPodHolder to aggregate.
     */
    where?: PlayerPodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPodHolders to fetch.
     */
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerPodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerPodHolders
    **/
    _count?: true | PlayerPodHolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerPodHolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerPodHolderMaxAggregateInputType
  }

  export type GetPlayerPodHolderAggregateType<T extends PlayerPodHolderAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerPodHolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerPodHolder[P]>
      : GetScalarType<T[P], AggregatePlayerPodHolder[P]>
  }




  export type PlayerPodHolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerPodHolderWhereInput
    orderBy?: PlayerPodHolderOrderByWithAggregationInput | PlayerPodHolderOrderByWithAggregationInput[]
    by: PlayerPodHolderScalarFieldEnum[] | PlayerPodHolderScalarFieldEnum
    having?: PlayerPodHolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerPodHolderCountAggregateInputType | true
    _min?: PlayerPodHolderMinAggregateInputType
    _max?: PlayerPodHolderMaxAggregateInputType
  }

  export type PlayerPodHolderGroupByOutputType = {
    id: string
    player_id: string
    pod_holder_id: string
    assigned_date: Date
    _count: PlayerPodHolderCountAggregateOutputType | null
    _min: PlayerPodHolderMinAggregateOutputType | null
    _max: PlayerPodHolderMaxAggregateOutputType | null
  }

  type GetPlayerPodHolderGroupByPayload<T extends PlayerPodHolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerPodHolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerPodHolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerPodHolderGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerPodHolderGroupByOutputType[P]>
        }
      >
    >


  export type PlayerPodHolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_holder_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPodHolder"]>

  export type PlayerPodHolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_holder_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPodHolder"]>

  export type PlayerPodHolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    pod_holder_id?: boolean
    assigned_date?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerPodHolder"]>

  export type PlayerPodHolderSelectScalar = {
    id?: boolean
    player_id?: boolean
    pod_holder_id?: boolean
    assigned_date?: boolean
  }

  export type PlayerPodHolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "pod_holder_id" | "assigned_date", ExtArgs["result"]["playerPodHolder"]>
  export type PlayerPodHolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PlayerPodHolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PlayerPodHolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }

  export type $PlayerPodHolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerPodHolder"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      pod_holder: Prisma.$PodHolderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      pod_holder_id: string
      assigned_date: Date
    }, ExtArgs["result"]["playerPodHolder"]>
    composites: {}
  }

  type PlayerPodHolderGetPayload<S extends boolean | null | undefined | PlayerPodHolderDefaultArgs> = $Result.GetResult<Prisma.$PlayerPodHolderPayload, S>

  type PlayerPodHolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerPodHolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerPodHolderCountAggregateInputType | true
    }

  export interface PlayerPodHolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerPodHolder'], meta: { name: 'PlayerPodHolder' } }
    /**
     * Find zero or one PlayerPodHolder that matches the filter.
     * @param {PlayerPodHolderFindUniqueArgs} args - Arguments to find a PlayerPodHolder
     * @example
     * // Get one PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerPodHolderFindUniqueArgs>(args: SelectSubset<T, PlayerPodHolderFindUniqueArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerPodHolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerPodHolderFindUniqueOrThrowArgs} args - Arguments to find a PlayerPodHolder
     * @example
     * // Get one PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerPodHolderFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerPodHolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerPodHolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderFindFirstArgs} args - Arguments to find a PlayerPodHolder
     * @example
     * // Get one PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerPodHolderFindFirstArgs>(args?: SelectSubset<T, PlayerPodHolderFindFirstArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerPodHolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderFindFirstOrThrowArgs} args - Arguments to find a PlayerPodHolder
     * @example
     * // Get one PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerPodHolderFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerPodHolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerPodHolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerPodHolders
     * const playerPodHolders = await prisma.playerPodHolder.findMany()
     * 
     * // Get first 10 PlayerPodHolders
     * const playerPodHolders = await prisma.playerPodHolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerPodHolderWithIdOnly = await prisma.playerPodHolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerPodHolderFindManyArgs>(args?: SelectSubset<T, PlayerPodHolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerPodHolder.
     * @param {PlayerPodHolderCreateArgs} args - Arguments to create a PlayerPodHolder.
     * @example
     * // Create one PlayerPodHolder
     * const PlayerPodHolder = await prisma.playerPodHolder.create({
     *   data: {
     *     // ... data to create a PlayerPodHolder
     *   }
     * })
     * 
     */
    create<T extends PlayerPodHolderCreateArgs>(args: SelectSubset<T, PlayerPodHolderCreateArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerPodHolders.
     * @param {PlayerPodHolderCreateManyArgs} args - Arguments to create many PlayerPodHolders.
     * @example
     * // Create many PlayerPodHolders
     * const playerPodHolder = await prisma.playerPodHolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerPodHolderCreateManyArgs>(args?: SelectSubset<T, PlayerPodHolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerPodHolders and returns the data saved in the database.
     * @param {PlayerPodHolderCreateManyAndReturnArgs} args - Arguments to create many PlayerPodHolders.
     * @example
     * // Create many PlayerPodHolders
     * const playerPodHolder = await prisma.playerPodHolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerPodHolders and only return the `id`
     * const playerPodHolderWithIdOnly = await prisma.playerPodHolder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerPodHolderCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerPodHolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerPodHolder.
     * @param {PlayerPodHolderDeleteArgs} args - Arguments to delete one PlayerPodHolder.
     * @example
     * // Delete one PlayerPodHolder
     * const PlayerPodHolder = await prisma.playerPodHolder.delete({
     *   where: {
     *     // ... filter to delete one PlayerPodHolder
     *   }
     * })
     * 
     */
    delete<T extends PlayerPodHolderDeleteArgs>(args: SelectSubset<T, PlayerPodHolderDeleteArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerPodHolder.
     * @param {PlayerPodHolderUpdateArgs} args - Arguments to update one PlayerPodHolder.
     * @example
     * // Update one PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerPodHolderUpdateArgs>(args: SelectSubset<T, PlayerPodHolderUpdateArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerPodHolders.
     * @param {PlayerPodHolderDeleteManyArgs} args - Arguments to filter PlayerPodHolders to delete.
     * @example
     * // Delete a few PlayerPodHolders
     * const { count } = await prisma.playerPodHolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerPodHolderDeleteManyArgs>(args?: SelectSubset<T, PlayerPodHolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerPodHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerPodHolders
     * const playerPodHolder = await prisma.playerPodHolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerPodHolderUpdateManyArgs>(args: SelectSubset<T, PlayerPodHolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerPodHolders and returns the data updated in the database.
     * @param {PlayerPodHolderUpdateManyAndReturnArgs} args - Arguments to update many PlayerPodHolders.
     * @example
     * // Update many PlayerPodHolders
     * const playerPodHolder = await prisma.playerPodHolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerPodHolders and only return the `id`
     * const playerPodHolderWithIdOnly = await prisma.playerPodHolder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerPodHolderUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerPodHolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerPodHolder.
     * @param {PlayerPodHolderUpsertArgs} args - Arguments to update or create a PlayerPodHolder.
     * @example
     * // Update or create a PlayerPodHolder
     * const playerPodHolder = await prisma.playerPodHolder.upsert({
     *   create: {
     *     // ... data to create a PlayerPodHolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerPodHolder we want to update
     *   }
     * })
     */
    upsert<T extends PlayerPodHolderUpsertArgs>(args: SelectSubset<T, PlayerPodHolderUpsertArgs<ExtArgs>>): Prisma__PlayerPodHolderClient<$Result.GetResult<Prisma.$PlayerPodHolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerPodHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderCountArgs} args - Arguments to filter PlayerPodHolders to count.
     * @example
     * // Count the number of PlayerPodHolders
     * const count = await prisma.playerPodHolder.count({
     *   where: {
     *     // ... the filter for the PlayerPodHolders we want to count
     *   }
     * })
    **/
    count<T extends PlayerPodHolderCountArgs>(
      args?: Subset<T, PlayerPodHolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerPodHolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerPodHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerPodHolderAggregateArgs>(args: Subset<T, PlayerPodHolderAggregateArgs>): Prisma.PrismaPromise<GetPlayerPodHolderAggregateType<T>>

    /**
     * Group by PlayerPodHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerPodHolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerPodHolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerPodHolderGroupByArgs['orderBy'] }
        : { orderBy?: PlayerPodHolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerPodHolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerPodHolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerPodHolder model
   */
  readonly fields: PlayerPodHolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerPodHolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerPodHolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pod_holder<T extends PodHolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodHolderDefaultArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerPodHolder model
   */
  interface PlayerPodHolderFieldRefs {
    readonly id: FieldRef<"PlayerPodHolder", 'String'>
    readonly player_id: FieldRef<"PlayerPodHolder", 'String'>
    readonly pod_holder_id: FieldRef<"PlayerPodHolder", 'String'>
    readonly assigned_date: FieldRef<"PlayerPodHolder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerPodHolder findUnique
   */
  export type PlayerPodHolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPodHolder to fetch.
     */
    where: PlayerPodHolderWhereUniqueInput
  }

  /**
   * PlayerPodHolder findUniqueOrThrow
   */
  export type PlayerPodHolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPodHolder to fetch.
     */
    where: PlayerPodHolderWhereUniqueInput
  }

  /**
   * PlayerPodHolder findFirst
   */
  export type PlayerPodHolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPodHolder to fetch.
     */
    where?: PlayerPodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPodHolders to fetch.
     */
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPodHolders.
     */
    cursor?: PlayerPodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPodHolders.
     */
    distinct?: PlayerPodHolderScalarFieldEnum | PlayerPodHolderScalarFieldEnum[]
  }

  /**
   * PlayerPodHolder findFirstOrThrow
   */
  export type PlayerPodHolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPodHolder to fetch.
     */
    where?: PlayerPodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPodHolders to fetch.
     */
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerPodHolders.
     */
    cursor?: PlayerPodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPodHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerPodHolders.
     */
    distinct?: PlayerPodHolderScalarFieldEnum | PlayerPodHolderScalarFieldEnum[]
  }

  /**
   * PlayerPodHolder findMany
   */
  export type PlayerPodHolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter, which PlayerPodHolders to fetch.
     */
    where?: PlayerPodHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerPodHolders to fetch.
     */
    orderBy?: PlayerPodHolderOrderByWithRelationInput | PlayerPodHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerPodHolders.
     */
    cursor?: PlayerPodHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerPodHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerPodHolders.
     */
    skip?: number
    distinct?: PlayerPodHolderScalarFieldEnum | PlayerPodHolderScalarFieldEnum[]
  }

  /**
   * PlayerPodHolder create
   */
  export type PlayerPodHolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerPodHolder.
     */
    data: XOR<PlayerPodHolderCreateInput, PlayerPodHolderUncheckedCreateInput>
  }

  /**
   * PlayerPodHolder createMany
   */
  export type PlayerPodHolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerPodHolders.
     */
    data: PlayerPodHolderCreateManyInput | PlayerPodHolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerPodHolder createManyAndReturn
   */
  export type PlayerPodHolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerPodHolders.
     */
    data: PlayerPodHolderCreateManyInput | PlayerPodHolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerPodHolder update
   */
  export type PlayerPodHolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerPodHolder.
     */
    data: XOR<PlayerPodHolderUpdateInput, PlayerPodHolderUncheckedUpdateInput>
    /**
     * Choose, which PlayerPodHolder to update.
     */
    where: PlayerPodHolderWhereUniqueInput
  }

  /**
   * PlayerPodHolder updateMany
   */
  export type PlayerPodHolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerPodHolders.
     */
    data: XOR<PlayerPodHolderUpdateManyMutationInput, PlayerPodHolderUncheckedUpdateManyInput>
    /**
     * Filter which PlayerPodHolders to update
     */
    where?: PlayerPodHolderWhereInput
    /**
     * Limit how many PlayerPodHolders to update.
     */
    limit?: number
  }

  /**
   * PlayerPodHolder updateManyAndReturn
   */
  export type PlayerPodHolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * The data used to update PlayerPodHolders.
     */
    data: XOR<PlayerPodHolderUpdateManyMutationInput, PlayerPodHolderUncheckedUpdateManyInput>
    /**
     * Filter which PlayerPodHolders to update
     */
    where?: PlayerPodHolderWhereInput
    /**
     * Limit how many PlayerPodHolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerPodHolder upsert
   */
  export type PlayerPodHolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerPodHolder to update in case it exists.
     */
    where: PlayerPodHolderWhereUniqueInput
    /**
     * In case the PlayerPodHolder found by the `where` argument doesn't exist, create a new PlayerPodHolder with this data.
     */
    create: XOR<PlayerPodHolderCreateInput, PlayerPodHolderUncheckedCreateInput>
    /**
     * In case the PlayerPodHolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerPodHolderUpdateInput, PlayerPodHolderUncheckedUpdateInput>
  }

  /**
   * PlayerPodHolder delete
   */
  export type PlayerPodHolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
    /**
     * Filter which PlayerPodHolder to delete.
     */
    where: PlayerPodHolderWhereUniqueInput
  }

  /**
   * PlayerPodHolder deleteMany
   */
  export type PlayerPodHolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerPodHolders to delete
     */
    where?: PlayerPodHolderWhereInput
    /**
     * Limit how many PlayerPodHolders to delete.
     */
    limit?: number
  }

  /**
   * PlayerPodHolder without action
   */
  export type PlayerPodHolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerPodHolder
     */
    select?: PlayerPodHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerPodHolder
     */
    omit?: PlayerPodHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerPodHolderInclude<ExtArgs> | null
  }


  /**
   * Model PodStatus
   */

  export type AggregatePodStatus = {
    _count: PodStatusCountAggregateOutputType | null
    _avg: PodStatusAvgAggregateOutputType | null
    _sum: PodStatusSumAggregateOutputType | null
    _min: PodStatusMinAggregateOutputType | null
    _max: PodStatusMaxAggregateOutputType | null
  }

  export type PodStatusAvgAggregateOutputType = {
    battery_level: number | null
  }

  export type PodStatusSumAggregateOutputType = {
    battery_level: number | null
  }

  export type PodStatusMinAggregateOutputType = {
    status_id: string | null
    pod_id: string | null
    working_status: string | null
    battery_level: number | null
    last_sync: Date | null
    health_status: string | null
    created_at: Date | null
  }

  export type PodStatusMaxAggregateOutputType = {
    status_id: string | null
    pod_id: string | null
    working_status: string | null
    battery_level: number | null
    last_sync: Date | null
    health_status: string | null
    created_at: Date | null
  }

  export type PodStatusCountAggregateOutputType = {
    status_id: number
    pod_id: number
    working_status: number
    battery_level: number
    last_sync: number
    health_status: number
    created_at: number
    _all: number
  }


  export type PodStatusAvgAggregateInputType = {
    battery_level?: true
  }

  export type PodStatusSumAggregateInputType = {
    battery_level?: true
  }

  export type PodStatusMinAggregateInputType = {
    status_id?: true
    pod_id?: true
    working_status?: true
    battery_level?: true
    last_sync?: true
    health_status?: true
    created_at?: true
  }

  export type PodStatusMaxAggregateInputType = {
    status_id?: true
    pod_id?: true
    working_status?: true
    battery_level?: true
    last_sync?: true
    health_status?: true
    created_at?: true
  }

  export type PodStatusCountAggregateInputType = {
    status_id?: true
    pod_id?: true
    working_status?: true
    battery_level?: true
    last_sync?: true
    health_status?: true
    created_at?: true
    _all?: true
  }

  export type PodStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodStatus to aggregate.
     */
    where?: PodStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodStatuses to fetch.
     */
    orderBy?: PodStatusOrderByWithRelationInput | PodStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodStatuses
    **/
    _count?: true | PodStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodStatusMaxAggregateInputType
  }

  export type GetPodStatusAggregateType<T extends PodStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePodStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodStatus[P]>
      : GetScalarType<T[P], AggregatePodStatus[P]>
  }




  export type PodStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodStatusWhereInput
    orderBy?: PodStatusOrderByWithAggregationInput | PodStatusOrderByWithAggregationInput[]
    by: PodStatusScalarFieldEnum[] | PodStatusScalarFieldEnum
    having?: PodStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodStatusCountAggregateInputType | true
    _avg?: PodStatusAvgAggregateInputType
    _sum?: PodStatusSumAggregateInputType
    _min?: PodStatusMinAggregateInputType
    _max?: PodStatusMaxAggregateInputType
  }

  export type PodStatusGroupByOutputType = {
    status_id: string
    pod_id: string
    working_status: string | null
    battery_level: number | null
    last_sync: Date | null
    health_status: string | null
    created_at: Date
    _count: PodStatusCountAggregateOutputType | null
    _avg: PodStatusAvgAggregateOutputType | null
    _sum: PodStatusSumAggregateOutputType | null
    _min: PodStatusMinAggregateOutputType | null
    _max: PodStatusMaxAggregateOutputType | null
  }

  type GetPodStatusGroupByPayload<T extends PodStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PodStatusGroupByOutputType[P]>
        }
      >
    >


  export type PodStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_id?: boolean
    working_status?: boolean
    battery_level?: boolean
    last_sync?: boolean
    health_status?: boolean
    created_at?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podStatus"]>

  export type PodStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_id?: boolean
    working_status?: boolean
    battery_level?: boolean
    last_sync?: boolean
    health_status?: boolean
    created_at?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podStatus"]>

  export type PodStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_id?: boolean
    working_status?: boolean
    battery_level?: boolean
    last_sync?: boolean
    health_status?: boolean
    created_at?: boolean
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podStatus"]>

  export type PodStatusSelectScalar = {
    status_id?: boolean
    pod_id?: boolean
    working_status?: boolean
    battery_level?: boolean
    last_sync?: boolean
    health_status?: boolean
    created_at?: boolean
  }

  export type PodStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"status_id" | "pod_id" | "working_status" | "battery_level" | "last_sync" | "health_status" | "created_at", ExtArgs["result"]["podStatus"]>
  export type PodStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type PodStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $PodStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodStatus"
    objects: {
      pod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      status_id: string
      pod_id: string
      working_status: string | null
      battery_level: number | null
      last_sync: Date | null
      health_status: string | null
      created_at: Date
    }, ExtArgs["result"]["podStatus"]>
    composites: {}
  }

  type PodStatusGetPayload<S extends boolean | null | undefined | PodStatusDefaultArgs> = $Result.GetResult<Prisma.$PodStatusPayload, S>

  type PodStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodStatusCountAggregateInputType | true
    }

  export interface PodStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodStatus'], meta: { name: 'PodStatus' } }
    /**
     * Find zero or one PodStatus that matches the filter.
     * @param {PodStatusFindUniqueArgs} args - Arguments to find a PodStatus
     * @example
     * // Get one PodStatus
     * const podStatus = await prisma.podStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodStatusFindUniqueArgs>(args: SelectSubset<T, PodStatusFindUniqueArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodStatusFindUniqueOrThrowArgs} args - Arguments to find a PodStatus
     * @example
     * // Get one PodStatus
     * const podStatus = await prisma.podStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PodStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusFindFirstArgs} args - Arguments to find a PodStatus
     * @example
     * // Get one PodStatus
     * const podStatus = await prisma.podStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodStatusFindFirstArgs>(args?: SelectSubset<T, PodStatusFindFirstArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusFindFirstOrThrowArgs} args - Arguments to find a PodStatus
     * @example
     * // Get one PodStatus
     * const podStatus = await prisma.podStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PodStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodStatuses
     * const podStatuses = await prisma.podStatus.findMany()
     * 
     * // Get first 10 PodStatuses
     * const podStatuses = await prisma.podStatus.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const podStatusWithStatus_idOnly = await prisma.podStatus.findMany({ select: { status_id: true } })
     * 
     */
    findMany<T extends PodStatusFindManyArgs>(args?: SelectSubset<T, PodStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodStatus.
     * @param {PodStatusCreateArgs} args - Arguments to create a PodStatus.
     * @example
     * // Create one PodStatus
     * const PodStatus = await prisma.podStatus.create({
     *   data: {
     *     // ... data to create a PodStatus
     *   }
     * })
     * 
     */
    create<T extends PodStatusCreateArgs>(args: SelectSubset<T, PodStatusCreateArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodStatuses.
     * @param {PodStatusCreateManyArgs} args - Arguments to create many PodStatuses.
     * @example
     * // Create many PodStatuses
     * const podStatus = await prisma.podStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodStatusCreateManyArgs>(args?: SelectSubset<T, PodStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodStatuses and returns the data saved in the database.
     * @param {PodStatusCreateManyAndReturnArgs} args - Arguments to create many PodStatuses.
     * @example
     * // Create many PodStatuses
     * const podStatus = await prisma.podStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodStatuses and only return the `status_id`
     * const podStatusWithStatus_idOnly = await prisma.podStatus.createManyAndReturn({
     *   select: { status_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PodStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodStatus.
     * @param {PodStatusDeleteArgs} args - Arguments to delete one PodStatus.
     * @example
     * // Delete one PodStatus
     * const PodStatus = await prisma.podStatus.delete({
     *   where: {
     *     // ... filter to delete one PodStatus
     *   }
     * })
     * 
     */
    delete<T extends PodStatusDeleteArgs>(args: SelectSubset<T, PodStatusDeleteArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodStatus.
     * @param {PodStatusUpdateArgs} args - Arguments to update one PodStatus.
     * @example
     * // Update one PodStatus
     * const podStatus = await prisma.podStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodStatusUpdateArgs>(args: SelectSubset<T, PodStatusUpdateArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodStatuses.
     * @param {PodStatusDeleteManyArgs} args - Arguments to filter PodStatuses to delete.
     * @example
     * // Delete a few PodStatuses
     * const { count } = await prisma.podStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodStatusDeleteManyArgs>(args?: SelectSubset<T, PodStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodStatuses
     * const podStatus = await prisma.podStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodStatusUpdateManyArgs>(args: SelectSubset<T, PodStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodStatuses and returns the data updated in the database.
     * @param {PodStatusUpdateManyAndReturnArgs} args - Arguments to update many PodStatuses.
     * @example
     * // Update many PodStatuses
     * const podStatus = await prisma.podStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodStatuses and only return the `status_id`
     * const podStatusWithStatus_idOnly = await prisma.podStatus.updateManyAndReturn({
     *   select: { status_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, PodStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodStatus.
     * @param {PodStatusUpsertArgs} args - Arguments to update or create a PodStatus.
     * @example
     * // Update or create a PodStatus
     * const podStatus = await prisma.podStatus.upsert({
     *   create: {
     *     // ... data to create a PodStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodStatus we want to update
     *   }
     * })
     */
    upsert<T extends PodStatusUpsertArgs>(args: SelectSubset<T, PodStatusUpsertArgs<ExtArgs>>): Prisma__PodStatusClient<$Result.GetResult<Prisma.$PodStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusCountArgs} args - Arguments to filter PodStatuses to count.
     * @example
     * // Count the number of PodStatuses
     * const count = await prisma.podStatus.count({
     *   where: {
     *     // ... the filter for the PodStatuses we want to count
     *   }
     * })
    **/
    count<T extends PodStatusCountArgs>(
      args?: Subset<T, PodStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodStatusAggregateArgs>(args: Subset<T, PodStatusAggregateArgs>): Prisma.PrismaPromise<GetPodStatusAggregateType<T>>

    /**
     * Group by PodStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodStatusGroupByArgs['orderBy'] }
        : { orderBy?: PodStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodStatus model
   */
  readonly fields: PodStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodStatus model
   */
  interface PodStatusFieldRefs {
    readonly status_id: FieldRef<"PodStatus", 'String'>
    readonly pod_id: FieldRef<"PodStatus", 'String'>
    readonly working_status: FieldRef<"PodStatus", 'String'>
    readonly battery_level: FieldRef<"PodStatus", 'Int'>
    readonly last_sync: FieldRef<"PodStatus", 'DateTime'>
    readonly health_status: FieldRef<"PodStatus", 'String'>
    readonly created_at: FieldRef<"PodStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodStatus findUnique
   */
  export type PodStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodStatus to fetch.
     */
    where: PodStatusWhereUniqueInput
  }

  /**
   * PodStatus findUniqueOrThrow
   */
  export type PodStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodStatus to fetch.
     */
    where: PodStatusWhereUniqueInput
  }

  /**
   * PodStatus findFirst
   */
  export type PodStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodStatus to fetch.
     */
    where?: PodStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodStatuses to fetch.
     */
    orderBy?: PodStatusOrderByWithRelationInput | PodStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodStatuses.
     */
    cursor?: PodStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodStatuses.
     */
    distinct?: PodStatusScalarFieldEnum | PodStatusScalarFieldEnum[]
  }

  /**
   * PodStatus findFirstOrThrow
   */
  export type PodStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodStatus to fetch.
     */
    where?: PodStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodStatuses to fetch.
     */
    orderBy?: PodStatusOrderByWithRelationInput | PodStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodStatuses.
     */
    cursor?: PodStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodStatuses.
     */
    distinct?: PodStatusScalarFieldEnum | PodStatusScalarFieldEnum[]
  }

  /**
   * PodStatus findMany
   */
  export type PodStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodStatuses to fetch.
     */
    where?: PodStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodStatuses to fetch.
     */
    orderBy?: PodStatusOrderByWithRelationInput | PodStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodStatuses.
     */
    cursor?: PodStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodStatuses.
     */
    skip?: number
    distinct?: PodStatusScalarFieldEnum | PodStatusScalarFieldEnum[]
  }

  /**
   * PodStatus create
   */
  export type PodStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PodStatus.
     */
    data: XOR<PodStatusCreateInput, PodStatusUncheckedCreateInput>
  }

  /**
   * PodStatus createMany
   */
  export type PodStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodStatuses.
     */
    data: PodStatusCreateManyInput | PodStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodStatus createManyAndReturn
   */
  export type PodStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * The data used to create many PodStatuses.
     */
    data: PodStatusCreateManyInput | PodStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodStatus update
   */
  export type PodStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PodStatus.
     */
    data: XOR<PodStatusUpdateInput, PodStatusUncheckedUpdateInput>
    /**
     * Choose, which PodStatus to update.
     */
    where: PodStatusWhereUniqueInput
  }

  /**
   * PodStatus updateMany
   */
  export type PodStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodStatuses.
     */
    data: XOR<PodStatusUpdateManyMutationInput, PodStatusUncheckedUpdateManyInput>
    /**
     * Filter which PodStatuses to update
     */
    where?: PodStatusWhereInput
    /**
     * Limit how many PodStatuses to update.
     */
    limit?: number
  }

  /**
   * PodStatus updateManyAndReturn
   */
  export type PodStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * The data used to update PodStatuses.
     */
    data: XOR<PodStatusUpdateManyMutationInput, PodStatusUncheckedUpdateManyInput>
    /**
     * Filter which PodStatuses to update
     */
    where?: PodStatusWhereInput
    /**
     * Limit how many PodStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodStatus upsert
   */
  export type PodStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PodStatus to update in case it exists.
     */
    where: PodStatusWhereUniqueInput
    /**
     * In case the PodStatus found by the `where` argument doesn't exist, create a new PodStatus with this data.
     */
    create: XOR<PodStatusCreateInput, PodStatusUncheckedCreateInput>
    /**
     * In case the PodStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodStatusUpdateInput, PodStatusUncheckedUpdateInput>
  }

  /**
   * PodStatus delete
   */
  export type PodStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
    /**
     * Filter which PodStatus to delete.
     */
    where: PodStatusWhereUniqueInput
  }

  /**
   * PodStatus deleteMany
   */
  export type PodStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodStatuses to delete
     */
    where?: PodStatusWhereInput
    /**
     * Limit how many PodStatuses to delete.
     */
    limit?: number
  }

  /**
   * PodStatus without action
   */
  export type PodStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodStatus
     */
    select?: PodStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodStatus
     */
    omit?: PodStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodStatusInclude<ExtArgs> | null
  }


  /**
   * Model PodHolderStatus
   */

  export type AggregatePodHolderStatus = {
    _count: PodHolderStatusCountAggregateOutputType | null
    _avg: PodHolderStatusAvgAggregateOutputType | null
    _sum: PodHolderStatusSumAggregateOutputType | null
    _min: PodHolderStatusMinAggregateOutputType | null
    _max: PodHolderStatusMaxAggregateOutputType | null
  }

  export type PodHolderStatusAvgAggregateOutputType = {
    battery_level: number | null
  }

  export type PodHolderStatusSumAggregateOutputType = {
    battery_level: number | null
  }

  export type PodHolderStatusMinAggregateOutputType = {
    status_id: string | null
    pod_holder_id: string | null
    battery_level: number | null
    working_status: string | null
    last_sync: Date | null
    created_at: Date | null
  }

  export type PodHolderStatusMaxAggregateOutputType = {
    status_id: string | null
    pod_holder_id: string | null
    battery_level: number | null
    working_status: string | null
    last_sync: Date | null
    created_at: Date | null
  }

  export type PodHolderStatusCountAggregateOutputType = {
    status_id: number
    pod_holder_id: number
    battery_level: number
    working_status: number
    last_sync: number
    created_at: number
    _all: number
  }


  export type PodHolderStatusAvgAggregateInputType = {
    battery_level?: true
  }

  export type PodHolderStatusSumAggregateInputType = {
    battery_level?: true
  }

  export type PodHolderStatusMinAggregateInputType = {
    status_id?: true
    pod_holder_id?: true
    battery_level?: true
    working_status?: true
    last_sync?: true
    created_at?: true
  }

  export type PodHolderStatusMaxAggregateInputType = {
    status_id?: true
    pod_holder_id?: true
    battery_level?: true
    working_status?: true
    last_sync?: true
    created_at?: true
  }

  export type PodHolderStatusCountAggregateInputType = {
    status_id?: true
    pod_holder_id?: true
    battery_level?: true
    working_status?: true
    last_sync?: true
    created_at?: true
    _all?: true
  }

  export type PodHolderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolderStatus to aggregate.
     */
    where?: PodHolderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderStatuses to fetch.
     */
    orderBy?: PodHolderStatusOrderByWithRelationInput | PodHolderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PodHolderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PodHolderStatuses
    **/
    _count?: true | PodHolderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodHolderStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodHolderStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodHolderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodHolderStatusMaxAggregateInputType
  }

  export type GetPodHolderStatusAggregateType<T extends PodHolderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePodHolderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodHolderStatus[P]>
      : GetScalarType<T[P], AggregatePodHolderStatus[P]>
  }




  export type PodHolderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PodHolderStatusWhereInput
    orderBy?: PodHolderStatusOrderByWithAggregationInput | PodHolderStatusOrderByWithAggregationInput[]
    by: PodHolderStatusScalarFieldEnum[] | PodHolderStatusScalarFieldEnum
    having?: PodHolderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodHolderStatusCountAggregateInputType | true
    _avg?: PodHolderStatusAvgAggregateInputType
    _sum?: PodHolderStatusSumAggregateInputType
    _min?: PodHolderStatusMinAggregateInputType
    _max?: PodHolderStatusMaxAggregateInputType
  }

  export type PodHolderStatusGroupByOutputType = {
    status_id: string
    pod_holder_id: string
    battery_level: number | null
    working_status: string | null
    last_sync: Date | null
    created_at: Date
    _count: PodHolderStatusCountAggregateOutputType | null
    _avg: PodHolderStatusAvgAggregateOutputType | null
    _sum: PodHolderStatusSumAggregateOutputType | null
    _min: PodHolderStatusMinAggregateOutputType | null
    _max: PodHolderStatusMaxAggregateOutputType | null
  }

  type GetPodHolderStatusGroupByPayload<T extends PodHolderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodHolderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodHolderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodHolderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PodHolderStatusGroupByOutputType[P]>
        }
      >
    >


  export type PodHolderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_holder_id?: boolean
    battery_level?: boolean
    working_status?: boolean
    last_sync?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderStatus"]>

  export type PodHolderStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_holder_id?: boolean
    battery_level?: boolean
    working_status?: boolean
    last_sync?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderStatus"]>

  export type PodHolderStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    pod_holder_id?: boolean
    battery_level?: boolean
    working_status?: boolean
    last_sync?: boolean
    created_at?: boolean
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podHolderStatus"]>

  export type PodHolderStatusSelectScalar = {
    status_id?: boolean
    pod_holder_id?: boolean
    battery_level?: boolean
    working_status?: boolean
    last_sync?: boolean
    created_at?: boolean
  }

  export type PodHolderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"status_id" | "pod_holder_id" | "battery_level" | "working_status" | "last_sync" | "created_at", ExtArgs["result"]["podHolderStatus"]>
  export type PodHolderStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PodHolderStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }
  export type PodHolderStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pod_holder?: boolean | PodHolderDefaultArgs<ExtArgs>
  }

  export type $PodHolderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PodHolderStatus"
    objects: {
      pod_holder: Prisma.$PodHolderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      status_id: string
      pod_holder_id: string
      battery_level: number | null
      working_status: string | null
      last_sync: Date | null
      created_at: Date
    }, ExtArgs["result"]["podHolderStatus"]>
    composites: {}
  }

  type PodHolderStatusGetPayload<S extends boolean | null | undefined | PodHolderStatusDefaultArgs> = $Result.GetResult<Prisma.$PodHolderStatusPayload, S>

  type PodHolderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PodHolderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodHolderStatusCountAggregateInputType | true
    }

  export interface PodHolderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PodHolderStatus'], meta: { name: 'PodHolderStatus' } }
    /**
     * Find zero or one PodHolderStatus that matches the filter.
     * @param {PodHolderStatusFindUniqueArgs} args - Arguments to find a PodHolderStatus
     * @example
     * // Get one PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PodHolderStatusFindUniqueArgs>(args: SelectSubset<T, PodHolderStatusFindUniqueArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PodHolderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PodHolderStatusFindUniqueOrThrowArgs} args - Arguments to find a PodHolderStatus
     * @example
     * // Get one PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PodHolderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PodHolderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusFindFirstArgs} args - Arguments to find a PodHolderStatus
     * @example
     * // Get one PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PodHolderStatusFindFirstArgs>(args?: SelectSubset<T, PodHolderStatusFindFirstArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PodHolderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusFindFirstOrThrowArgs} args - Arguments to find a PodHolderStatus
     * @example
     * // Get one PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PodHolderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PodHolderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PodHolderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PodHolderStatuses
     * const podHolderStatuses = await prisma.podHolderStatus.findMany()
     * 
     * // Get first 10 PodHolderStatuses
     * const podHolderStatuses = await prisma.podHolderStatus.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const podHolderStatusWithStatus_idOnly = await prisma.podHolderStatus.findMany({ select: { status_id: true } })
     * 
     */
    findMany<T extends PodHolderStatusFindManyArgs>(args?: SelectSubset<T, PodHolderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PodHolderStatus.
     * @param {PodHolderStatusCreateArgs} args - Arguments to create a PodHolderStatus.
     * @example
     * // Create one PodHolderStatus
     * const PodHolderStatus = await prisma.podHolderStatus.create({
     *   data: {
     *     // ... data to create a PodHolderStatus
     *   }
     * })
     * 
     */
    create<T extends PodHolderStatusCreateArgs>(args: SelectSubset<T, PodHolderStatusCreateArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PodHolderStatuses.
     * @param {PodHolderStatusCreateManyArgs} args - Arguments to create many PodHolderStatuses.
     * @example
     * // Create many PodHolderStatuses
     * const podHolderStatus = await prisma.podHolderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PodHolderStatusCreateManyArgs>(args?: SelectSubset<T, PodHolderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PodHolderStatuses and returns the data saved in the database.
     * @param {PodHolderStatusCreateManyAndReturnArgs} args - Arguments to create many PodHolderStatuses.
     * @example
     * // Create many PodHolderStatuses
     * const podHolderStatus = await prisma.podHolderStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PodHolderStatuses and only return the `status_id`
     * const podHolderStatusWithStatus_idOnly = await prisma.podHolderStatus.createManyAndReturn({
     *   select: { status_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PodHolderStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PodHolderStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PodHolderStatus.
     * @param {PodHolderStatusDeleteArgs} args - Arguments to delete one PodHolderStatus.
     * @example
     * // Delete one PodHolderStatus
     * const PodHolderStatus = await prisma.podHolderStatus.delete({
     *   where: {
     *     // ... filter to delete one PodHolderStatus
     *   }
     * })
     * 
     */
    delete<T extends PodHolderStatusDeleteArgs>(args: SelectSubset<T, PodHolderStatusDeleteArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PodHolderStatus.
     * @param {PodHolderStatusUpdateArgs} args - Arguments to update one PodHolderStatus.
     * @example
     * // Update one PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PodHolderStatusUpdateArgs>(args: SelectSubset<T, PodHolderStatusUpdateArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PodHolderStatuses.
     * @param {PodHolderStatusDeleteManyArgs} args - Arguments to filter PodHolderStatuses to delete.
     * @example
     * // Delete a few PodHolderStatuses
     * const { count } = await prisma.podHolderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PodHolderStatusDeleteManyArgs>(args?: SelectSubset<T, PodHolderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PodHolderStatuses
     * const podHolderStatus = await prisma.podHolderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PodHolderStatusUpdateManyArgs>(args: SelectSubset<T, PodHolderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PodHolderStatuses and returns the data updated in the database.
     * @param {PodHolderStatusUpdateManyAndReturnArgs} args - Arguments to update many PodHolderStatuses.
     * @example
     * // Update many PodHolderStatuses
     * const podHolderStatus = await prisma.podHolderStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PodHolderStatuses and only return the `status_id`
     * const podHolderStatusWithStatus_idOnly = await prisma.podHolderStatus.updateManyAndReturn({
     *   select: { status_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PodHolderStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, PodHolderStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PodHolderStatus.
     * @param {PodHolderStatusUpsertArgs} args - Arguments to update or create a PodHolderStatus.
     * @example
     * // Update or create a PodHolderStatus
     * const podHolderStatus = await prisma.podHolderStatus.upsert({
     *   create: {
     *     // ... data to create a PodHolderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PodHolderStatus we want to update
     *   }
     * })
     */
    upsert<T extends PodHolderStatusUpsertArgs>(args: SelectSubset<T, PodHolderStatusUpsertArgs<ExtArgs>>): Prisma__PodHolderStatusClient<$Result.GetResult<Prisma.$PodHolderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PodHolderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusCountArgs} args - Arguments to filter PodHolderStatuses to count.
     * @example
     * // Count the number of PodHolderStatuses
     * const count = await prisma.podHolderStatus.count({
     *   where: {
     *     // ... the filter for the PodHolderStatuses we want to count
     *   }
     * })
    **/
    count<T extends PodHolderStatusCountArgs>(
      args?: Subset<T, PodHolderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodHolderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PodHolderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodHolderStatusAggregateArgs>(args: Subset<T, PodHolderStatusAggregateArgs>): Prisma.PrismaPromise<GetPodHolderStatusAggregateType<T>>

    /**
     * Group by PodHolderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodHolderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PodHolderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PodHolderStatusGroupByArgs['orderBy'] }
        : { orderBy?: PodHolderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PodHolderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodHolderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PodHolderStatus model
   */
  readonly fields: PodHolderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PodHolderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PodHolderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pod_holder<T extends PodHolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodHolderDefaultArgs<ExtArgs>>): Prisma__PodHolderClient<$Result.GetResult<Prisma.$PodHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PodHolderStatus model
   */
  interface PodHolderStatusFieldRefs {
    readonly status_id: FieldRef<"PodHolderStatus", 'String'>
    readonly pod_holder_id: FieldRef<"PodHolderStatus", 'String'>
    readonly battery_level: FieldRef<"PodHolderStatus", 'Int'>
    readonly working_status: FieldRef<"PodHolderStatus", 'String'>
    readonly last_sync: FieldRef<"PodHolderStatus", 'DateTime'>
    readonly created_at: FieldRef<"PodHolderStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PodHolderStatus findUnique
   */
  export type PodHolderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderStatus to fetch.
     */
    where: PodHolderStatusWhereUniqueInput
  }

  /**
   * PodHolderStatus findUniqueOrThrow
   */
  export type PodHolderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderStatus to fetch.
     */
    where: PodHolderStatusWhereUniqueInput
  }

  /**
   * PodHolderStatus findFirst
   */
  export type PodHolderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderStatus to fetch.
     */
    where?: PodHolderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderStatuses to fetch.
     */
    orderBy?: PodHolderStatusOrderByWithRelationInput | PodHolderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolderStatuses.
     */
    cursor?: PodHolderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolderStatuses.
     */
    distinct?: PodHolderStatusScalarFieldEnum | PodHolderStatusScalarFieldEnum[]
  }

  /**
   * PodHolderStatus findFirstOrThrow
   */
  export type PodHolderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderStatus to fetch.
     */
    where?: PodHolderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderStatuses to fetch.
     */
    orderBy?: PodHolderStatusOrderByWithRelationInput | PodHolderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PodHolderStatuses.
     */
    cursor?: PodHolderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PodHolderStatuses.
     */
    distinct?: PodHolderStatusScalarFieldEnum | PodHolderStatusScalarFieldEnum[]
  }

  /**
   * PodHolderStatus findMany
   */
  export type PodHolderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter, which PodHolderStatuses to fetch.
     */
    where?: PodHolderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PodHolderStatuses to fetch.
     */
    orderBy?: PodHolderStatusOrderByWithRelationInput | PodHolderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PodHolderStatuses.
     */
    cursor?: PodHolderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PodHolderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PodHolderStatuses.
     */
    skip?: number
    distinct?: PodHolderStatusScalarFieldEnum | PodHolderStatusScalarFieldEnum[]
  }

  /**
   * PodHolderStatus create
   */
  export type PodHolderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PodHolderStatus.
     */
    data: XOR<PodHolderStatusCreateInput, PodHolderStatusUncheckedCreateInput>
  }

  /**
   * PodHolderStatus createMany
   */
  export type PodHolderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PodHolderStatuses.
     */
    data: PodHolderStatusCreateManyInput | PodHolderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PodHolderStatus createManyAndReturn
   */
  export type PodHolderStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * The data used to create many PodHolderStatuses.
     */
    data: PodHolderStatusCreateManyInput | PodHolderStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolderStatus update
   */
  export type PodHolderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PodHolderStatus.
     */
    data: XOR<PodHolderStatusUpdateInput, PodHolderStatusUncheckedUpdateInput>
    /**
     * Choose, which PodHolderStatus to update.
     */
    where: PodHolderStatusWhereUniqueInput
  }

  /**
   * PodHolderStatus updateMany
   */
  export type PodHolderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PodHolderStatuses.
     */
    data: XOR<PodHolderStatusUpdateManyMutationInput, PodHolderStatusUncheckedUpdateManyInput>
    /**
     * Filter which PodHolderStatuses to update
     */
    where?: PodHolderStatusWhereInput
    /**
     * Limit how many PodHolderStatuses to update.
     */
    limit?: number
  }

  /**
   * PodHolderStatus updateManyAndReturn
   */
  export type PodHolderStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * The data used to update PodHolderStatuses.
     */
    data: XOR<PodHolderStatusUpdateManyMutationInput, PodHolderStatusUncheckedUpdateManyInput>
    /**
     * Filter which PodHolderStatuses to update
     */
    where?: PodHolderStatusWhereInput
    /**
     * Limit how many PodHolderStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PodHolderStatus upsert
   */
  export type PodHolderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PodHolderStatus to update in case it exists.
     */
    where: PodHolderStatusWhereUniqueInput
    /**
     * In case the PodHolderStatus found by the `where` argument doesn't exist, create a new PodHolderStatus with this data.
     */
    create: XOR<PodHolderStatusCreateInput, PodHolderStatusUncheckedCreateInput>
    /**
     * In case the PodHolderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PodHolderStatusUpdateInput, PodHolderStatusUncheckedUpdateInput>
  }

  /**
   * PodHolderStatus delete
   */
  export type PodHolderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
    /**
     * Filter which PodHolderStatus to delete.
     */
    where: PodHolderStatusWhereUniqueInput
  }

  /**
   * PodHolderStatus deleteMany
   */
  export type PodHolderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PodHolderStatuses to delete
     */
    where?: PodHolderStatusWhereInput
    /**
     * Limit how many PodHolderStatuses to delete.
     */
    limit?: number
  }

  /**
   * PodHolderStatus without action
   */
  export type PodHolderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PodHolderStatus
     */
    select?: PodHolderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PodHolderStatus
     */
    omit?: PodHolderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PodHolderStatusInclude<ExtArgs> | null
  }


  /**
   * Model RawData
   */

  export type AggregateRawData = {
    _count: RawDataCountAggregateOutputType | null
    _avg: RawDataAvgAggregateOutputType | null
    _sum: RawDataSumAggregateOutputType | null
    _min: RawDataMinAggregateOutputType | null
    _max: RawDataMaxAggregateOutputType | null
  }

  export type RawDataAvgAggregateOutputType = {
    acceleration_x: number | null
    acceleration_y: number | null
    acceleration_z: number | null
    latitude: number | null
    longitude: number | null
    w: number | null
    x: number | null
    y: number | null
    z: number | null
    distance: number | null
    speed: number | null
    heart_rate: number | null
  }

  export type RawDataSumAggregateOutputType = {
    acceleration_x: number | null
    acceleration_y: number | null
    acceleration_z: number | null
    latitude: number | null
    longitude: number | null
    w: number | null
    x: number | null
    y: number | null
    z: number | null
    distance: number | null
    speed: number | null
    heart_rate: number | null
  }

  export type RawDataMinAggregateOutputType = {
    raw_id: string | null
    pod_id: string | null
    player_id: string | null
    ts: Date | null
    acceleration_x: number | null
    acceleration_y: number | null
    acceleration_z: number | null
    latitude: number | null
    longitude: number | null
    w: number | null
    x: number | null
    y: number | null
    z: number | null
    distance: number | null
    speed: number | null
    heart_rate: number | null
    created_at: Date | null
  }

  export type RawDataMaxAggregateOutputType = {
    raw_id: string | null
    pod_id: string | null
    player_id: string | null
    ts: Date | null
    acceleration_x: number | null
    acceleration_y: number | null
    acceleration_z: number | null
    latitude: number | null
    longitude: number | null
    w: number | null
    x: number | null
    y: number | null
    z: number | null
    distance: number | null
    speed: number | null
    heart_rate: number | null
    created_at: Date | null
  }

  export type RawDataCountAggregateOutputType = {
    raw_id: number
    pod_id: number
    player_id: number
    ts: number
    acceleration_x: number
    acceleration_y: number
    acceleration_z: number
    latitude: number
    longitude: number
    w: number
    x: number
    y: number
    z: number
    distance: number
    speed: number
    heart_rate: number
    created_at: number
    _all: number
  }


  export type RawDataAvgAggregateInputType = {
    acceleration_x?: true
    acceleration_y?: true
    acceleration_z?: true
    latitude?: true
    longitude?: true
    w?: true
    x?: true
    y?: true
    z?: true
    distance?: true
    speed?: true
    heart_rate?: true
  }

  export type RawDataSumAggregateInputType = {
    acceleration_x?: true
    acceleration_y?: true
    acceleration_z?: true
    latitude?: true
    longitude?: true
    w?: true
    x?: true
    y?: true
    z?: true
    distance?: true
    speed?: true
    heart_rate?: true
  }

  export type RawDataMinAggregateInputType = {
    raw_id?: true
    pod_id?: true
    player_id?: true
    ts?: true
    acceleration_x?: true
    acceleration_y?: true
    acceleration_z?: true
    latitude?: true
    longitude?: true
    w?: true
    x?: true
    y?: true
    z?: true
    distance?: true
    speed?: true
    heart_rate?: true
    created_at?: true
  }

  export type RawDataMaxAggregateInputType = {
    raw_id?: true
    pod_id?: true
    player_id?: true
    ts?: true
    acceleration_x?: true
    acceleration_y?: true
    acceleration_z?: true
    latitude?: true
    longitude?: true
    w?: true
    x?: true
    y?: true
    z?: true
    distance?: true
    speed?: true
    heart_rate?: true
    created_at?: true
  }

  export type RawDataCountAggregateInputType = {
    raw_id?: true
    pod_id?: true
    player_id?: true
    ts?: true
    acceleration_x?: true
    acceleration_y?: true
    acceleration_z?: true
    latitude?: true
    longitude?: true
    w?: true
    x?: true
    y?: true
    z?: true
    distance?: true
    speed?: true
    heart_rate?: true
    created_at?: true
    _all?: true
  }

  export type RawDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawData to aggregate.
     */
    where?: RawDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawData to fetch.
     */
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawData
    **/
    _count?: true | RawDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawDataMaxAggregateInputType
  }

  export type GetRawDataAggregateType<T extends RawDataAggregateArgs> = {
        [P in keyof T & keyof AggregateRawData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawData[P]>
      : GetScalarType<T[P], AggregateRawData[P]>
  }




  export type RawDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawDataWhereInput
    orderBy?: RawDataOrderByWithAggregationInput | RawDataOrderByWithAggregationInput[]
    by: RawDataScalarFieldEnum[] | RawDataScalarFieldEnum
    having?: RawDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawDataCountAggregateInputType | true
    _avg?: RawDataAvgAggregateInputType
    _sum?: RawDataSumAggregateInputType
    _min?: RawDataMinAggregateInputType
    _max?: RawDataMaxAggregateInputType
  }

  export type RawDataGroupByOutputType = {
    raw_id: string
    pod_id: string
    player_id: string | null
    ts: Date | null
    acceleration_x: number | null
    acceleration_y: number | null
    acceleration_z: number | null
    latitude: number | null
    longitude: number | null
    w: number | null
    x: number | null
    y: number | null
    z: number | null
    distance: number | null
    speed: number | null
    heart_rate: number | null
    created_at: Date
    _count: RawDataCountAggregateOutputType | null
    _avg: RawDataAvgAggregateOutputType | null
    _sum: RawDataSumAggregateOutputType | null
    _min: RawDataMinAggregateOutputType | null
    _max: RawDataMaxAggregateOutputType | null
  }

  type GetRawDataGroupByPayload<T extends RawDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawDataGroupByOutputType[P]>
            : GetScalarType<T[P], RawDataGroupByOutputType[P]>
        }
      >
    >


  export type RawDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raw_id?: boolean
    pod_id?: boolean
    player_id?: boolean
    ts?: boolean
    acceleration_x?: boolean
    acceleration_y?: boolean
    acceleration_z?: boolean
    latitude?: boolean
    longitude?: boolean
    w?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    distance?: boolean
    speed?: boolean
    heart_rate?: boolean
    created_at?: boolean
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawData"]>

  export type RawDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raw_id?: boolean
    pod_id?: boolean
    player_id?: boolean
    ts?: boolean
    acceleration_x?: boolean
    acceleration_y?: boolean
    acceleration_z?: boolean
    latitude?: boolean
    longitude?: boolean
    w?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    distance?: boolean
    speed?: boolean
    heart_rate?: boolean
    created_at?: boolean
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawData"]>

  export type RawDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raw_id?: boolean
    pod_id?: boolean
    player_id?: boolean
    ts?: boolean
    acceleration_x?: boolean
    acceleration_y?: boolean
    acceleration_z?: boolean
    latitude?: boolean
    longitude?: boolean
    w?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    distance?: boolean
    speed?: boolean
    heart_rate?: boolean
    created_at?: boolean
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawData"]>

  export type RawDataSelectScalar = {
    raw_id?: boolean
    pod_id?: boolean
    player_id?: boolean
    ts?: boolean
    acceleration_x?: boolean
    acceleration_y?: boolean
    acceleration_z?: boolean
    latitude?: boolean
    longitude?: boolean
    w?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    distance?: boolean
    speed?: boolean
    heart_rate?: boolean
    created_at?: boolean
  }

  export type RawDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raw_id" | "pod_id" | "player_id" | "ts" | "acceleration_x" | "acceleration_y" | "acceleration_z" | "latitude" | "longitude" | "w" | "x" | "y" | "z" | "distance" | "speed" | "heart_rate" | "created_at", ExtArgs["result"]["rawData"]>
  export type RawDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type RawDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }
  export type RawDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | RawData$playerArgs<ExtArgs>
    pod?: boolean | PodDefaultArgs<ExtArgs>
  }

  export type $RawDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawData"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs> | null
      pod: Prisma.$PodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raw_id: string
      pod_id: string
      player_id: string | null
      ts: Date | null
      acceleration_x: number | null
      acceleration_y: number | null
      acceleration_z: number | null
      latitude: number | null
      longitude: number | null
      w: number | null
      x: number | null
      y: number | null
      z: number | null
      distance: number | null
      speed: number | null
      heart_rate: number | null
      created_at: Date
    }, ExtArgs["result"]["rawData"]>
    composites: {}
  }

  type RawDataGetPayload<S extends boolean | null | undefined | RawDataDefaultArgs> = $Result.GetResult<Prisma.$RawDataPayload, S>

  type RawDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawDataCountAggregateInputType | true
    }

  export interface RawDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawData'], meta: { name: 'RawData' } }
    /**
     * Find zero or one RawData that matches the filter.
     * @param {RawDataFindUniqueArgs} args - Arguments to find a RawData
     * @example
     * // Get one RawData
     * const rawData = await prisma.rawData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawDataFindUniqueArgs>(args: SelectSubset<T, RawDataFindUniqueArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawDataFindUniqueOrThrowArgs} args - Arguments to find a RawData
     * @example
     * // Get one RawData
     * const rawData = await prisma.rawData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawDataFindUniqueOrThrowArgs>(args: SelectSubset<T, RawDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataFindFirstArgs} args - Arguments to find a RawData
     * @example
     * // Get one RawData
     * const rawData = await prisma.rawData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawDataFindFirstArgs>(args?: SelectSubset<T, RawDataFindFirstArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataFindFirstOrThrowArgs} args - Arguments to find a RawData
     * @example
     * // Get one RawData
     * const rawData = await prisma.rawData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawDataFindFirstOrThrowArgs>(args?: SelectSubset<T, RawDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawData
     * const rawData = await prisma.rawData.findMany()
     * 
     * // Get first 10 RawData
     * const rawData = await prisma.rawData.findMany({ take: 10 })
     * 
     * // Only select the `raw_id`
     * const rawDataWithRaw_idOnly = await prisma.rawData.findMany({ select: { raw_id: true } })
     * 
     */
    findMany<T extends RawDataFindManyArgs>(args?: SelectSubset<T, RawDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawData.
     * @param {RawDataCreateArgs} args - Arguments to create a RawData.
     * @example
     * // Create one RawData
     * const RawData = await prisma.rawData.create({
     *   data: {
     *     // ... data to create a RawData
     *   }
     * })
     * 
     */
    create<T extends RawDataCreateArgs>(args: SelectSubset<T, RawDataCreateArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawData.
     * @param {RawDataCreateManyArgs} args - Arguments to create many RawData.
     * @example
     * // Create many RawData
     * const rawData = await prisma.rawData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawDataCreateManyArgs>(args?: SelectSubset<T, RawDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawData and returns the data saved in the database.
     * @param {RawDataCreateManyAndReturnArgs} args - Arguments to create many RawData.
     * @example
     * // Create many RawData
     * const rawData = await prisma.rawData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawData and only return the `raw_id`
     * const rawDataWithRaw_idOnly = await prisma.rawData.createManyAndReturn({
     *   select: { raw_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawDataCreateManyAndReturnArgs>(args?: SelectSubset<T, RawDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RawData.
     * @param {RawDataDeleteArgs} args - Arguments to delete one RawData.
     * @example
     * // Delete one RawData
     * const RawData = await prisma.rawData.delete({
     *   where: {
     *     // ... filter to delete one RawData
     *   }
     * })
     * 
     */
    delete<T extends RawDataDeleteArgs>(args: SelectSubset<T, RawDataDeleteArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawData.
     * @param {RawDataUpdateArgs} args - Arguments to update one RawData.
     * @example
     * // Update one RawData
     * const rawData = await prisma.rawData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawDataUpdateArgs>(args: SelectSubset<T, RawDataUpdateArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawData.
     * @param {RawDataDeleteManyArgs} args - Arguments to filter RawData to delete.
     * @example
     * // Delete a few RawData
     * const { count } = await prisma.rawData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawDataDeleteManyArgs>(args?: SelectSubset<T, RawDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawData
     * const rawData = await prisma.rawData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawDataUpdateManyArgs>(args: SelectSubset<T, RawDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawData and returns the data updated in the database.
     * @param {RawDataUpdateManyAndReturnArgs} args - Arguments to update many RawData.
     * @example
     * // Update many RawData
     * const rawData = await prisma.rawData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RawData and only return the `raw_id`
     * const rawDataWithRaw_idOnly = await prisma.rawData.updateManyAndReturn({
     *   select: { raw_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RawDataUpdateManyAndReturnArgs>(args: SelectSubset<T, RawDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RawData.
     * @param {RawDataUpsertArgs} args - Arguments to update or create a RawData.
     * @example
     * // Update or create a RawData
     * const rawData = await prisma.rawData.upsert({
     *   create: {
     *     // ... data to create a RawData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawData we want to update
     *   }
     * })
     */
    upsert<T extends RawDataUpsertArgs>(args: SelectSubset<T, RawDataUpsertArgs<ExtArgs>>): Prisma__RawDataClient<$Result.GetResult<Prisma.$RawDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataCountArgs} args - Arguments to filter RawData to count.
     * @example
     * // Count the number of RawData
     * const count = await prisma.rawData.count({
     *   where: {
     *     // ... the filter for the RawData we want to count
     *   }
     * })
    **/
    count<T extends RawDataCountArgs>(
      args?: Subset<T, RawDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawDataAggregateArgs>(args: Subset<T, RawDataAggregateArgs>): Prisma.PrismaPromise<GetRawDataAggregateType<T>>

    /**
     * Group by RawData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawDataGroupByArgs['orderBy'] }
        : { orderBy?: RawDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawData model
   */
  readonly fields: RawDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends RawData$playerArgs<ExtArgs> = {}>(args?: Subset<T, RawData$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pod<T extends PodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PodDefaultArgs<ExtArgs>>): Prisma__PodClient<$Result.GetResult<Prisma.$PodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawData model
   */
  interface RawDataFieldRefs {
    readonly raw_id: FieldRef<"RawData", 'String'>
    readonly pod_id: FieldRef<"RawData", 'String'>
    readonly player_id: FieldRef<"RawData", 'String'>
    readonly ts: FieldRef<"RawData", 'DateTime'>
    readonly acceleration_x: FieldRef<"RawData", 'Float'>
    readonly acceleration_y: FieldRef<"RawData", 'Float'>
    readonly acceleration_z: FieldRef<"RawData", 'Float'>
    readonly latitude: FieldRef<"RawData", 'Float'>
    readonly longitude: FieldRef<"RawData", 'Float'>
    readonly w: FieldRef<"RawData", 'Float'>
    readonly x: FieldRef<"RawData", 'Float'>
    readonly y: FieldRef<"RawData", 'Float'>
    readonly z: FieldRef<"RawData", 'Float'>
    readonly distance: FieldRef<"RawData", 'Float'>
    readonly speed: FieldRef<"RawData", 'Float'>
    readonly heart_rate: FieldRef<"RawData", 'Int'>
    readonly created_at: FieldRef<"RawData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RawData findUnique
   */
  export type RawDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter, which RawData to fetch.
     */
    where: RawDataWhereUniqueInput
  }

  /**
   * RawData findUniqueOrThrow
   */
  export type RawDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter, which RawData to fetch.
     */
    where: RawDataWhereUniqueInput
  }

  /**
   * RawData findFirst
   */
  export type RawDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter, which RawData to fetch.
     */
    where?: RawDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawData to fetch.
     */
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawData.
     */
    cursor?: RawDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawData.
     */
    distinct?: RawDataScalarFieldEnum | RawDataScalarFieldEnum[]
  }

  /**
   * RawData findFirstOrThrow
   */
  export type RawDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter, which RawData to fetch.
     */
    where?: RawDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawData to fetch.
     */
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawData.
     */
    cursor?: RawDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawData.
     */
    distinct?: RawDataScalarFieldEnum | RawDataScalarFieldEnum[]
  }

  /**
   * RawData findMany
   */
  export type RawDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter, which RawData to fetch.
     */
    where?: RawDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawData to fetch.
     */
    orderBy?: RawDataOrderByWithRelationInput | RawDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawData.
     */
    cursor?: RawDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawData.
     */
    skip?: number
    distinct?: RawDataScalarFieldEnum | RawDataScalarFieldEnum[]
  }

  /**
   * RawData create
   */
  export type RawDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * The data needed to create a RawData.
     */
    data: XOR<RawDataCreateInput, RawDataUncheckedCreateInput>
  }

  /**
   * RawData createMany
   */
  export type RawDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawData.
     */
    data: RawDataCreateManyInput | RawDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawData createManyAndReturn
   */
  export type RawDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * The data used to create many RawData.
     */
    data: RawDataCreateManyInput | RawDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawData update
   */
  export type RawDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * The data needed to update a RawData.
     */
    data: XOR<RawDataUpdateInput, RawDataUncheckedUpdateInput>
    /**
     * Choose, which RawData to update.
     */
    where: RawDataWhereUniqueInput
  }

  /**
   * RawData updateMany
   */
  export type RawDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawData.
     */
    data: XOR<RawDataUpdateManyMutationInput, RawDataUncheckedUpdateManyInput>
    /**
     * Filter which RawData to update
     */
    where?: RawDataWhereInput
    /**
     * Limit how many RawData to update.
     */
    limit?: number
  }

  /**
   * RawData updateManyAndReturn
   */
  export type RawDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * The data used to update RawData.
     */
    data: XOR<RawDataUpdateManyMutationInput, RawDataUncheckedUpdateManyInput>
    /**
     * Filter which RawData to update
     */
    where?: RawDataWhereInput
    /**
     * Limit how many RawData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawData upsert
   */
  export type RawDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * The filter to search for the RawData to update in case it exists.
     */
    where: RawDataWhereUniqueInput
    /**
     * In case the RawData found by the `where` argument doesn't exist, create a new RawData with this data.
     */
    create: XOR<RawDataCreateInput, RawDataUncheckedCreateInput>
    /**
     * In case the RawData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawDataUpdateInput, RawDataUncheckedUpdateInput>
  }

  /**
   * RawData delete
   */
  export type RawDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
    /**
     * Filter which RawData to delete.
     */
    where: RawDataWhereUniqueInput
  }

  /**
   * RawData deleteMany
   */
  export type RawDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawData to delete
     */
    where?: RawDataWhereInput
    /**
     * Limit how many RawData to delete.
     */
    limit?: number
  }

  /**
   * RawData.player
   */
  export type RawData$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * RawData without action
   */
  export type RawDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawData
     */
    select?: RawDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawData
     */
    omit?: RawDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDataInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    event_id: string | null
    club_id: string | null
    event_name: string | null
    event_date: Date | null
    location: string | null
    event_type: string | null
    created_at: Date | null
  }

  export type EventMaxAggregateOutputType = {
    event_id: string | null
    club_id: string | null
    event_name: string | null
    event_date: Date | null
    location: string | null
    event_type: string | null
    created_at: Date | null
  }

  export type EventCountAggregateOutputType = {
    event_id: number
    club_id: number
    event_name: number
    event_date: number
    location: number
    event_type: number
    created_at: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    event_id?: true
    club_id?: true
    event_name?: true
    event_date?: true
    location?: true
    event_type?: true
    created_at?: true
  }

  export type EventMaxAggregateInputType = {
    event_id?: true
    club_id?: true
    event_name?: true
    event_date?: true
    location?: true
    event_type?: true
    created_at?: true
  }

  export type EventCountAggregateInputType = {
    event_id?: true
    club_id?: true
    event_name?: true
    event_date?: true
    location?: true
    event_type?: true
    created_at?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    event_id: string
    club_id: string
    event_name: string | null
    event_date: Date | null
    location: string | null
    event_type: string | null
    created_at: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    club_id?: boolean
    event_name?: boolean
    event_date?: boolean
    location?: boolean
    event_type?: boolean
    created_at?: boolean
    event_participants?: boolean | Event$event_participantsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    club_id?: boolean
    event_name?: boolean
    event_date?: boolean
    location?: boolean
    event_type?: boolean
    created_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    club_id?: boolean
    event_name?: boolean
    event_date?: boolean
    location?: boolean
    event_type?: boolean
    created_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    event_id?: boolean
    club_id?: boolean
    event_name?: boolean
    event_date?: boolean
    location?: boolean
    event_type?: boolean
    created_at?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_id" | "club_id" | "event_name" | "event_date" | "location" | "event_type" | "created_at", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event_participants?: boolean | Event$event_participantsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      event_participants: Prisma.$EventParticipantPayload<ExtArgs>[]
      club: Prisma.$ClubPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: string
      club_id: string
      event_name: string | null
      event_date: Date | null
      location: string | null
      event_type: string | null
      created_at: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.createManyAndReturn({
     *   select: { event_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.updateManyAndReturn({
     *   select: { event_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event_participants<T extends Event$event_participantsArgs<ExtArgs> = {}>(args?: Subset<T, Event$event_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly event_id: FieldRef<"Event", 'String'>
    readonly club_id: FieldRef<"Event", 'String'>
    readonly event_name: FieldRef<"Event", 'String'>
    readonly event_date: FieldRef<"Event", 'DateTime'>
    readonly location: FieldRef<"Event", 'String'>
    readonly event_type: FieldRef<"Event", 'String'>
    readonly created_at: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.event_participants
   */
  export type Event$event_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    cursor?: EventParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventParticipant
   */

  export type AggregateEventParticipant = {
    _count: EventParticipantCountAggregateOutputType | null
    _min: EventParticipantMinAggregateOutputType | null
    _max: EventParticipantMaxAggregateOutputType | null
  }

  export type EventParticipantMinAggregateOutputType = {
    id: string | null
    event_id: string | null
    coach_id: string | null
    player_id: string | null
  }

  export type EventParticipantMaxAggregateOutputType = {
    id: string | null
    event_id: string | null
    coach_id: string | null
    player_id: string | null
  }

  export type EventParticipantCountAggregateOutputType = {
    id: number
    event_id: number
    coach_id: number
    player_id: number
    _all: number
  }


  export type EventParticipantMinAggregateInputType = {
    id?: true
    event_id?: true
    coach_id?: true
    player_id?: true
  }

  export type EventParticipantMaxAggregateInputType = {
    id?: true
    event_id?: true
    coach_id?: true
    player_id?: true
  }

  export type EventParticipantCountAggregateInputType = {
    id?: true
    event_id?: true
    coach_id?: true
    player_id?: true
    _all?: true
  }

  export type EventParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipant to aggregate.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventParticipants
    **/
    _count?: true | EventParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventParticipantMaxAggregateInputType
  }

  export type GetEventParticipantAggregateType<T extends EventParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateEventParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventParticipant[P]>
      : GetScalarType<T[P], AggregateEventParticipant[P]>
  }




  export type EventParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipantWhereInput
    orderBy?: EventParticipantOrderByWithAggregationInput | EventParticipantOrderByWithAggregationInput[]
    by: EventParticipantScalarFieldEnum[] | EventParticipantScalarFieldEnum
    having?: EventParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventParticipantCountAggregateInputType | true
    _min?: EventParticipantMinAggregateInputType
    _max?: EventParticipantMaxAggregateInputType
  }

  export type EventParticipantGroupByOutputType = {
    id: string
    event_id: string
    coach_id: string | null
    player_id: string | null
    _count: EventParticipantCountAggregateOutputType | null
    _min: EventParticipantMinAggregateOutputType | null
    _max: EventParticipantMaxAggregateOutputType | null
  }

  type GetEventParticipantGroupByPayload<T extends EventParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>
        }
      >
    >


  export type EventParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    coach_id?: boolean
    player_id?: boolean
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipant"]>

  export type EventParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    coach_id?: boolean
    player_id?: boolean
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipant"]>

  export type EventParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    coach_id?: boolean
    player_id?: boolean
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipant"]>

  export type EventParticipantSelectScalar = {
    id?: boolean
    event_id?: boolean
    coach_id?: boolean
    player_id?: boolean
  }

  export type EventParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_id" | "coach_id" | "player_id", ExtArgs["result"]["eventParticipant"]>
  export type EventParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }
  export type EventParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }
  export type EventParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | EventParticipant$coachArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    player?: boolean | EventParticipant$playerArgs<ExtArgs>
  }

  export type $EventParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventParticipant"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      event_id: string
      coach_id: string | null
      player_id: string | null
    }, ExtArgs["result"]["eventParticipant"]>
    composites: {}
  }

  type EventParticipantGetPayload<S extends boolean | null | undefined | EventParticipantDefaultArgs> = $Result.GetResult<Prisma.$EventParticipantPayload, S>

  type EventParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventParticipantCountAggregateInputType | true
    }

  export interface EventParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventParticipant'], meta: { name: 'EventParticipant' } }
    /**
     * Find zero or one EventParticipant that matches the filter.
     * @param {EventParticipantFindUniqueArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventParticipantFindUniqueArgs>(args: SelectSubset<T, EventParticipantFindUniqueArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventParticipantFindUniqueOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, EventParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventParticipantFindFirstArgs>(args?: SelectSubset<T, EventParticipantFindFirstArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, EventParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany()
     * 
     * // Get first 10 EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventParticipantFindManyArgs>(args?: SelectSubset<T, EventParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventParticipant.
     * @param {EventParticipantCreateArgs} args - Arguments to create a EventParticipant.
     * @example
     * // Create one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.create({
     *   data: {
     *     // ... data to create a EventParticipant
     *   }
     * })
     * 
     */
    create<T extends EventParticipantCreateArgs>(args: SelectSubset<T, EventParticipantCreateArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventParticipants.
     * @param {EventParticipantCreateManyArgs} args - Arguments to create many EventParticipants.
     * @example
     * // Create many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventParticipantCreateManyArgs>(args?: SelectSubset<T, EventParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventParticipants and returns the data saved in the database.
     * @param {EventParticipantCreateManyAndReturnArgs} args - Arguments to create many EventParticipants.
     * @example
     * // Create many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventParticipants and only return the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, EventParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventParticipant.
     * @param {EventParticipantDeleteArgs} args - Arguments to delete one EventParticipant.
     * @example
     * // Delete one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.delete({
     *   where: {
     *     // ... filter to delete one EventParticipant
     *   }
     * })
     * 
     */
    delete<T extends EventParticipantDeleteArgs>(args: SelectSubset<T, EventParticipantDeleteArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventParticipant.
     * @param {EventParticipantUpdateArgs} args - Arguments to update one EventParticipant.
     * @example
     * // Update one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventParticipantUpdateArgs>(args: SelectSubset<T, EventParticipantUpdateArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventParticipants.
     * @param {EventParticipantDeleteManyArgs} args - Arguments to filter EventParticipants to delete.
     * @example
     * // Delete a few EventParticipants
     * const { count } = await prisma.eventParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventParticipantDeleteManyArgs>(args?: SelectSubset<T, EventParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventParticipantUpdateManyArgs>(args: SelectSubset<T, EventParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventParticipants and returns the data updated in the database.
     * @param {EventParticipantUpdateManyAndReturnArgs} args - Arguments to update many EventParticipants.
     * @example
     * // Update many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventParticipants and only return the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, EventParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventParticipant.
     * @param {EventParticipantUpsertArgs} args - Arguments to update or create a EventParticipant.
     * @example
     * // Update or create a EventParticipant
     * const eventParticipant = await prisma.eventParticipant.upsert({
     *   create: {
     *     // ... data to create a EventParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventParticipant we want to update
     *   }
     * })
     */
    upsert<T extends EventParticipantUpsertArgs>(args: SelectSubset<T, EventParticipantUpsertArgs<ExtArgs>>): Prisma__EventParticipantClient<$Result.GetResult<Prisma.$EventParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantCountArgs} args - Arguments to filter EventParticipants to count.
     * @example
     * // Count the number of EventParticipants
     * const count = await prisma.eventParticipant.count({
     *   where: {
     *     // ... the filter for the EventParticipants we want to count
     *   }
     * })
    **/
    count<T extends EventParticipantCountArgs>(
      args?: Subset<T, EventParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventParticipantAggregateArgs>(args: Subset<T, EventParticipantAggregateArgs>): Prisma.PrismaPromise<GetEventParticipantAggregateType<T>>

    /**
     * Group by EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventParticipantGroupByArgs['orderBy'] }
        : { orderBy?: EventParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventParticipant model
   */
  readonly fields: EventParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends EventParticipant$coachArgs<ExtArgs> = {}>(args?: Subset<T, EventParticipant$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends EventParticipant$playerArgs<ExtArgs> = {}>(args?: Subset<T, EventParticipant$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventParticipant model
   */
  interface EventParticipantFieldRefs {
    readonly id: FieldRef<"EventParticipant", 'String'>
    readonly event_id: FieldRef<"EventParticipant", 'String'>
    readonly coach_id: FieldRef<"EventParticipant", 'String'>
    readonly player_id: FieldRef<"EventParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventParticipant findUnique
   */
  export type EventParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant findUniqueOrThrow
   */
  export type EventParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant findFirst
   */
  export type EventParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipants.
     */
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant findFirstOrThrow
   */
  export type EventParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipants.
     */
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant findMany
   */
  export type EventParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipants to fetch.
     */
    where?: EventParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?: EventParticipantOrderByWithRelationInput | EventParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipants.
     */
    skip?: number
    distinct?: EventParticipantScalarFieldEnum | EventParticipantScalarFieldEnum[]
  }

  /**
   * EventParticipant create
   */
  export type EventParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a EventParticipant.
     */
    data: XOR<EventParticipantCreateInput, EventParticipantUncheckedCreateInput>
  }

  /**
   * EventParticipant createMany
   */
  export type EventParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventParticipants.
     */
    data: EventParticipantCreateManyInput | EventParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventParticipant createManyAndReturn
   */
  export type EventParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many EventParticipants.
     */
    data: EventParticipantCreateManyInput | EventParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventParticipant update
   */
  export type EventParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a EventParticipant.
     */
    data: XOR<EventParticipantUpdateInput, EventParticipantUncheckedUpdateInput>
    /**
     * Choose, which EventParticipant to update.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant updateMany
   */
  export type EventParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventParticipants.
     */
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EventParticipants to update
     */
    where?: EventParticipantWhereInput
    /**
     * Limit how many EventParticipants to update.
     */
    limit?: number
  }

  /**
   * EventParticipant updateManyAndReturn
   */
  export type EventParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * The data used to update EventParticipants.
     */
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EventParticipants to update
     */
    where?: EventParticipantWhereInput
    /**
     * Limit how many EventParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventParticipant upsert
   */
  export type EventParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the EventParticipant to update in case it exists.
     */
    where: EventParticipantWhereUniqueInput
    /**
     * In case the EventParticipant found by the `where` argument doesn't exist, create a new EventParticipant with this data.
     */
    create: XOR<EventParticipantCreateInput, EventParticipantUncheckedCreateInput>
    /**
     * In case the EventParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventParticipantUpdateInput, EventParticipantUncheckedUpdateInput>
  }

  /**
   * EventParticipant delete
   */
  export type EventParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
    /**
     * Filter which EventParticipant to delete.
     */
    where: EventParticipantWhereUniqueInput
  }

  /**
   * EventParticipant deleteMany
   */
  export type EventParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipants to delete
     */
    where?: EventParticipantWhereInput
    /**
     * Limit how many EventParticipants to delete.
     */
    limit?: number
  }

  /**
   * EventParticipant.coach
   */
  export type EventParticipant$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coach
     */
    omit?: CoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * EventParticipant.player
   */
  export type EventParticipant$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * EventParticipant without action
   */
  export type EventParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null
  }


  /**
   * Model PaymentPlan
   */

  export type AggregatePaymentPlan = {
    _count: PaymentPlanCountAggregateOutputType | null
    _avg: PaymentPlanAvgAggregateOutputType | null
    _sum: PaymentPlanSumAggregateOutputType | null
    _min: PaymentPlanMinAggregateOutputType | null
    _max: PaymentPlanMaxAggregateOutputType | null
  }

  export type PaymentPlanAvgAggregateOutputType = {
    price_cents: number | null
    duration_days: number | null
  }

  export type PaymentPlanSumAggregateOutputType = {
    price_cents: number | null
    duration_days: number | null
  }

  export type PaymentPlanMinAggregateOutputType = {
    plan_id: string | null
    name: string | null
    price_cents: number | null
    duration_days: number | null
    description: string | null
    created_at: Date | null
  }

  export type PaymentPlanMaxAggregateOutputType = {
    plan_id: string | null
    name: string | null
    price_cents: number | null
    duration_days: number | null
    description: string | null
    created_at: Date | null
  }

  export type PaymentPlanCountAggregateOutputType = {
    plan_id: number
    name: number
    price_cents: number
    duration_days: number
    description: number
    created_at: number
    _all: number
  }


  export type PaymentPlanAvgAggregateInputType = {
    price_cents?: true
    duration_days?: true
  }

  export type PaymentPlanSumAggregateInputType = {
    price_cents?: true
    duration_days?: true
  }

  export type PaymentPlanMinAggregateInputType = {
    plan_id?: true
    name?: true
    price_cents?: true
    duration_days?: true
    description?: true
    created_at?: true
  }

  export type PaymentPlanMaxAggregateInputType = {
    plan_id?: true
    name?: true
    price_cents?: true
    duration_days?: true
    description?: true
    created_at?: true
  }

  export type PaymentPlanCountAggregateInputType = {
    plan_id?: true
    name?: true
    price_cents?: true
    duration_days?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type PaymentPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentPlan to aggregate.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentPlans
    **/
    _count?: true | PaymentPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentPlanMaxAggregateInputType
  }

  export type GetPaymentPlanAggregateType<T extends PaymentPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentPlan[P]>
      : GetScalarType<T[P], AggregatePaymentPlan[P]>
  }




  export type PaymentPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentPlanWhereInput
    orderBy?: PaymentPlanOrderByWithAggregationInput | PaymentPlanOrderByWithAggregationInput[]
    by: PaymentPlanScalarFieldEnum[] | PaymentPlanScalarFieldEnum
    having?: PaymentPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentPlanCountAggregateInputType | true
    _avg?: PaymentPlanAvgAggregateInputType
    _sum?: PaymentPlanSumAggregateInputType
    _min?: PaymentPlanMinAggregateInputType
    _max?: PaymentPlanMaxAggregateInputType
  }

  export type PaymentPlanGroupByOutputType = {
    plan_id: string
    name: string | null
    price_cents: number | null
    duration_days: number | null
    description: string | null
    created_at: Date
    _count: PaymentPlanCountAggregateOutputType | null
    _avg: PaymentPlanAvgAggregateOutputType | null
    _sum: PaymentPlanSumAggregateOutputType | null
    _min: PaymentPlanMinAggregateOutputType | null
    _max: PaymentPlanMaxAggregateOutputType | null
  }

  type GetPaymentPlanGroupByPayload<T extends PaymentPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentPlanGroupByOutputType[P]>
        }
      >
    >


  export type PaymentPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plan_id?: boolean
    name?: boolean
    price_cents?: boolean
    duration_days?: boolean
    description?: boolean
    created_at?: boolean
    subscriptions?: boolean | PaymentPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PaymentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plan_id?: boolean
    name?: boolean
    price_cents?: boolean
    duration_days?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plan_id?: boolean
    name?: boolean
    price_cents?: boolean
    duration_days?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectScalar = {
    plan_id?: boolean
    name?: boolean
    price_cents?: boolean
    duration_days?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type PaymentPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"plan_id" | "name" | "price_cents" | "duration_days" | "description" | "created_at", ExtArgs["result"]["paymentPlan"]>
  export type PaymentPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PaymentPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PaymentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      plan_id: string
      name: string | null
      price_cents: number | null
      duration_days: number | null
      description: string | null
      created_at: Date
    }, ExtArgs["result"]["paymentPlan"]>
    composites: {}
  }

  type PaymentPlanGetPayload<S extends boolean | null | undefined | PaymentPlanDefaultArgs> = $Result.GetResult<Prisma.$PaymentPlanPayload, S>

  type PaymentPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentPlanCountAggregateInputType | true
    }

  export interface PaymentPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentPlan'], meta: { name: 'PaymentPlan' } }
    /**
     * Find zero or one PaymentPlan that matches the filter.
     * @param {PaymentPlanFindUniqueArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentPlanFindUniqueArgs>(args: SelectSubset<T, PaymentPlanFindUniqueArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentPlanFindUniqueOrThrowArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindFirstArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentPlanFindFirstArgs>(args?: SelectSubset<T, PaymentPlanFindFirstArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindFirstOrThrowArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentPlans
     * const paymentPlans = await prisma.paymentPlan.findMany()
     * 
     * // Get first 10 PaymentPlans
     * const paymentPlans = await prisma.paymentPlan.findMany({ take: 10 })
     * 
     * // Only select the `plan_id`
     * const paymentPlanWithPlan_idOnly = await prisma.paymentPlan.findMany({ select: { plan_id: true } })
     * 
     */
    findMany<T extends PaymentPlanFindManyArgs>(args?: SelectSubset<T, PaymentPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentPlan.
     * @param {PaymentPlanCreateArgs} args - Arguments to create a PaymentPlan.
     * @example
     * // Create one PaymentPlan
     * const PaymentPlan = await prisma.paymentPlan.create({
     *   data: {
     *     // ... data to create a PaymentPlan
     *   }
     * })
     * 
     */
    create<T extends PaymentPlanCreateArgs>(args: SelectSubset<T, PaymentPlanCreateArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentPlans.
     * @param {PaymentPlanCreateManyArgs} args - Arguments to create many PaymentPlans.
     * @example
     * // Create many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentPlanCreateManyArgs>(args?: SelectSubset<T, PaymentPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentPlans and returns the data saved in the database.
     * @param {PaymentPlanCreateManyAndReturnArgs} args - Arguments to create many PaymentPlans.
     * @example
     * // Create many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentPlans and only return the `plan_id`
     * const paymentPlanWithPlan_idOnly = await prisma.paymentPlan.createManyAndReturn({
     *   select: { plan_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentPlan.
     * @param {PaymentPlanDeleteArgs} args - Arguments to delete one PaymentPlan.
     * @example
     * // Delete one PaymentPlan
     * const PaymentPlan = await prisma.paymentPlan.delete({
     *   where: {
     *     // ... filter to delete one PaymentPlan
     *   }
     * })
     * 
     */
    delete<T extends PaymentPlanDeleteArgs>(args: SelectSubset<T, PaymentPlanDeleteArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentPlan.
     * @param {PaymentPlanUpdateArgs} args - Arguments to update one PaymentPlan.
     * @example
     * // Update one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentPlanUpdateArgs>(args: SelectSubset<T, PaymentPlanUpdateArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentPlans.
     * @param {PaymentPlanDeleteManyArgs} args - Arguments to filter PaymentPlans to delete.
     * @example
     * // Delete a few PaymentPlans
     * const { count } = await prisma.paymentPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentPlanDeleteManyArgs>(args?: SelectSubset<T, PaymentPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentPlanUpdateManyArgs>(args: SelectSubset<T, PaymentPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentPlans and returns the data updated in the database.
     * @param {PaymentPlanUpdateManyAndReturnArgs} args - Arguments to update many PaymentPlans.
     * @example
     * // Update many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentPlans and only return the `plan_id`
     * const paymentPlanWithPlan_idOnly = await prisma.paymentPlan.updateManyAndReturn({
     *   select: { plan_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentPlan.
     * @param {PaymentPlanUpsertArgs} args - Arguments to update or create a PaymentPlan.
     * @example
     * // Update or create a PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.upsert({
     *   create: {
     *     // ... data to create a PaymentPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentPlan we want to update
     *   }
     * })
     */
    upsert<T extends PaymentPlanUpsertArgs>(args: SelectSubset<T, PaymentPlanUpsertArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanCountArgs} args - Arguments to filter PaymentPlans to count.
     * @example
     * // Count the number of PaymentPlans
     * const count = await prisma.paymentPlan.count({
     *   where: {
     *     // ... the filter for the PaymentPlans we want to count
     *   }
     * })
    **/
    count<T extends PaymentPlanCountArgs>(
      args?: Subset<T, PaymentPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentPlanAggregateArgs>(args: Subset<T, PaymentPlanAggregateArgs>): Prisma.PrismaPromise<GetPaymentPlanAggregateType<T>>

    /**
     * Group by PaymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentPlanGroupByArgs['orderBy'] }
        : { orderBy?: PaymentPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentPlan model
   */
  readonly fields: PaymentPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends PaymentPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentPlan model
   */
  interface PaymentPlanFieldRefs {
    readonly plan_id: FieldRef<"PaymentPlan", 'String'>
    readonly name: FieldRef<"PaymentPlan", 'String'>
    readonly price_cents: FieldRef<"PaymentPlan", 'Int'>
    readonly duration_days: FieldRef<"PaymentPlan", 'Int'>
    readonly description: FieldRef<"PaymentPlan", 'String'>
    readonly created_at: FieldRef<"PaymentPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentPlan findUnique
   */
  export type PaymentPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan findUniqueOrThrow
   */
  export type PaymentPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan findFirst
   */
  export type PaymentPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentPlans.
     */
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan findFirstOrThrow
   */
  export type PaymentPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentPlans.
     */
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan findMany
   */
  export type PaymentPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlans to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan create
   */
  export type PaymentPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentPlan.
     */
    data?: XOR<PaymentPlanCreateInput, PaymentPlanUncheckedCreateInput>
  }

  /**
   * PaymentPlan createMany
   */
  export type PaymentPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentPlans.
     */
    data: PaymentPlanCreateManyInput | PaymentPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentPlan createManyAndReturn
   */
  export type PaymentPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentPlans.
     */
    data: PaymentPlanCreateManyInput | PaymentPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentPlan update
   */
  export type PaymentPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentPlan.
     */
    data: XOR<PaymentPlanUpdateInput, PaymentPlanUncheckedUpdateInput>
    /**
     * Choose, which PaymentPlan to update.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan updateMany
   */
  export type PaymentPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentPlans.
     */
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentPlans to update
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to update.
     */
    limit?: number
  }

  /**
   * PaymentPlan updateManyAndReturn
   */
  export type PaymentPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * The data used to update PaymentPlans.
     */
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentPlans to update
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to update.
     */
    limit?: number
  }

  /**
   * PaymentPlan upsert
   */
  export type PaymentPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentPlan to update in case it exists.
     */
    where: PaymentPlanWhereUniqueInput
    /**
     * In case the PaymentPlan found by the `where` argument doesn't exist, create a new PaymentPlan with this data.
     */
    create: XOR<PaymentPlanCreateInput, PaymentPlanUncheckedCreateInput>
    /**
     * In case the PaymentPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentPlanUpdateInput, PaymentPlanUncheckedUpdateInput>
  }

  /**
   * PaymentPlan delete
   */
  export type PaymentPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter which PaymentPlan to delete.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan deleteMany
   */
  export type PaymentPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentPlans to delete
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to delete.
     */
    limit?: number
  }

  /**
   * PaymentPlan.subscriptions
   */
  export type PaymentPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * PaymentPlan without action
   */
  export type PaymentPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    subscription_id: string | null
    club_id: string | null
    plan_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    subscription_id: string | null
    club_id: string | null
    plan_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    subscription_id: number
    club_id: number
    plan_id: number
    start_date: number
    end_date: number
    status: number
    created_at: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    subscription_id?: true
    club_id?: true
    plan_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    subscription_id?: true
    club_id?: true
    plan_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    subscription_id?: true
    club_id?: true
    plan_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    subscription_id: string
    club_id: string
    plan_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscription_id?: boolean
    club_id?: boolean
    plan_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscription_id?: boolean
    club_id?: boolean
    plan_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscription_id?: boolean
    club_id?: boolean
    plan_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    subscription_id?: boolean
    club_id?: boolean
    plan_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subscription_id" | "club_id" | "plan_id" | "start_date" | "end_date" | "status" | "created_at", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
    plan?: boolean | Subscription$planArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      club: Prisma.$ClubPayload<ExtArgs>
      plan: Prisma.$PaymentPlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      subscription_id: string
      club_id: string
      plan_id: string | null
      start_date: Date | null
      end_date: Date | null
      status: string | null
      created_at: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `subscription_id`
     * const subscriptionWithSubscription_idOnly = await prisma.subscription.findMany({ select: { subscription_id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `subscription_id`
     * const subscriptionWithSubscription_idOnly = await prisma.subscription.createManyAndReturn({
     *   select: { subscription_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `subscription_id`
     * const subscriptionWithSubscription_idOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { subscription_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends Subscription$planArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$planArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly subscription_id: FieldRef<"Subscription", 'String'>
    readonly club_id: FieldRef<"Subscription", 'String'>
    readonly plan_id: FieldRef<"Subscription", 'String'>
    readonly start_date: FieldRef<"Subscription", 'DateTime'>
    readonly end_date: FieldRef<"Subscription", 'DateTime'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly created_at: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription.plan
   */
  export type Subscription$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    where?: PaymentPlanWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount_cents: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount_cents: number | null
  }

  export type PaymentMinAggregateOutputType = {
    payment_id: string | null
    subscription_id: string | null
    amount_cents: number | null
    paid_at: Date | null
    method: string | null
    transaction_ref: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    payment_id: string | null
    subscription_id: string | null
    amount_cents: number | null
    paid_at: Date | null
    method: string | null
    transaction_ref: string | null
  }

  export type PaymentCountAggregateOutputType = {
    payment_id: number
    subscription_id: number
    amount_cents: number
    paid_at: number
    method: number
    transaction_ref: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount_cents?: true
  }

  export type PaymentSumAggregateInputType = {
    amount_cents?: true
  }

  export type PaymentMinAggregateInputType = {
    payment_id?: true
    subscription_id?: true
    amount_cents?: true
    paid_at?: true
    method?: true
    transaction_ref?: true
  }

  export type PaymentMaxAggregateInputType = {
    payment_id?: true
    subscription_id?: true
    amount_cents?: true
    paid_at?: true
    method?: true
    transaction_ref?: true
  }

  export type PaymentCountAggregateInputType = {
    payment_id?: true
    subscription_id?: true
    amount_cents?: true
    paid_at?: true
    method?: true
    transaction_ref?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    payment_id: string
    subscription_id: string
    amount_cents: number | null
    paid_at: Date
    method: string | null
    transaction_ref: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    subscription_id?: boolean
    amount_cents?: boolean
    paid_at?: boolean
    method?: boolean
    transaction_ref?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    subscription_id?: boolean
    amount_cents?: boolean
    paid_at?: boolean
    method?: boolean
    transaction_ref?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    subscription_id?: boolean
    amount_cents?: boolean
    paid_at?: boolean
    method?: boolean
    transaction_ref?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    payment_id?: boolean
    subscription_id?: boolean
    amount_cents?: boolean
    paid_at?: boolean
    method?: boolean
    transaction_ref?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_id" | "subscription_id" | "amount_cents" | "paid_at" | "method" | "transaction_ref", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_id: string
      subscription_id: string
      amount_cents: number | null
      paid_at: Date
      method: string | null
      transaction_ref: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.findMany({ select: { payment_id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.createManyAndReturn({
     *   select: { payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.updateManyAndReturn({
     *   select: { payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly payment_id: FieldRef<"Payment", 'String'>
    readonly subscription_id: FieldRef<"Payment", 'String'>
    readonly amount_cents: FieldRef<"Payment", 'Int'>
    readonly paid_at: FieldRef<"Payment", 'DateTime'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly transaction_ref: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRequest
   */

  export type AggregateServiceRequest = {
    _count: ServiceRequestCountAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  export type ServiceRequestMinAggregateOutputType = {
    request_id: string | null
    club_id: string | null
    requester_id: string | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceRequestMaxAggregateOutputType = {
    request_id: string | null
    club_id: string | null
    requester_id: string | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceRequestCountAggregateOutputType = {
    request_id: number
    club_id: number
    requester_id: number
    description: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServiceRequestMinAggregateInputType = {
    request_id?: true
    club_id?: true
    requester_id?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceRequestMaxAggregateInputType = {
    request_id?: true
    club_id?: true
    requester_id?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceRequestCountAggregateInputType = {
    request_id?: true
    club_id?: true
    requester_id?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServiceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequest to aggregate.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRequests
    **/
    _count?: true | ServiceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type GetServiceRequestAggregateType<T extends ServiceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRequest[P]>
      : GetScalarType<T[P], AggregateServiceRequest[P]>
  }




  export type ServiceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithAggregationInput | ServiceRequestOrderByWithAggregationInput[]
    by: ServiceRequestScalarFieldEnum[] | ServiceRequestScalarFieldEnum
    having?: ServiceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRequestCountAggregateInputType | true
    _min?: ServiceRequestMinAggregateInputType
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type ServiceRequestGroupByOutputType = {
    request_id: string
    club_id: string | null
    requester_id: string | null
    description: string | null
    status: string | null
    created_at: Date
    updated_at: Date
    _count: ServiceRequestCountAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  type GetServiceRequestGroupByPayload<T extends ServiceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    request_id?: boolean
    club_id?: boolean
    requester_id?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    request_id?: boolean
    club_id?: boolean
    requester_id?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    request_id?: boolean
    club_id?: boolean
    requester_id?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectScalar = {
    request_id?: boolean
    club_id?: boolean
    requester_id?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServiceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"request_id" | "club_id" | "requester_id" | "description" | "status" | "created_at" | "updated_at", ExtArgs["result"]["serviceRequest"]>
  export type ServiceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }
  export type ServiceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }
  export type ServiceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ServiceRequest$clubArgs<ExtArgs>
  }

  export type $ServiceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRequest"
    objects: {
      club: Prisma.$ClubPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      request_id: string
      club_id: string | null
      requester_id: string | null
      description: string | null
      status: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["serviceRequest"]>
    composites: {}
  }

  type ServiceRequestGetPayload<S extends boolean | null | undefined | ServiceRequestDefaultArgs> = $Result.GetResult<Prisma.$ServiceRequestPayload, S>

  type ServiceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRequestCountAggregateInputType | true
    }

  export interface ServiceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRequest'], meta: { name: 'ServiceRequest' } }
    /**
     * Find zero or one ServiceRequest that matches the filter.
     * @param {ServiceRequestFindUniqueArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRequestFindUniqueArgs>(args: SelectSubset<T, ServiceRequestFindUniqueArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRequestFindUniqueOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRequestFindFirstArgs>(args?: SelectSubset<T, ServiceRequestFindFirstArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany()
     * 
     * // Get first 10 ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany({ take: 10 })
     * 
     * // Only select the `request_id`
     * const serviceRequestWithRequest_idOnly = await prisma.serviceRequest.findMany({ select: { request_id: true } })
     * 
     */
    findMany<T extends ServiceRequestFindManyArgs>(args?: SelectSubset<T, ServiceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRequest.
     * @param {ServiceRequestCreateArgs} args - Arguments to create a ServiceRequest.
     * @example
     * // Create one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.create({
     *   data: {
     *     // ... data to create a ServiceRequest
     *   }
     * })
     * 
     */
    create<T extends ServiceRequestCreateArgs>(args: SelectSubset<T, ServiceRequestCreateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRequests.
     * @param {ServiceRequestCreateManyArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRequestCreateManyArgs>(args?: SelectSubset<T, ServiceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRequests and returns the data saved in the database.
     * @param {ServiceRequestCreateManyAndReturnArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRequests and only return the `request_id`
     * const serviceRequestWithRequest_idOnly = await prisma.serviceRequest.createManyAndReturn({
     *   select: { request_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceRequest.
     * @param {ServiceRequestDeleteArgs} args - Arguments to delete one ServiceRequest.
     * @example
     * // Delete one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.delete({
     *   where: {
     *     // ... filter to delete one ServiceRequest
     *   }
     * })
     * 
     */
    delete<T extends ServiceRequestDeleteArgs>(args: SelectSubset<T, ServiceRequestDeleteArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRequest.
     * @param {ServiceRequestUpdateArgs} args - Arguments to update one ServiceRequest.
     * @example
     * // Update one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRequestUpdateArgs>(args: SelectSubset<T, ServiceRequestUpdateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRequests.
     * @param {ServiceRequestDeleteManyArgs} args - Arguments to filter ServiceRequests to delete.
     * @example
     * // Delete a few ServiceRequests
     * const { count } = await prisma.serviceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRequestDeleteManyArgs>(args?: SelectSubset<T, ServiceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRequestUpdateManyArgs>(args: SelectSubset<T, ServiceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests and returns the data updated in the database.
     * @param {ServiceRequestUpdateManyAndReturnArgs} args - Arguments to update many ServiceRequests.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceRequests and only return the `request_id`
     * const serviceRequestWithRequest_idOnly = await prisma.serviceRequest.updateManyAndReturn({
     *   select: { request_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceRequest.
     * @param {ServiceRequestUpsertArgs} args - Arguments to update or create a ServiceRequest.
     * @example
     * // Update or create a ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.upsert({
     *   create: {
     *     // ... data to create a ServiceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRequest we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRequestUpsertArgs>(args: SelectSubset<T, ServiceRequestUpsertArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestCountArgs} args - Arguments to filter ServiceRequests to count.
     * @example
     * // Count the number of ServiceRequests
     * const count = await prisma.serviceRequest.count({
     *   where: {
     *     // ... the filter for the ServiceRequests we want to count
     *   }
     * })
    **/
    count<T extends ServiceRequestCountArgs>(
      args?: Subset<T, ServiceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRequestAggregateArgs>(args: Subset<T, ServiceRequestAggregateArgs>): Prisma.PrismaPromise<GetServiceRequestAggregateType<T>>

    /**
     * Group by ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRequestGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRequest model
   */
  readonly fields: ServiceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club<T extends ServiceRequest$clubArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$clubArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRequest model
   */
  interface ServiceRequestFieldRefs {
    readonly request_id: FieldRef<"ServiceRequest", 'String'>
    readonly club_id: FieldRef<"ServiceRequest", 'String'>
    readonly requester_id: FieldRef<"ServiceRequest", 'String'>
    readonly description: FieldRef<"ServiceRequest", 'String'>
    readonly status: FieldRef<"ServiceRequest", 'String'>
    readonly created_at: FieldRef<"ServiceRequest", 'DateTime'>
    readonly updated_at: FieldRef<"ServiceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRequest findUnique
   */
  export type ServiceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findUniqueOrThrow
   */
  export type ServiceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findFirst
   */
  export type ServiceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findFirstOrThrow
   */
  export type ServiceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findMany
   */
  export type ServiceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequests to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest create
   */
  export type ServiceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRequest.
     */
    data?: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
  }

  /**
   * ServiceRequest createMany
   */
  export type ServiceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceRequest createManyAndReturn
   */
  export type ServiceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRequest update
   */
  export type ServiceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRequest.
     */
    data: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
    /**
     * Choose, which ServiceRequest to update.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest updateMany
   */
  export type ServiceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
  }

  /**
   * ServiceRequest updateManyAndReturn
   */
  export type ServiceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRequest upsert
   */
  export type ServiceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRequest to update in case it exists.
     */
    where: ServiceRequestWhereUniqueInput
    /**
     * In case the ServiceRequest found by the `where` argument doesn't exist, create a new ServiceRequest with this data.
     */
    create: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
    /**
     * In case the ServiceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
  }

  /**
   * ServiceRequest delete
   */
  export type ServiceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter which ServiceRequest to delete.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest deleteMany
   */
  export type ServiceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequests to delete
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to delete.
     */
    limit?: number
  }

  /**
   * ServiceRequest.club
   */
  export type ServiceRequest$clubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
  }

  /**
   * ServiceRequest without action
   */
  export type ServiceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
  }


  /**
   * Model ActivityMetric
   */

  export type AggregateActivityMetric = {
    _count: ActivityMetricCountAggregateOutputType | null
    _avg: ActivityMetricAvgAggregateOutputType | null
    _sum: ActivityMetricSumAggregateOutputType | null
    _min: ActivityMetricMinAggregateOutputType | null
    _max: ActivityMetricMaxAggregateOutputType | null
  }

  export type ActivityMetricAvgAggregateOutputType = {
    total_distance: number | null
    hsr_distance: number | null
    sprint_distance: number | null
    top_speed: number | null
    sprint_count: number | null
    acceleration: number | null
    deceleration: number | null
    max_acceleration: number | null
    max_deceleration: number | null
    player_load: number | null
    power_score: number | null
    hr_max: number | null
    time_in_red_zone: number | null
    percent_in_red_zone: number | null
    hr_recovery_time: number | null
  }

  export type ActivityMetricSumAggregateOutputType = {
    total_distance: number | null
    hsr_distance: number | null
    sprint_distance: number | null
    top_speed: number | null
    sprint_count: number | null
    acceleration: number | null
    deceleration: number | null
    max_acceleration: number | null
    max_deceleration: number | null
    player_load: number | null
    power_score: number | null
    hr_max: number | null
    time_in_red_zone: number | null
    percent_in_red_zone: number | null
    hr_recovery_time: number | null
  }

  export type ActivityMetricMinAggregateOutputType = {
    id: string | null
    player_id: string | null
    total_distance: number | null
    hsr_distance: number | null
    sprint_distance: number | null
    top_speed: number | null
    sprint_count: number | null
    acceleration: number | null
    deceleration: number | null
    max_acceleration: number | null
    max_deceleration: number | null
    player_load: number | null
    power_score: number | null
    hr_max: number | null
    time_in_red_zone: number | null
    percent_in_red_zone: number | null
    hr_recovery_time: number | null
    recorded_at: Date | null
  }

  export type ActivityMetricMaxAggregateOutputType = {
    id: string | null
    player_id: string | null
    total_distance: number | null
    hsr_distance: number | null
    sprint_distance: number | null
    top_speed: number | null
    sprint_count: number | null
    acceleration: number | null
    deceleration: number | null
    max_acceleration: number | null
    max_deceleration: number | null
    player_load: number | null
    power_score: number | null
    hr_max: number | null
    time_in_red_zone: number | null
    percent_in_red_zone: number | null
    hr_recovery_time: number | null
    recorded_at: Date | null
  }

  export type ActivityMetricCountAggregateOutputType = {
    id: number
    player_id: number
    total_distance: number
    hsr_distance: number
    sprint_distance: number
    top_speed: number
    sprint_count: number
    acceleration: number
    deceleration: number
    max_acceleration: number
    max_deceleration: number
    player_load: number
    power_score: number
    hr_max: number
    time_in_red_zone: number
    percent_in_red_zone: number
    hr_recovery_time: number
    recorded_at: number
    _all: number
  }


  export type ActivityMetricAvgAggregateInputType = {
    total_distance?: true
    hsr_distance?: true
    sprint_distance?: true
    top_speed?: true
    sprint_count?: true
    acceleration?: true
    deceleration?: true
    max_acceleration?: true
    max_deceleration?: true
    player_load?: true
    power_score?: true
    hr_max?: true
    time_in_red_zone?: true
    percent_in_red_zone?: true
    hr_recovery_time?: true
  }

  export type ActivityMetricSumAggregateInputType = {
    total_distance?: true
    hsr_distance?: true
    sprint_distance?: true
    top_speed?: true
    sprint_count?: true
    acceleration?: true
    deceleration?: true
    max_acceleration?: true
    max_deceleration?: true
    player_load?: true
    power_score?: true
    hr_max?: true
    time_in_red_zone?: true
    percent_in_red_zone?: true
    hr_recovery_time?: true
  }

  export type ActivityMetricMinAggregateInputType = {
    id?: true
    player_id?: true
    total_distance?: true
    hsr_distance?: true
    sprint_distance?: true
    top_speed?: true
    sprint_count?: true
    acceleration?: true
    deceleration?: true
    max_acceleration?: true
    max_deceleration?: true
    player_load?: true
    power_score?: true
    hr_max?: true
    time_in_red_zone?: true
    percent_in_red_zone?: true
    hr_recovery_time?: true
    recorded_at?: true
  }

  export type ActivityMetricMaxAggregateInputType = {
    id?: true
    player_id?: true
    total_distance?: true
    hsr_distance?: true
    sprint_distance?: true
    top_speed?: true
    sprint_count?: true
    acceleration?: true
    deceleration?: true
    max_acceleration?: true
    max_deceleration?: true
    player_load?: true
    power_score?: true
    hr_max?: true
    time_in_red_zone?: true
    percent_in_red_zone?: true
    hr_recovery_time?: true
    recorded_at?: true
  }

  export type ActivityMetricCountAggregateInputType = {
    id?: true
    player_id?: true
    total_distance?: true
    hsr_distance?: true
    sprint_distance?: true
    top_speed?: true
    sprint_count?: true
    acceleration?: true
    deceleration?: true
    max_acceleration?: true
    max_deceleration?: true
    player_load?: true
    power_score?: true
    hr_max?: true
    time_in_red_zone?: true
    percent_in_red_zone?: true
    hr_recovery_time?: true
    recorded_at?: true
    _all?: true
  }

  export type ActivityMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityMetric to aggregate.
     */
    where?: ActivityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityMetrics to fetch.
     */
    orderBy?: ActivityMetricOrderByWithRelationInput | ActivityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityMetrics
    **/
    _count?: true | ActivityMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMetricMaxAggregateInputType
  }

  export type GetActivityMetricAggregateType<T extends ActivityMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityMetric[P]>
      : GetScalarType<T[P], AggregateActivityMetric[P]>
  }




  export type ActivityMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityMetricWhereInput
    orderBy?: ActivityMetricOrderByWithAggregationInput | ActivityMetricOrderByWithAggregationInput[]
    by: ActivityMetricScalarFieldEnum[] | ActivityMetricScalarFieldEnum
    having?: ActivityMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityMetricCountAggregateInputType | true
    _avg?: ActivityMetricAvgAggregateInputType
    _sum?: ActivityMetricSumAggregateInputType
    _min?: ActivityMetricMinAggregateInputType
    _max?: ActivityMetricMaxAggregateInputType
  }

  export type ActivityMetricGroupByOutputType = {
    id: string
    player_id: string
    total_distance: number | null
    hsr_distance: number | null
    sprint_distance: number | null
    top_speed: number | null
    sprint_count: number | null
    acceleration: number | null
    deceleration: number | null
    max_acceleration: number | null
    max_deceleration: number | null
    player_load: number | null
    power_score: number | null
    hr_max: number | null
    time_in_red_zone: number | null
    percent_in_red_zone: number | null
    hr_recovery_time: number | null
    recorded_at: Date
    _count: ActivityMetricCountAggregateOutputType | null
    _avg: ActivityMetricAvgAggregateOutputType | null
    _sum: ActivityMetricSumAggregateOutputType | null
    _min: ActivityMetricMinAggregateOutputType | null
    _max: ActivityMetricMaxAggregateOutputType | null
  }

  type GetActivityMetricGroupByPayload<T extends ActivityMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityMetricGroupByOutputType[P]>
        }
      >
    >


  export type ActivityMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    total_distance?: boolean
    hsr_distance?: boolean
    sprint_distance?: boolean
    top_speed?: boolean
    sprint_count?: boolean
    acceleration?: boolean
    deceleration?: boolean
    max_acceleration?: boolean
    max_deceleration?: boolean
    player_load?: boolean
    power_score?: boolean
    hr_max?: boolean
    time_in_red_zone?: boolean
    percent_in_red_zone?: boolean
    hr_recovery_time?: boolean
    recorded_at?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityMetric"]>

  export type ActivityMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    total_distance?: boolean
    hsr_distance?: boolean
    sprint_distance?: boolean
    top_speed?: boolean
    sprint_count?: boolean
    acceleration?: boolean
    deceleration?: boolean
    max_acceleration?: boolean
    max_deceleration?: boolean
    player_load?: boolean
    power_score?: boolean
    hr_max?: boolean
    time_in_red_zone?: boolean
    percent_in_red_zone?: boolean
    hr_recovery_time?: boolean
    recorded_at?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityMetric"]>

  export type ActivityMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    total_distance?: boolean
    hsr_distance?: boolean
    sprint_distance?: boolean
    top_speed?: boolean
    sprint_count?: boolean
    acceleration?: boolean
    deceleration?: boolean
    max_acceleration?: boolean
    max_deceleration?: boolean
    player_load?: boolean
    power_score?: boolean
    hr_max?: boolean
    time_in_red_zone?: boolean
    percent_in_red_zone?: boolean
    hr_recovery_time?: boolean
    recorded_at?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityMetric"]>

  export type ActivityMetricSelectScalar = {
    id?: boolean
    player_id?: boolean
    total_distance?: boolean
    hsr_distance?: boolean
    sprint_distance?: boolean
    top_speed?: boolean
    sprint_count?: boolean
    acceleration?: boolean
    deceleration?: boolean
    max_acceleration?: boolean
    max_deceleration?: boolean
    player_load?: boolean
    power_score?: boolean
    hr_max?: boolean
    time_in_red_zone?: boolean
    percent_in_red_zone?: boolean
    hr_recovery_time?: boolean
    recorded_at?: boolean
  }

  export type ActivityMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "player_id" | "total_distance" | "hsr_distance" | "sprint_distance" | "top_speed" | "sprint_count" | "acceleration" | "deceleration" | "max_acceleration" | "max_deceleration" | "player_load" | "power_score" | "hr_max" | "time_in_red_zone" | "percent_in_red_zone" | "hr_recovery_time" | "recorded_at", ExtArgs["result"]["activityMetric"]>
  export type ActivityMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type ActivityMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type ActivityMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $ActivityMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityMetric"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      player_id: string
      total_distance: number | null
      hsr_distance: number | null
      sprint_distance: number | null
      top_speed: number | null
      sprint_count: number | null
      acceleration: number | null
      deceleration: number | null
      max_acceleration: number | null
      max_deceleration: number | null
      player_load: number | null
      power_score: number | null
      hr_max: number | null
      time_in_red_zone: number | null
      percent_in_red_zone: number | null
      hr_recovery_time: number | null
      recorded_at: Date
    }, ExtArgs["result"]["activityMetric"]>
    composites: {}
  }

  type ActivityMetricGetPayload<S extends boolean | null | undefined | ActivityMetricDefaultArgs> = $Result.GetResult<Prisma.$ActivityMetricPayload, S>

  type ActivityMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityMetricCountAggregateInputType | true
    }

  export interface ActivityMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityMetric'], meta: { name: 'ActivityMetric' } }
    /**
     * Find zero or one ActivityMetric that matches the filter.
     * @param {ActivityMetricFindUniqueArgs} args - Arguments to find a ActivityMetric
     * @example
     * // Get one ActivityMetric
     * const activityMetric = await prisma.activityMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityMetricFindUniqueArgs>(args: SelectSubset<T, ActivityMetricFindUniqueArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityMetricFindUniqueOrThrowArgs} args - Arguments to find a ActivityMetric
     * @example
     * // Get one ActivityMetric
     * const activityMetric = await prisma.activityMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricFindFirstArgs} args - Arguments to find a ActivityMetric
     * @example
     * // Get one ActivityMetric
     * const activityMetric = await prisma.activityMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityMetricFindFirstArgs>(args?: SelectSubset<T, ActivityMetricFindFirstArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricFindFirstOrThrowArgs} args - Arguments to find a ActivityMetric
     * @example
     * // Get one ActivityMetric
     * const activityMetric = await prisma.activityMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityMetrics
     * const activityMetrics = await prisma.activityMetric.findMany()
     * 
     * // Get first 10 ActivityMetrics
     * const activityMetrics = await prisma.activityMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityMetricWithIdOnly = await prisma.activityMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityMetricFindManyArgs>(args?: SelectSubset<T, ActivityMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityMetric.
     * @param {ActivityMetricCreateArgs} args - Arguments to create a ActivityMetric.
     * @example
     * // Create one ActivityMetric
     * const ActivityMetric = await prisma.activityMetric.create({
     *   data: {
     *     // ... data to create a ActivityMetric
     *   }
     * })
     * 
     */
    create<T extends ActivityMetricCreateArgs>(args: SelectSubset<T, ActivityMetricCreateArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityMetrics.
     * @param {ActivityMetricCreateManyArgs} args - Arguments to create many ActivityMetrics.
     * @example
     * // Create many ActivityMetrics
     * const activityMetric = await prisma.activityMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityMetricCreateManyArgs>(args?: SelectSubset<T, ActivityMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityMetrics and returns the data saved in the database.
     * @param {ActivityMetricCreateManyAndReturnArgs} args - Arguments to create many ActivityMetrics.
     * @example
     * // Create many ActivityMetrics
     * const activityMetric = await prisma.activityMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityMetrics and only return the `id`
     * const activityMetricWithIdOnly = await prisma.activityMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityMetric.
     * @param {ActivityMetricDeleteArgs} args - Arguments to delete one ActivityMetric.
     * @example
     * // Delete one ActivityMetric
     * const ActivityMetric = await prisma.activityMetric.delete({
     *   where: {
     *     // ... filter to delete one ActivityMetric
     *   }
     * })
     * 
     */
    delete<T extends ActivityMetricDeleteArgs>(args: SelectSubset<T, ActivityMetricDeleteArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityMetric.
     * @param {ActivityMetricUpdateArgs} args - Arguments to update one ActivityMetric.
     * @example
     * // Update one ActivityMetric
     * const activityMetric = await prisma.activityMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityMetricUpdateArgs>(args: SelectSubset<T, ActivityMetricUpdateArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityMetrics.
     * @param {ActivityMetricDeleteManyArgs} args - Arguments to filter ActivityMetrics to delete.
     * @example
     * // Delete a few ActivityMetrics
     * const { count } = await prisma.activityMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityMetricDeleteManyArgs>(args?: SelectSubset<T, ActivityMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityMetrics
     * const activityMetric = await prisma.activityMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityMetricUpdateManyArgs>(args: SelectSubset<T, ActivityMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityMetrics and returns the data updated in the database.
     * @param {ActivityMetricUpdateManyAndReturnArgs} args - Arguments to update many ActivityMetrics.
     * @example
     * // Update many ActivityMetrics
     * const activityMetric = await prisma.activityMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityMetrics and only return the `id`
     * const activityMetricWithIdOnly = await prisma.activityMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityMetric.
     * @param {ActivityMetricUpsertArgs} args - Arguments to update or create a ActivityMetric.
     * @example
     * // Update or create a ActivityMetric
     * const activityMetric = await prisma.activityMetric.upsert({
     *   create: {
     *     // ... data to create a ActivityMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityMetric we want to update
     *   }
     * })
     */
    upsert<T extends ActivityMetricUpsertArgs>(args: SelectSubset<T, ActivityMetricUpsertArgs<ExtArgs>>): Prisma__ActivityMetricClient<$Result.GetResult<Prisma.$ActivityMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricCountArgs} args - Arguments to filter ActivityMetrics to count.
     * @example
     * // Count the number of ActivityMetrics
     * const count = await prisma.activityMetric.count({
     *   where: {
     *     // ... the filter for the ActivityMetrics we want to count
     *   }
     * })
    **/
    count<T extends ActivityMetricCountArgs>(
      args?: Subset<T, ActivityMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityMetricAggregateArgs>(args: Subset<T, ActivityMetricAggregateArgs>): Prisma.PrismaPromise<GetActivityMetricAggregateType<T>>

    /**
     * Group by ActivityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityMetricGroupByArgs['orderBy'] }
        : { orderBy?: ActivityMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityMetric model
   */
  readonly fields: ActivityMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityMetric model
   */
  interface ActivityMetricFieldRefs {
    readonly id: FieldRef<"ActivityMetric", 'String'>
    readonly player_id: FieldRef<"ActivityMetric", 'String'>
    readonly total_distance: FieldRef<"ActivityMetric", 'Float'>
    readonly hsr_distance: FieldRef<"ActivityMetric", 'Float'>
    readonly sprint_distance: FieldRef<"ActivityMetric", 'Float'>
    readonly top_speed: FieldRef<"ActivityMetric", 'Float'>
    readonly sprint_count: FieldRef<"ActivityMetric", 'Int'>
    readonly acceleration: FieldRef<"ActivityMetric", 'Float'>
    readonly deceleration: FieldRef<"ActivityMetric", 'Float'>
    readonly max_acceleration: FieldRef<"ActivityMetric", 'Float'>
    readonly max_deceleration: FieldRef<"ActivityMetric", 'Float'>
    readonly player_load: FieldRef<"ActivityMetric", 'Float'>
    readonly power_score: FieldRef<"ActivityMetric", 'Float'>
    readonly hr_max: FieldRef<"ActivityMetric", 'Int'>
    readonly time_in_red_zone: FieldRef<"ActivityMetric", 'Float'>
    readonly percent_in_red_zone: FieldRef<"ActivityMetric", 'Float'>
    readonly hr_recovery_time: FieldRef<"ActivityMetric", 'Float'>
    readonly recorded_at: FieldRef<"ActivityMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityMetric findUnique
   */
  export type ActivityMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter, which ActivityMetric to fetch.
     */
    where: ActivityMetricWhereUniqueInput
  }

  /**
   * ActivityMetric findUniqueOrThrow
   */
  export type ActivityMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter, which ActivityMetric to fetch.
     */
    where: ActivityMetricWhereUniqueInput
  }

  /**
   * ActivityMetric findFirst
   */
  export type ActivityMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter, which ActivityMetric to fetch.
     */
    where?: ActivityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityMetrics to fetch.
     */
    orderBy?: ActivityMetricOrderByWithRelationInput | ActivityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityMetrics.
     */
    cursor?: ActivityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityMetrics.
     */
    distinct?: ActivityMetricScalarFieldEnum | ActivityMetricScalarFieldEnum[]
  }

  /**
   * ActivityMetric findFirstOrThrow
   */
  export type ActivityMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter, which ActivityMetric to fetch.
     */
    where?: ActivityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityMetrics to fetch.
     */
    orderBy?: ActivityMetricOrderByWithRelationInput | ActivityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityMetrics.
     */
    cursor?: ActivityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityMetrics.
     */
    distinct?: ActivityMetricScalarFieldEnum | ActivityMetricScalarFieldEnum[]
  }

  /**
   * ActivityMetric findMany
   */
  export type ActivityMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter, which ActivityMetrics to fetch.
     */
    where?: ActivityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityMetrics to fetch.
     */
    orderBy?: ActivityMetricOrderByWithRelationInput | ActivityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityMetrics.
     */
    cursor?: ActivityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityMetrics.
     */
    skip?: number
    distinct?: ActivityMetricScalarFieldEnum | ActivityMetricScalarFieldEnum[]
  }

  /**
   * ActivityMetric create
   */
  export type ActivityMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityMetric.
     */
    data: XOR<ActivityMetricCreateInput, ActivityMetricUncheckedCreateInput>
  }

  /**
   * ActivityMetric createMany
   */
  export type ActivityMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityMetrics.
     */
    data: ActivityMetricCreateManyInput | ActivityMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityMetric createManyAndReturn
   */
  export type ActivityMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityMetrics.
     */
    data: ActivityMetricCreateManyInput | ActivityMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityMetric update
   */
  export type ActivityMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityMetric.
     */
    data: XOR<ActivityMetricUpdateInput, ActivityMetricUncheckedUpdateInput>
    /**
     * Choose, which ActivityMetric to update.
     */
    where: ActivityMetricWhereUniqueInput
  }

  /**
   * ActivityMetric updateMany
   */
  export type ActivityMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityMetrics.
     */
    data: XOR<ActivityMetricUpdateManyMutationInput, ActivityMetricUncheckedUpdateManyInput>
    /**
     * Filter which ActivityMetrics to update
     */
    where?: ActivityMetricWhereInput
    /**
     * Limit how many ActivityMetrics to update.
     */
    limit?: number
  }

  /**
   * ActivityMetric updateManyAndReturn
   */
  export type ActivityMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * The data used to update ActivityMetrics.
     */
    data: XOR<ActivityMetricUpdateManyMutationInput, ActivityMetricUncheckedUpdateManyInput>
    /**
     * Filter which ActivityMetrics to update
     */
    where?: ActivityMetricWhereInput
    /**
     * Limit how many ActivityMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityMetric upsert
   */
  export type ActivityMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityMetric to update in case it exists.
     */
    where: ActivityMetricWhereUniqueInput
    /**
     * In case the ActivityMetric found by the `where` argument doesn't exist, create a new ActivityMetric with this data.
     */
    create: XOR<ActivityMetricCreateInput, ActivityMetricUncheckedCreateInput>
    /**
     * In case the ActivityMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityMetricUpdateInput, ActivityMetricUncheckedUpdateInput>
  }

  /**
   * ActivityMetric delete
   */
  export type ActivityMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
    /**
     * Filter which ActivityMetric to delete.
     */
    where: ActivityMetricWhereUniqueInput
  }

  /**
   * ActivityMetric deleteMany
   */
  export type ActivityMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityMetrics to delete
     */
    where?: ActivityMetricWhereInput
    /**
     * Limit how many ActivityMetrics to delete.
     */
    limit?: number
  }

  /**
   * ActivityMetric without action
   */
  export type ActivityMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityMetric
     */
    select?: ActivityMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityMetric
     */
    omit?: ActivityMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityMetricInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SuperAdminScalarFieldEnum: {
    super_admin_id: 'super_admin_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password_hash: 'password_hash',
    profile_image: 'profile_image',
    created_at: 'created_at',
    updated_at: 'updated_at',
    reset_token: 'reset_token',
    reset_token_expires: 'reset_token_expires',
    login_otp: 'login_otp',
    login_otp_expires: 'login_otp_expires'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const ClubScalarFieldEnum: {
    club_id: 'club_id',
    super_admin_id: 'super_admin_id',
    club_name: 'club_name',
    address: 'address',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    sport: 'sport'
  };

  export type ClubScalarFieldEnum = (typeof ClubScalarFieldEnum)[keyof typeof ClubScalarFieldEnum]


  export const ClubAdminScalarFieldEnum: {
    admin_id: 'admin_id',
    club_id: 'club_id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    password_hash: 'password_hash',
    profile_image: 'profile_image',
    created_at: 'created_at',
    updated_at: 'updated_at',
    reset_token: 'reset_token',
    reset_token_expires: 'reset_token_expires',
    login_otp: 'login_otp',
    login_otp_expires: 'login_otp_expires'
  };

  export type ClubAdminScalarFieldEnum = (typeof ClubAdminScalarFieldEnum)[keyof typeof ClubAdminScalarFieldEnum]


  export const CoachScalarFieldEnum: {
    coach_id: 'coach_id',
    club_id: 'club_id',
    coach_name: 'coach_name',
    phone: 'phone',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    coach_image: 'coach_image',
    location: 'location',
    created_at: 'created_at',
    updated_at: 'updated_at',
    reset_token: 'reset_token',
    reset_token_expires: 'reset_token_expires',
    login_otp: 'login_otp',
    login_otp_expires: 'login_otp_expires'
  };

  export type CoachScalarFieldEnum = (typeof CoachScalarFieldEnum)[keyof typeof CoachScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    player_id: 'player_id',
    club_id: 'club_id',
    player_name: 'player_name',
    jersey_number: 'jersey_number',
    age: 'age',
    position: 'position',
    phone: 'phone',
    player_image: 'player_image',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const PodScalarFieldEnum: {
    pod_id: 'pod_id',
    serial_number: 'serial_number',
    model: 'model',
    firmware: 'firmware',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PodScalarFieldEnum = (typeof PodScalarFieldEnum)[keyof typeof PodScalarFieldEnum]


  export const PodHolderScalarFieldEnum: {
    pod_holder_id: 'pod_holder_id',
    serial_number: 'serial_number',
    model: 'model',
    created_at: 'created_at',
    updated_at: 'updated_at',
    club_id: 'club_id'
  };

  export type PodHolderScalarFieldEnum = (typeof PodHolderScalarFieldEnum)[keyof typeof PodHolderScalarFieldEnum]


  export const PodHolderAuditScalarFieldEnum: {
    audit_id: 'audit_id',
    pod_holder_id: 'pod_holder_id',
    from_club_id: 'from_club_id',
    to_club_id: 'to_club_id',
    action: 'action',
    performed_by: 'performed_by',
    created_at: 'created_at'
  };

  export type PodHolderAuditScalarFieldEnum = (typeof PodHolderAuditScalarFieldEnum)[keyof typeof PodHolderAuditScalarFieldEnum]


  export const PodAllocationScalarFieldEnum: {
    allocation_id: 'allocation_id',
    coach_id: 'coach_id',
    pod_id: 'pod_id',
    battery_level: 'battery_level',
    health_status: 'health_status',
    assigned_at: 'assigned_at'
  };

  export type PodAllocationScalarFieldEnum = (typeof PodAllocationScalarFieldEnum)[keyof typeof PodAllocationScalarFieldEnum]


  export const CoachAssignmentScalarFieldEnum: {
    assignment_id: 'assignment_id',
    coach_id: 'coach_id',
    pod_id: 'pod_id',
    pod_holder_id: 'pod_holder_id',
    player_id: 'player_id',
    assigned_at: 'assigned_at'
  };

  export type CoachAssignmentScalarFieldEnum = (typeof CoachAssignmentScalarFieldEnum)[keyof typeof CoachAssignmentScalarFieldEnum]


  export const PlayerPodScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    pod_id: 'pod_id',
    assigned_date: 'assigned_date'
  };

  export type PlayerPodScalarFieldEnum = (typeof PlayerPodScalarFieldEnum)[keyof typeof PlayerPodScalarFieldEnum]


  export const PlayerPodHolderScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    pod_holder_id: 'pod_holder_id',
    assigned_date: 'assigned_date'
  };

  export type PlayerPodHolderScalarFieldEnum = (typeof PlayerPodHolderScalarFieldEnum)[keyof typeof PlayerPodHolderScalarFieldEnum]


  export const PodStatusScalarFieldEnum: {
    status_id: 'status_id',
    pod_id: 'pod_id',
    working_status: 'working_status',
    battery_level: 'battery_level',
    last_sync: 'last_sync',
    health_status: 'health_status',
    created_at: 'created_at'
  };

  export type PodStatusScalarFieldEnum = (typeof PodStatusScalarFieldEnum)[keyof typeof PodStatusScalarFieldEnum]


  export const PodHolderStatusScalarFieldEnum: {
    status_id: 'status_id',
    pod_holder_id: 'pod_holder_id',
    battery_level: 'battery_level',
    working_status: 'working_status',
    last_sync: 'last_sync',
    created_at: 'created_at'
  };

  export type PodHolderStatusScalarFieldEnum = (typeof PodHolderStatusScalarFieldEnum)[keyof typeof PodHolderStatusScalarFieldEnum]


  export const RawDataScalarFieldEnum: {
    raw_id: 'raw_id',
    pod_id: 'pod_id',
    player_id: 'player_id',
    ts: 'ts',
    acceleration_x: 'acceleration_x',
    acceleration_y: 'acceleration_y',
    acceleration_z: 'acceleration_z',
    latitude: 'latitude',
    longitude: 'longitude',
    w: 'w',
    x: 'x',
    y: 'y',
    z: 'z',
    distance: 'distance',
    speed: 'speed',
    heart_rate: 'heart_rate',
    created_at: 'created_at'
  };

  export type RawDataScalarFieldEnum = (typeof RawDataScalarFieldEnum)[keyof typeof RawDataScalarFieldEnum]


  export const EventScalarFieldEnum: {
    event_id: 'event_id',
    club_id: 'club_id',
    event_name: 'event_name',
    event_date: 'event_date',
    location: 'location',
    event_type: 'event_type',
    created_at: 'created_at'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventParticipantScalarFieldEnum: {
    id: 'id',
    event_id: 'event_id',
    coach_id: 'coach_id',
    player_id: 'player_id'
  };

  export type EventParticipantScalarFieldEnum = (typeof EventParticipantScalarFieldEnum)[keyof typeof EventParticipantScalarFieldEnum]


  export const PaymentPlanScalarFieldEnum: {
    plan_id: 'plan_id',
    name: 'name',
    price_cents: 'price_cents',
    duration_days: 'duration_days',
    description: 'description',
    created_at: 'created_at'
  };

  export type PaymentPlanScalarFieldEnum = (typeof PaymentPlanScalarFieldEnum)[keyof typeof PaymentPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    subscription_id: 'subscription_id',
    club_id: 'club_id',
    plan_id: 'plan_id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    created_at: 'created_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    subscription_id: 'subscription_id',
    amount_cents: 'amount_cents',
    paid_at: 'paid_at',
    method: 'method',
    transaction_ref: 'transaction_ref'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ServiceRequestScalarFieldEnum: {
    request_id: 'request_id',
    club_id: 'club_id',
    requester_id: 'requester_id',
    description: 'description',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServiceRequestScalarFieldEnum = (typeof ServiceRequestScalarFieldEnum)[keyof typeof ServiceRequestScalarFieldEnum]


  export const ActivityMetricScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    total_distance: 'total_distance',
    hsr_distance: 'hsr_distance',
    sprint_distance: 'sprint_distance',
    top_speed: 'top_speed',
    sprint_count: 'sprint_count',
    acceleration: 'acceleration',
    deceleration: 'deceleration',
    max_acceleration: 'max_acceleration',
    max_deceleration: 'max_deceleration',
    player_load: 'player_load',
    power_score: 'power_score',
    hr_max: 'hr_max',
    time_in_red_zone: 'time_in_red_zone',
    percent_in_red_zone: 'percent_in_red_zone',
    hr_recovery_time: 'hr_recovery_time',
    recorded_at: 'recorded_at'
  };

  export type ActivityMetricScalarFieldEnum = (typeof ActivityMetricScalarFieldEnum)[keyof typeof ActivityMetricScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    super_admin_id?: UuidFilter<"SuperAdmin"> | string
    name?: StringNullableFilter<"SuperAdmin"> | string | null
    email?: StringFilter<"SuperAdmin"> | string
    phone?: StringNullableFilter<"SuperAdmin"> | string | null
    password_hash?: StringFilter<"SuperAdmin"> | string
    profile_image?: StringNullableFilter<"SuperAdmin"> | string | null
    created_at?: DateTimeFilter<"SuperAdmin"> | Date | string
    updated_at?: DateTimeFilter<"SuperAdmin"> | Date | string
    reset_token?: StringNullableFilter<"SuperAdmin"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"SuperAdmin"> | Date | string | null
    login_otp?: StringNullableFilter<"SuperAdmin"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"SuperAdmin"> | Date | string | null
    clubs?: ClubListRelationFilter
  }

  export type SuperAdminOrderByWithRelationInput = {
    super_admin_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    clubs?: ClubOrderByRelationAggregateInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    super_admin_id?: string
    email?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    name?: StringNullableFilter<"SuperAdmin"> | string | null
    phone?: StringNullableFilter<"SuperAdmin"> | string | null
    password_hash?: StringFilter<"SuperAdmin"> | string
    profile_image?: StringNullableFilter<"SuperAdmin"> | string | null
    created_at?: DateTimeFilter<"SuperAdmin"> | Date | string
    updated_at?: DateTimeFilter<"SuperAdmin"> | Date | string
    reset_token?: StringNullableFilter<"SuperAdmin"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"SuperAdmin"> | Date | string | null
    login_otp?: StringNullableFilter<"SuperAdmin"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"SuperAdmin"> | Date | string | null
    clubs?: ClubListRelationFilter
  }, "super_admin_id" | "email">

  export type SuperAdminOrderByWithAggregationInput = {
    super_admin_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    super_admin_id?: UuidWithAggregatesFilter<"SuperAdmin"> | string
    name?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    email?: StringWithAggregatesFilter<"SuperAdmin"> | string
    phone?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    password_hash?: StringWithAggregatesFilter<"SuperAdmin"> | string
    profile_image?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
    reset_token?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    reset_token_expires?: DateTimeNullableWithAggregatesFilter<"SuperAdmin"> | Date | string | null
    login_otp?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    login_otp_expires?: DateTimeNullableWithAggregatesFilter<"SuperAdmin"> | Date | string | null
  }

  export type ClubWhereInput = {
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    club_id?: UuidFilter<"Club"> | string
    super_admin_id?: UuidNullableFilter<"Club"> | string | null
    club_name?: StringNullableFilter<"Club"> | string | null
    address?: StringNullableFilter<"Club"> | string | null
    status?: StringNullableFilter<"Club"> | string | null
    created_at?: DateTimeFilter<"Club"> | Date | string
    updated_at?: DateTimeFilter<"Club"> | Date | string
    sport?: StringNullableFilter<"Club"> | string | null
    club_admins?: ClubAdminListRelationFilter
    super_admin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    pod_holders?: PodHolderListRelationFilter
    coaches?: CoachListRelationFilter
    events?: EventListRelationFilter
    players?: PlayerListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type ClubOrderByWithRelationInput = {
    club_id?: SortOrder
    super_admin_id?: SortOrderInput | SortOrder
    club_name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sport?: SortOrderInput | SortOrder
    club_admins?: ClubAdminOrderByRelationAggregateInput
    super_admin?: SuperAdminOrderByWithRelationInput
    pod_holders?: PodHolderOrderByRelationAggregateInput
    coaches?: CoachOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type ClubWhereUniqueInput = Prisma.AtLeast<{
    club_id?: string
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    super_admin_id?: UuidNullableFilter<"Club"> | string | null
    club_name?: StringNullableFilter<"Club"> | string | null
    address?: StringNullableFilter<"Club"> | string | null
    status?: StringNullableFilter<"Club"> | string | null
    created_at?: DateTimeFilter<"Club"> | Date | string
    updated_at?: DateTimeFilter<"Club"> | Date | string
    sport?: StringNullableFilter<"Club"> | string | null
    club_admins?: ClubAdminListRelationFilter
    super_admin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    pod_holders?: PodHolderListRelationFilter
    coaches?: CoachListRelationFilter
    events?: EventListRelationFilter
    players?: PlayerListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "club_id">

  export type ClubOrderByWithAggregationInput = {
    club_id?: SortOrder
    super_admin_id?: SortOrderInput | SortOrder
    club_name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sport?: SortOrderInput | SortOrder
    _count?: ClubCountOrderByAggregateInput
    _max?: ClubMaxOrderByAggregateInput
    _min?: ClubMinOrderByAggregateInput
  }

  export type ClubScalarWhereWithAggregatesInput = {
    AND?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    OR?: ClubScalarWhereWithAggregatesInput[]
    NOT?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    club_id?: UuidWithAggregatesFilter<"Club"> | string
    super_admin_id?: UuidNullableWithAggregatesFilter<"Club"> | string | null
    club_name?: StringNullableWithAggregatesFilter<"Club"> | string | null
    address?: StringNullableWithAggregatesFilter<"Club"> | string | null
    status?: StringNullableWithAggregatesFilter<"Club"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Club"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Club"> | Date | string
    sport?: StringNullableWithAggregatesFilter<"Club"> | string | null
  }

  export type ClubAdminWhereInput = {
    AND?: ClubAdminWhereInput | ClubAdminWhereInput[]
    OR?: ClubAdminWhereInput[]
    NOT?: ClubAdminWhereInput | ClubAdminWhereInput[]
    admin_id?: UuidFilter<"ClubAdmin"> | string
    club_id?: UuidFilter<"ClubAdmin"> | string
    name?: StringNullableFilter<"ClubAdmin"> | string | null
    phone?: StringNullableFilter<"ClubAdmin"> | string | null
    email?: StringNullableFilter<"ClubAdmin"> | string | null
    password_hash?: StringNullableFilter<"ClubAdmin"> | string | null
    profile_image?: StringNullableFilter<"ClubAdmin"> | string | null
    created_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    updated_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    reset_token?: StringNullableFilter<"ClubAdmin"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
    login_otp?: StringNullableFilter<"ClubAdmin"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
  }

  export type ClubAdminOrderByWithRelationInput = {
    admin_id?: SortOrder
    club_id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    club?: ClubOrderByWithRelationInput
  }

  export type ClubAdminWhereUniqueInput = Prisma.AtLeast<{
    admin_id?: string
    email?: string
    AND?: ClubAdminWhereInput | ClubAdminWhereInput[]
    OR?: ClubAdminWhereInput[]
    NOT?: ClubAdminWhereInput | ClubAdminWhereInput[]
    club_id?: UuidFilter<"ClubAdmin"> | string
    name?: StringNullableFilter<"ClubAdmin"> | string | null
    phone?: StringNullableFilter<"ClubAdmin"> | string | null
    password_hash?: StringNullableFilter<"ClubAdmin"> | string | null
    profile_image?: StringNullableFilter<"ClubAdmin"> | string | null
    created_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    updated_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    reset_token?: StringNullableFilter<"ClubAdmin"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
    login_otp?: StringNullableFilter<"ClubAdmin"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
  }, "admin_id" | "email">

  export type ClubAdminOrderByWithAggregationInput = {
    admin_id?: SortOrder
    club_id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    _count?: ClubAdminCountOrderByAggregateInput
    _max?: ClubAdminMaxOrderByAggregateInput
    _min?: ClubAdminMinOrderByAggregateInput
  }

  export type ClubAdminScalarWhereWithAggregatesInput = {
    AND?: ClubAdminScalarWhereWithAggregatesInput | ClubAdminScalarWhereWithAggregatesInput[]
    OR?: ClubAdminScalarWhereWithAggregatesInput[]
    NOT?: ClubAdminScalarWhereWithAggregatesInput | ClubAdminScalarWhereWithAggregatesInput[]
    admin_id?: UuidWithAggregatesFilter<"ClubAdmin"> | string
    club_id?: UuidWithAggregatesFilter<"ClubAdmin"> | string
    name?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    email?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    profile_image?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClubAdmin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClubAdmin"> | Date | string
    reset_token?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    reset_token_expires?: DateTimeNullableWithAggregatesFilter<"ClubAdmin"> | Date | string | null
    login_otp?: StringNullableWithAggregatesFilter<"ClubAdmin"> | string | null
    login_otp_expires?: DateTimeNullableWithAggregatesFilter<"ClubAdmin"> | Date | string | null
  }

  export type CoachWhereInput = {
    AND?: CoachWhereInput | CoachWhereInput[]
    OR?: CoachWhereInput[]
    NOT?: CoachWhereInput | CoachWhereInput[]
    coach_id?: UuidFilter<"Coach"> | string
    club_id?: UuidFilter<"Coach"> | string
    coach_name?: StringNullableFilter<"Coach"> | string | null
    phone?: StringNullableFilter<"Coach"> | string | null
    email?: StringNullableFilter<"Coach"> | string | null
    password_hash?: StringNullableFilter<"Coach"> | string | null
    role?: StringNullableFilter<"Coach"> | string | null
    coach_image?: StringNullableFilter<"Coach"> | string | null
    location?: StringNullableFilter<"Coach"> | string | null
    created_at?: DateTimeFilter<"Coach"> | Date | string
    updated_at?: DateTimeFilter<"Coach"> | Date | string
    reset_token?: StringNullableFilter<"Coach"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
    login_otp?: StringNullableFilter<"Coach"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
    coach_assignments?: CoachAssignmentListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    event_participants?: EventParticipantListRelationFilter
    pod_allocations?: PodAllocationListRelationFilter
  }

  export type CoachOrderByWithRelationInput = {
    coach_id?: SortOrder
    club_id?: SortOrder
    coach_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    coach_image?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    coach_assignments?: CoachAssignmentOrderByRelationAggregateInput
    club?: ClubOrderByWithRelationInput
    event_participants?: EventParticipantOrderByRelationAggregateInput
    pod_allocations?: PodAllocationOrderByRelationAggregateInput
  }

  export type CoachWhereUniqueInput = Prisma.AtLeast<{
    coach_id?: string
    email?: string
    AND?: CoachWhereInput | CoachWhereInput[]
    OR?: CoachWhereInput[]
    NOT?: CoachWhereInput | CoachWhereInput[]
    club_id?: UuidFilter<"Coach"> | string
    coach_name?: StringNullableFilter<"Coach"> | string | null
    phone?: StringNullableFilter<"Coach"> | string | null
    password_hash?: StringNullableFilter<"Coach"> | string | null
    role?: StringNullableFilter<"Coach"> | string | null
    coach_image?: StringNullableFilter<"Coach"> | string | null
    location?: StringNullableFilter<"Coach"> | string | null
    created_at?: DateTimeFilter<"Coach"> | Date | string
    updated_at?: DateTimeFilter<"Coach"> | Date | string
    reset_token?: StringNullableFilter<"Coach"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
    login_otp?: StringNullableFilter<"Coach"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
    coach_assignments?: CoachAssignmentListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    event_participants?: EventParticipantListRelationFilter
    pod_allocations?: PodAllocationListRelationFilter
  }, "coach_id" | "email">

  export type CoachOrderByWithAggregationInput = {
    coach_id?: SortOrder
    club_id?: SortOrder
    coach_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    coach_image?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    login_otp?: SortOrderInput | SortOrder
    login_otp_expires?: SortOrderInput | SortOrder
    _count?: CoachCountOrderByAggregateInput
    _max?: CoachMaxOrderByAggregateInput
    _min?: CoachMinOrderByAggregateInput
  }

  export type CoachScalarWhereWithAggregatesInput = {
    AND?: CoachScalarWhereWithAggregatesInput | CoachScalarWhereWithAggregatesInput[]
    OR?: CoachScalarWhereWithAggregatesInput[]
    NOT?: CoachScalarWhereWithAggregatesInput | CoachScalarWhereWithAggregatesInput[]
    coach_id?: UuidWithAggregatesFilter<"Coach"> | string
    club_id?: UuidWithAggregatesFilter<"Coach"> | string
    coach_name?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    email?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    role?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    coach_image?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    location?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Coach"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Coach"> | Date | string
    reset_token?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    reset_token_expires?: DateTimeNullableWithAggregatesFilter<"Coach"> | Date | string | null
    login_otp?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    login_otp_expires?: DateTimeNullableWithAggregatesFilter<"Coach"> | Date | string | null
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    player_id?: UuidFilter<"Player"> | string
    club_id?: UuidFilter<"Player"> | string
    player_name?: StringNullableFilter<"Player"> | string | null
    jersey_number?: IntNullableFilter<"Player"> | number | null
    age?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    phone?: StringNullableFilter<"Player"> | string | null
    player_image?: StringNullableFilter<"Player"> | string | null
    created_at?: DateTimeFilter<"Player"> | Date | string
    updated_at?: DateTimeFilter<"Player"> | Date | string
    activity_metrics?: ActivityMetricListRelationFilter
    coach_assignments?: CoachAssignmentListRelationFilter
    event_participants?: EventParticipantListRelationFilter
    player_pod_holders?: PlayerPodHolderListRelationFilter
    player_pods?: PlayerPodListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    raw_data?: RawDataListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    player_id?: SortOrder
    club_id?: SortOrder
    player_name?: SortOrderInput | SortOrder
    jersey_number?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    player_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    activity_metrics?: ActivityMetricOrderByRelationAggregateInput
    coach_assignments?: CoachAssignmentOrderByRelationAggregateInput
    event_participants?: EventParticipantOrderByRelationAggregateInput
    player_pod_holders?: PlayerPodHolderOrderByRelationAggregateInput
    player_pods?: PlayerPodOrderByRelationAggregateInput
    club?: ClubOrderByWithRelationInput
    raw_data?: RawDataOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    player_id?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    club_id?: UuidFilter<"Player"> | string
    player_name?: StringNullableFilter<"Player"> | string | null
    jersey_number?: IntNullableFilter<"Player"> | number | null
    age?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    phone?: StringNullableFilter<"Player"> | string | null
    player_image?: StringNullableFilter<"Player"> | string | null
    created_at?: DateTimeFilter<"Player"> | Date | string
    updated_at?: DateTimeFilter<"Player"> | Date | string
    activity_metrics?: ActivityMetricListRelationFilter
    coach_assignments?: CoachAssignmentListRelationFilter
    event_participants?: EventParticipantListRelationFilter
    player_pod_holders?: PlayerPodHolderListRelationFilter
    player_pods?: PlayerPodListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    raw_data?: RawDataListRelationFilter
  }, "player_id">

  export type PlayerOrderByWithAggregationInput = {
    player_id?: SortOrder
    club_id?: SortOrder
    player_name?: SortOrderInput | SortOrder
    jersey_number?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    player_image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    player_id?: UuidWithAggregatesFilter<"Player"> | string
    club_id?: UuidWithAggregatesFilter<"Player"> | string
    player_name?: StringNullableWithAggregatesFilter<"Player"> | string | null
    jersey_number?: IntNullableWithAggregatesFilter<"Player"> | number | null
    age?: IntNullableWithAggregatesFilter<"Player"> | number | null
    position?: StringNullableWithAggregatesFilter<"Player"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Player"> | string | null
    player_image?: StringNullableWithAggregatesFilter<"Player"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type PodWhereInput = {
    AND?: PodWhereInput | PodWhereInput[]
    OR?: PodWhereInput[]
    NOT?: PodWhereInput | PodWhereInput[]
    pod_id?: UuidFilter<"Pod"> | string
    serial_number?: StringNullableFilter<"Pod"> | string | null
    model?: StringNullableFilter<"Pod"> | string | null
    firmware?: StringNullableFilter<"Pod"> | string | null
    created_at?: DateTimeFilter<"Pod"> | Date | string
    updated_at?: DateTimeFilter<"Pod"> | Date | string
    coach_assignments?: CoachAssignmentListRelationFilter
    player_pods?: PlayerPodListRelationFilter
    pod_allocations?: PodAllocationListRelationFilter
    pod_statuses?: PodStatusListRelationFilter
    raw_data?: RawDataListRelationFilter
  }

  export type PodOrderByWithRelationInput = {
    pod_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    firmware?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    coach_assignments?: CoachAssignmentOrderByRelationAggregateInput
    player_pods?: PlayerPodOrderByRelationAggregateInput
    pod_allocations?: PodAllocationOrderByRelationAggregateInput
    pod_statuses?: PodStatusOrderByRelationAggregateInput
    raw_data?: RawDataOrderByRelationAggregateInput
  }

  export type PodWhereUniqueInput = Prisma.AtLeast<{
    pod_id?: string
    serial_number?: string
    AND?: PodWhereInput | PodWhereInput[]
    OR?: PodWhereInput[]
    NOT?: PodWhereInput | PodWhereInput[]
    model?: StringNullableFilter<"Pod"> | string | null
    firmware?: StringNullableFilter<"Pod"> | string | null
    created_at?: DateTimeFilter<"Pod"> | Date | string
    updated_at?: DateTimeFilter<"Pod"> | Date | string
    coach_assignments?: CoachAssignmentListRelationFilter
    player_pods?: PlayerPodListRelationFilter
    pod_allocations?: PodAllocationListRelationFilter
    pod_statuses?: PodStatusListRelationFilter
    raw_data?: RawDataListRelationFilter
  }, "pod_id" | "serial_number">

  export type PodOrderByWithAggregationInput = {
    pod_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    firmware?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PodCountOrderByAggregateInput
    _max?: PodMaxOrderByAggregateInput
    _min?: PodMinOrderByAggregateInput
  }

  export type PodScalarWhereWithAggregatesInput = {
    AND?: PodScalarWhereWithAggregatesInput | PodScalarWhereWithAggregatesInput[]
    OR?: PodScalarWhereWithAggregatesInput[]
    NOT?: PodScalarWhereWithAggregatesInput | PodScalarWhereWithAggregatesInput[]
    pod_id?: UuidWithAggregatesFilter<"Pod"> | string
    serial_number?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    model?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    firmware?: StringNullableWithAggregatesFilter<"Pod"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Pod"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Pod"> | Date | string
  }

  export type PodHolderWhereInput = {
    AND?: PodHolderWhereInput | PodHolderWhereInput[]
    OR?: PodHolderWhereInput[]
    NOT?: PodHolderWhereInput | PodHolderWhereInput[]
    pod_holder_id?: UuidFilter<"PodHolder"> | string
    serial_number?: StringNullableFilter<"PodHolder"> | string | null
    model?: StringNullableFilter<"PodHolder"> | string | null
    created_at?: DateTimeFilter<"PodHolder"> | Date | string
    updated_at?: DateTimeFilter<"PodHolder"> | Date | string
    club_id?: UuidNullableFilter<"PodHolder"> | string | null
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
    audits?: PodHolderAuditListRelationFilter
    coach_assignments?: CoachAssignmentListRelationFilter
    player_pod_holders?: PlayerPodHolderListRelationFilter
    pod_holder_statuses?: PodHolderStatusListRelationFilter
  }

  export type PodHolderOrderByWithRelationInput = {
    pod_holder_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club_id?: SortOrderInput | SortOrder
    club?: ClubOrderByWithRelationInput
    audits?: PodHolderAuditOrderByRelationAggregateInput
    coach_assignments?: CoachAssignmentOrderByRelationAggregateInput
    player_pod_holders?: PlayerPodHolderOrderByRelationAggregateInput
    pod_holder_statuses?: PodHolderStatusOrderByRelationAggregateInput
  }

  export type PodHolderWhereUniqueInput = Prisma.AtLeast<{
    pod_holder_id?: string
    serial_number?: string
    AND?: PodHolderWhereInput | PodHolderWhereInput[]
    OR?: PodHolderWhereInput[]
    NOT?: PodHolderWhereInput | PodHolderWhereInput[]
    model?: StringNullableFilter<"PodHolder"> | string | null
    created_at?: DateTimeFilter<"PodHolder"> | Date | string
    updated_at?: DateTimeFilter<"PodHolder"> | Date | string
    club_id?: UuidNullableFilter<"PodHolder"> | string | null
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
    audits?: PodHolderAuditListRelationFilter
    coach_assignments?: CoachAssignmentListRelationFilter
    player_pod_holders?: PlayerPodHolderListRelationFilter
    pod_holder_statuses?: PodHolderStatusListRelationFilter
  }, "pod_holder_id" | "serial_number">

  export type PodHolderOrderByWithAggregationInput = {
    pod_holder_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club_id?: SortOrderInput | SortOrder
    _count?: PodHolderCountOrderByAggregateInput
    _max?: PodHolderMaxOrderByAggregateInput
    _min?: PodHolderMinOrderByAggregateInput
  }

  export type PodHolderScalarWhereWithAggregatesInput = {
    AND?: PodHolderScalarWhereWithAggregatesInput | PodHolderScalarWhereWithAggregatesInput[]
    OR?: PodHolderScalarWhereWithAggregatesInput[]
    NOT?: PodHolderScalarWhereWithAggregatesInput | PodHolderScalarWhereWithAggregatesInput[]
    pod_holder_id?: UuidWithAggregatesFilter<"PodHolder"> | string
    serial_number?: StringNullableWithAggregatesFilter<"PodHolder"> | string | null
    model?: StringNullableWithAggregatesFilter<"PodHolder"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PodHolder"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PodHolder"> | Date | string
    club_id?: UuidNullableWithAggregatesFilter<"PodHolder"> | string | null
  }

  export type PodHolderAuditWhereInput = {
    AND?: PodHolderAuditWhereInput | PodHolderAuditWhereInput[]
    OR?: PodHolderAuditWhereInput[]
    NOT?: PodHolderAuditWhereInput | PodHolderAuditWhereInput[]
    audit_id?: UuidFilter<"PodHolderAudit"> | string
    pod_holder_id?: UuidFilter<"PodHolderAudit"> | string
    from_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    to_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    action?: StringFilter<"PodHolderAudit"> | string
    performed_by?: UuidFilter<"PodHolderAudit"> | string
    created_at?: DateTimeFilter<"PodHolderAudit"> | Date | string
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }

  export type PodHolderAuditOrderByWithRelationInput = {
    audit_id?: SortOrder
    pod_holder_id?: SortOrder
    from_club_id?: SortOrderInput | SortOrder
    to_club_id?: SortOrderInput | SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    created_at?: SortOrder
    pod_holder?: PodHolderOrderByWithRelationInput
  }

  export type PodHolderAuditWhereUniqueInput = Prisma.AtLeast<{
    audit_id?: string
    AND?: PodHolderAuditWhereInput | PodHolderAuditWhereInput[]
    OR?: PodHolderAuditWhereInput[]
    NOT?: PodHolderAuditWhereInput | PodHolderAuditWhereInput[]
    pod_holder_id?: UuidFilter<"PodHolderAudit"> | string
    from_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    to_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    action?: StringFilter<"PodHolderAudit"> | string
    performed_by?: UuidFilter<"PodHolderAudit"> | string
    created_at?: DateTimeFilter<"PodHolderAudit"> | Date | string
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }, "audit_id">

  export type PodHolderAuditOrderByWithAggregationInput = {
    audit_id?: SortOrder
    pod_holder_id?: SortOrder
    from_club_id?: SortOrderInput | SortOrder
    to_club_id?: SortOrderInput | SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    created_at?: SortOrder
    _count?: PodHolderAuditCountOrderByAggregateInput
    _max?: PodHolderAuditMaxOrderByAggregateInput
    _min?: PodHolderAuditMinOrderByAggregateInput
  }

  export type PodHolderAuditScalarWhereWithAggregatesInput = {
    AND?: PodHolderAuditScalarWhereWithAggregatesInput | PodHolderAuditScalarWhereWithAggregatesInput[]
    OR?: PodHolderAuditScalarWhereWithAggregatesInput[]
    NOT?: PodHolderAuditScalarWhereWithAggregatesInput | PodHolderAuditScalarWhereWithAggregatesInput[]
    audit_id?: UuidWithAggregatesFilter<"PodHolderAudit"> | string
    pod_holder_id?: UuidWithAggregatesFilter<"PodHolderAudit"> | string
    from_club_id?: UuidNullableWithAggregatesFilter<"PodHolderAudit"> | string | null
    to_club_id?: UuidNullableWithAggregatesFilter<"PodHolderAudit"> | string | null
    action?: StringWithAggregatesFilter<"PodHolderAudit"> | string
    performed_by?: UuidWithAggregatesFilter<"PodHolderAudit"> | string
    created_at?: DateTimeWithAggregatesFilter<"PodHolderAudit"> | Date | string
  }

  export type PodAllocationWhereInput = {
    AND?: PodAllocationWhereInput | PodAllocationWhereInput[]
    OR?: PodAllocationWhereInput[]
    NOT?: PodAllocationWhereInput | PodAllocationWhereInput[]
    allocation_id?: UuidFilter<"PodAllocation"> | string
    coach_id?: UuidNullableFilter<"PodAllocation"> | string | null
    pod_id?: UuidFilter<"PodAllocation"> | string
    battery_level?: IntNullableFilter<"PodAllocation"> | number | null
    health_status?: StringNullableFilter<"PodAllocation"> | string | null
    assigned_at?: DateTimeFilter<"PodAllocation"> | Date | string
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type PodAllocationOrderByWithRelationInput = {
    allocation_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    pod_id?: SortOrder
    battery_level?: SortOrderInput | SortOrder
    health_status?: SortOrderInput | SortOrder
    assigned_at?: SortOrder
    coach?: CoachOrderByWithRelationInput
    pod?: PodOrderByWithRelationInput
  }

  export type PodAllocationWhereUniqueInput = Prisma.AtLeast<{
    allocation_id?: string
    AND?: PodAllocationWhereInput | PodAllocationWhereInput[]
    OR?: PodAllocationWhereInput[]
    NOT?: PodAllocationWhereInput | PodAllocationWhereInput[]
    coach_id?: UuidNullableFilter<"PodAllocation"> | string | null
    pod_id?: UuidFilter<"PodAllocation"> | string
    battery_level?: IntNullableFilter<"PodAllocation"> | number | null
    health_status?: StringNullableFilter<"PodAllocation"> | string | null
    assigned_at?: DateTimeFilter<"PodAllocation"> | Date | string
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "allocation_id">

  export type PodAllocationOrderByWithAggregationInput = {
    allocation_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    pod_id?: SortOrder
    battery_level?: SortOrderInput | SortOrder
    health_status?: SortOrderInput | SortOrder
    assigned_at?: SortOrder
    _count?: PodAllocationCountOrderByAggregateInput
    _avg?: PodAllocationAvgOrderByAggregateInput
    _max?: PodAllocationMaxOrderByAggregateInput
    _min?: PodAllocationMinOrderByAggregateInput
    _sum?: PodAllocationSumOrderByAggregateInput
  }

  export type PodAllocationScalarWhereWithAggregatesInput = {
    AND?: PodAllocationScalarWhereWithAggregatesInput | PodAllocationScalarWhereWithAggregatesInput[]
    OR?: PodAllocationScalarWhereWithAggregatesInput[]
    NOT?: PodAllocationScalarWhereWithAggregatesInput | PodAllocationScalarWhereWithAggregatesInput[]
    allocation_id?: UuidWithAggregatesFilter<"PodAllocation"> | string
    coach_id?: UuidNullableWithAggregatesFilter<"PodAllocation"> | string | null
    pod_id?: UuidWithAggregatesFilter<"PodAllocation"> | string
    battery_level?: IntNullableWithAggregatesFilter<"PodAllocation"> | number | null
    health_status?: StringNullableWithAggregatesFilter<"PodAllocation"> | string | null
    assigned_at?: DateTimeWithAggregatesFilter<"PodAllocation"> | Date | string
  }

  export type CoachAssignmentWhereInput = {
    AND?: CoachAssignmentWhereInput | CoachAssignmentWhereInput[]
    OR?: CoachAssignmentWhereInput[]
    NOT?: CoachAssignmentWhereInput | CoachAssignmentWhereInput[]
    assignment_id?: UuidFilter<"CoachAssignment"> | string
    coach_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_holder_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    player_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    assigned_at?: DateTimeFilter<"CoachAssignment"> | Date | string
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    pod_holder?: XOR<PodHolderNullableScalarRelationFilter, PodHolderWhereInput> | null
    pod?: XOR<PodNullableScalarRelationFilter, PodWhereInput> | null
  }

  export type CoachAssignmentOrderByWithRelationInput = {
    assignment_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    pod_id?: SortOrderInput | SortOrder
    pod_holder_id?: SortOrderInput | SortOrder
    player_id?: SortOrderInput | SortOrder
    assigned_at?: SortOrder
    coach?: CoachOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
    pod_holder?: PodHolderOrderByWithRelationInput
    pod?: PodOrderByWithRelationInput
  }

  export type CoachAssignmentWhereUniqueInput = Prisma.AtLeast<{
    assignment_id?: string
    AND?: CoachAssignmentWhereInput | CoachAssignmentWhereInput[]
    OR?: CoachAssignmentWhereInput[]
    NOT?: CoachAssignmentWhereInput | CoachAssignmentWhereInput[]
    coach_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_holder_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    player_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    assigned_at?: DateTimeFilter<"CoachAssignment"> | Date | string
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    pod_holder?: XOR<PodHolderNullableScalarRelationFilter, PodHolderWhereInput> | null
    pod?: XOR<PodNullableScalarRelationFilter, PodWhereInput> | null
  }, "assignment_id">

  export type CoachAssignmentOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    pod_id?: SortOrderInput | SortOrder
    pod_holder_id?: SortOrderInput | SortOrder
    player_id?: SortOrderInput | SortOrder
    assigned_at?: SortOrder
    _count?: CoachAssignmentCountOrderByAggregateInput
    _max?: CoachAssignmentMaxOrderByAggregateInput
    _min?: CoachAssignmentMinOrderByAggregateInput
  }

  export type CoachAssignmentScalarWhereWithAggregatesInput = {
    AND?: CoachAssignmentScalarWhereWithAggregatesInput | CoachAssignmentScalarWhereWithAggregatesInput[]
    OR?: CoachAssignmentScalarWhereWithAggregatesInput[]
    NOT?: CoachAssignmentScalarWhereWithAggregatesInput | CoachAssignmentScalarWhereWithAggregatesInput[]
    assignment_id?: UuidWithAggregatesFilter<"CoachAssignment"> | string
    coach_id?: UuidNullableWithAggregatesFilter<"CoachAssignment"> | string | null
    pod_id?: UuidNullableWithAggregatesFilter<"CoachAssignment"> | string | null
    pod_holder_id?: UuidNullableWithAggregatesFilter<"CoachAssignment"> | string | null
    player_id?: UuidNullableWithAggregatesFilter<"CoachAssignment"> | string | null
    assigned_at?: DateTimeWithAggregatesFilter<"CoachAssignment"> | Date | string
  }

  export type PlayerPodWhereInput = {
    AND?: PlayerPodWhereInput | PlayerPodWhereInput[]
    OR?: PlayerPodWhereInput[]
    NOT?: PlayerPodWhereInput | PlayerPodWhereInput[]
    id?: UuidFilter<"PlayerPod"> | string
    player_id?: UuidFilter<"PlayerPod"> | string
    pod_id?: UuidFilter<"PlayerPod"> | string
    assigned_date?: DateTimeFilter<"PlayerPod"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type PlayerPodOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_id?: SortOrder
    assigned_date?: SortOrder
    player?: PlayerOrderByWithRelationInput
    pod?: PodOrderByWithRelationInput
  }

  export type PlayerPodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerPodWhereInput | PlayerPodWhereInput[]
    OR?: PlayerPodWhereInput[]
    NOT?: PlayerPodWhereInput | PlayerPodWhereInput[]
    player_id?: UuidFilter<"PlayerPod"> | string
    pod_id?: UuidFilter<"PlayerPod"> | string
    assigned_date?: DateTimeFilter<"PlayerPod"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "id">

  export type PlayerPodOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_id?: SortOrder
    assigned_date?: SortOrder
    _count?: PlayerPodCountOrderByAggregateInput
    _max?: PlayerPodMaxOrderByAggregateInput
    _min?: PlayerPodMinOrderByAggregateInput
  }

  export type PlayerPodScalarWhereWithAggregatesInput = {
    AND?: PlayerPodScalarWhereWithAggregatesInput | PlayerPodScalarWhereWithAggregatesInput[]
    OR?: PlayerPodScalarWhereWithAggregatesInput[]
    NOT?: PlayerPodScalarWhereWithAggregatesInput | PlayerPodScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlayerPod"> | string
    player_id?: UuidWithAggregatesFilter<"PlayerPod"> | string
    pod_id?: UuidWithAggregatesFilter<"PlayerPod"> | string
    assigned_date?: DateTimeWithAggregatesFilter<"PlayerPod"> | Date | string
  }

  export type PlayerPodHolderWhereInput = {
    AND?: PlayerPodHolderWhereInput | PlayerPodHolderWhereInput[]
    OR?: PlayerPodHolderWhereInput[]
    NOT?: PlayerPodHolderWhereInput | PlayerPodHolderWhereInput[]
    id?: UuidFilter<"PlayerPodHolder"> | string
    player_id?: UuidFilter<"PlayerPodHolder"> | string
    pod_holder_id?: UuidFilter<"PlayerPodHolder"> | string
    assigned_date?: DateTimeFilter<"PlayerPodHolder"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }

  export type PlayerPodHolderOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_holder_id?: SortOrder
    assigned_date?: SortOrder
    player?: PlayerOrderByWithRelationInput
    pod_holder?: PodHolderOrderByWithRelationInput
  }

  export type PlayerPodHolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerPodHolderWhereInput | PlayerPodHolderWhereInput[]
    OR?: PlayerPodHolderWhereInput[]
    NOT?: PlayerPodHolderWhereInput | PlayerPodHolderWhereInput[]
    player_id?: UuidFilter<"PlayerPodHolder"> | string
    pod_holder_id?: UuidFilter<"PlayerPodHolder"> | string
    assigned_date?: DateTimeFilter<"PlayerPodHolder"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }, "id">

  export type PlayerPodHolderOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_holder_id?: SortOrder
    assigned_date?: SortOrder
    _count?: PlayerPodHolderCountOrderByAggregateInput
    _max?: PlayerPodHolderMaxOrderByAggregateInput
    _min?: PlayerPodHolderMinOrderByAggregateInput
  }

  export type PlayerPodHolderScalarWhereWithAggregatesInput = {
    AND?: PlayerPodHolderScalarWhereWithAggregatesInput | PlayerPodHolderScalarWhereWithAggregatesInput[]
    OR?: PlayerPodHolderScalarWhereWithAggregatesInput[]
    NOT?: PlayerPodHolderScalarWhereWithAggregatesInput | PlayerPodHolderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlayerPodHolder"> | string
    player_id?: UuidWithAggregatesFilter<"PlayerPodHolder"> | string
    pod_holder_id?: UuidWithAggregatesFilter<"PlayerPodHolder"> | string
    assigned_date?: DateTimeWithAggregatesFilter<"PlayerPodHolder"> | Date | string
  }

  export type PodStatusWhereInput = {
    AND?: PodStatusWhereInput | PodStatusWhereInput[]
    OR?: PodStatusWhereInput[]
    NOT?: PodStatusWhereInput | PodStatusWhereInput[]
    status_id?: UuidFilter<"PodStatus"> | string
    pod_id?: UuidFilter<"PodStatus"> | string
    working_status?: StringNullableFilter<"PodStatus"> | string | null
    battery_level?: IntNullableFilter<"PodStatus"> | number | null
    last_sync?: DateTimeNullableFilter<"PodStatus"> | Date | string | null
    health_status?: StringNullableFilter<"PodStatus"> | string | null
    created_at?: DateTimeFilter<"PodStatus"> | Date | string
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type PodStatusOrderByWithRelationInput = {
    status_id?: SortOrder
    pod_id?: SortOrder
    working_status?: SortOrderInput | SortOrder
    battery_level?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    health_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    pod?: PodOrderByWithRelationInput
  }

  export type PodStatusWhereUniqueInput = Prisma.AtLeast<{
    status_id?: string
    AND?: PodStatusWhereInput | PodStatusWhereInput[]
    OR?: PodStatusWhereInput[]
    NOT?: PodStatusWhereInput | PodStatusWhereInput[]
    pod_id?: UuidFilter<"PodStatus"> | string
    working_status?: StringNullableFilter<"PodStatus"> | string | null
    battery_level?: IntNullableFilter<"PodStatus"> | number | null
    last_sync?: DateTimeNullableFilter<"PodStatus"> | Date | string | null
    health_status?: StringNullableFilter<"PodStatus"> | string | null
    created_at?: DateTimeFilter<"PodStatus"> | Date | string
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "status_id">

  export type PodStatusOrderByWithAggregationInput = {
    status_id?: SortOrder
    pod_id?: SortOrder
    working_status?: SortOrderInput | SortOrder
    battery_level?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    health_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PodStatusCountOrderByAggregateInput
    _avg?: PodStatusAvgOrderByAggregateInput
    _max?: PodStatusMaxOrderByAggregateInput
    _min?: PodStatusMinOrderByAggregateInput
    _sum?: PodStatusSumOrderByAggregateInput
  }

  export type PodStatusScalarWhereWithAggregatesInput = {
    AND?: PodStatusScalarWhereWithAggregatesInput | PodStatusScalarWhereWithAggregatesInput[]
    OR?: PodStatusScalarWhereWithAggregatesInput[]
    NOT?: PodStatusScalarWhereWithAggregatesInput | PodStatusScalarWhereWithAggregatesInput[]
    status_id?: UuidWithAggregatesFilter<"PodStatus"> | string
    pod_id?: UuidWithAggregatesFilter<"PodStatus"> | string
    working_status?: StringNullableWithAggregatesFilter<"PodStatus"> | string | null
    battery_level?: IntNullableWithAggregatesFilter<"PodStatus"> | number | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"PodStatus"> | Date | string | null
    health_status?: StringNullableWithAggregatesFilter<"PodStatus"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PodStatus"> | Date | string
  }

  export type PodHolderStatusWhereInput = {
    AND?: PodHolderStatusWhereInput | PodHolderStatusWhereInput[]
    OR?: PodHolderStatusWhereInput[]
    NOT?: PodHolderStatusWhereInput | PodHolderStatusWhereInput[]
    status_id?: UuidFilter<"PodHolderStatus"> | string
    pod_holder_id?: UuidFilter<"PodHolderStatus"> | string
    battery_level?: IntNullableFilter<"PodHolderStatus"> | number | null
    working_status?: StringNullableFilter<"PodHolderStatus"> | string | null
    last_sync?: DateTimeNullableFilter<"PodHolderStatus"> | Date | string | null
    created_at?: DateTimeFilter<"PodHolderStatus"> | Date | string
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }

  export type PodHolderStatusOrderByWithRelationInput = {
    status_id?: SortOrder
    pod_holder_id?: SortOrder
    battery_level?: SortOrderInput | SortOrder
    working_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    created_at?: SortOrder
    pod_holder?: PodHolderOrderByWithRelationInput
  }

  export type PodHolderStatusWhereUniqueInput = Prisma.AtLeast<{
    status_id?: string
    AND?: PodHolderStatusWhereInput | PodHolderStatusWhereInput[]
    OR?: PodHolderStatusWhereInput[]
    NOT?: PodHolderStatusWhereInput | PodHolderStatusWhereInput[]
    pod_holder_id?: UuidFilter<"PodHolderStatus"> | string
    battery_level?: IntNullableFilter<"PodHolderStatus"> | number | null
    working_status?: StringNullableFilter<"PodHolderStatus"> | string | null
    last_sync?: DateTimeNullableFilter<"PodHolderStatus"> | Date | string | null
    created_at?: DateTimeFilter<"PodHolderStatus"> | Date | string
    pod_holder?: XOR<PodHolderScalarRelationFilter, PodHolderWhereInput>
  }, "status_id">

  export type PodHolderStatusOrderByWithAggregationInput = {
    status_id?: SortOrder
    pod_holder_id?: SortOrder
    battery_level?: SortOrderInput | SortOrder
    working_status?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PodHolderStatusCountOrderByAggregateInput
    _avg?: PodHolderStatusAvgOrderByAggregateInput
    _max?: PodHolderStatusMaxOrderByAggregateInput
    _min?: PodHolderStatusMinOrderByAggregateInput
    _sum?: PodHolderStatusSumOrderByAggregateInput
  }

  export type PodHolderStatusScalarWhereWithAggregatesInput = {
    AND?: PodHolderStatusScalarWhereWithAggregatesInput | PodHolderStatusScalarWhereWithAggregatesInput[]
    OR?: PodHolderStatusScalarWhereWithAggregatesInput[]
    NOT?: PodHolderStatusScalarWhereWithAggregatesInput | PodHolderStatusScalarWhereWithAggregatesInput[]
    status_id?: UuidWithAggregatesFilter<"PodHolderStatus"> | string
    pod_holder_id?: UuidWithAggregatesFilter<"PodHolderStatus"> | string
    battery_level?: IntNullableWithAggregatesFilter<"PodHolderStatus"> | number | null
    working_status?: StringNullableWithAggregatesFilter<"PodHolderStatus"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"PodHolderStatus"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"PodHolderStatus"> | Date | string
  }

  export type RawDataWhereInput = {
    AND?: RawDataWhereInput | RawDataWhereInput[]
    OR?: RawDataWhereInput[]
    NOT?: RawDataWhereInput | RawDataWhereInput[]
    raw_id?: UuidFilter<"RawData"> | string
    pod_id?: UuidFilter<"RawData"> | string
    player_id?: UuidNullableFilter<"RawData"> | string | null
    ts?: DateTimeNullableFilter<"RawData"> | Date | string | null
    acceleration_x?: FloatNullableFilter<"RawData"> | number | null
    acceleration_y?: FloatNullableFilter<"RawData"> | number | null
    acceleration_z?: FloatNullableFilter<"RawData"> | number | null
    latitude?: FloatNullableFilter<"RawData"> | number | null
    longitude?: FloatNullableFilter<"RawData"> | number | null
    w?: FloatNullableFilter<"RawData"> | number | null
    x?: FloatNullableFilter<"RawData"> | number | null
    y?: FloatNullableFilter<"RawData"> | number | null
    z?: FloatNullableFilter<"RawData"> | number | null
    distance?: FloatNullableFilter<"RawData"> | number | null
    speed?: FloatNullableFilter<"RawData"> | number | null
    heart_rate?: IntNullableFilter<"RawData"> | number | null
    created_at?: DateTimeFilter<"RawData"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }

  export type RawDataOrderByWithRelationInput = {
    raw_id?: SortOrder
    pod_id?: SortOrder
    player_id?: SortOrderInput | SortOrder
    ts?: SortOrderInput | SortOrder
    acceleration_x?: SortOrderInput | SortOrder
    acceleration_y?: SortOrderInput | SortOrder
    acceleration_z?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    w?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    heart_rate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    player?: PlayerOrderByWithRelationInput
    pod?: PodOrderByWithRelationInput
  }

  export type RawDataWhereUniqueInput = Prisma.AtLeast<{
    raw_id?: string
    AND?: RawDataWhereInput | RawDataWhereInput[]
    OR?: RawDataWhereInput[]
    NOT?: RawDataWhereInput | RawDataWhereInput[]
    pod_id?: UuidFilter<"RawData"> | string
    player_id?: UuidNullableFilter<"RawData"> | string | null
    ts?: DateTimeNullableFilter<"RawData"> | Date | string | null
    acceleration_x?: FloatNullableFilter<"RawData"> | number | null
    acceleration_y?: FloatNullableFilter<"RawData"> | number | null
    acceleration_z?: FloatNullableFilter<"RawData"> | number | null
    latitude?: FloatNullableFilter<"RawData"> | number | null
    longitude?: FloatNullableFilter<"RawData"> | number | null
    w?: FloatNullableFilter<"RawData"> | number | null
    x?: FloatNullableFilter<"RawData"> | number | null
    y?: FloatNullableFilter<"RawData"> | number | null
    z?: FloatNullableFilter<"RawData"> | number | null
    distance?: FloatNullableFilter<"RawData"> | number | null
    speed?: FloatNullableFilter<"RawData"> | number | null
    heart_rate?: IntNullableFilter<"RawData"> | number | null
    created_at?: DateTimeFilter<"RawData"> | Date | string
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
    pod?: XOR<PodScalarRelationFilter, PodWhereInput>
  }, "raw_id">

  export type RawDataOrderByWithAggregationInput = {
    raw_id?: SortOrder
    pod_id?: SortOrder
    player_id?: SortOrderInput | SortOrder
    ts?: SortOrderInput | SortOrder
    acceleration_x?: SortOrderInput | SortOrder
    acceleration_y?: SortOrderInput | SortOrder
    acceleration_z?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    w?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    heart_rate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: RawDataCountOrderByAggregateInput
    _avg?: RawDataAvgOrderByAggregateInput
    _max?: RawDataMaxOrderByAggregateInput
    _min?: RawDataMinOrderByAggregateInput
    _sum?: RawDataSumOrderByAggregateInput
  }

  export type RawDataScalarWhereWithAggregatesInput = {
    AND?: RawDataScalarWhereWithAggregatesInput | RawDataScalarWhereWithAggregatesInput[]
    OR?: RawDataScalarWhereWithAggregatesInput[]
    NOT?: RawDataScalarWhereWithAggregatesInput | RawDataScalarWhereWithAggregatesInput[]
    raw_id?: UuidWithAggregatesFilter<"RawData"> | string
    pod_id?: UuidWithAggregatesFilter<"RawData"> | string
    player_id?: UuidNullableWithAggregatesFilter<"RawData"> | string | null
    ts?: DateTimeNullableWithAggregatesFilter<"RawData"> | Date | string | null
    acceleration_x?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    acceleration_y?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    acceleration_z?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    w?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    x?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    y?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    z?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    speed?: FloatNullableWithAggregatesFilter<"RawData"> | number | null
    heart_rate?: IntNullableWithAggregatesFilter<"RawData"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"RawData"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    event_id?: UuidFilter<"Event"> | string
    club_id?: UuidFilter<"Event"> | string
    event_name?: StringNullableFilter<"Event"> | string | null
    event_date?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    event_type?: StringNullableFilter<"Event"> | string | null
    created_at?: DateTimeFilter<"Event"> | Date | string
    event_participants?: EventParticipantListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    event_id?: SortOrder
    club_id?: SortOrder
    event_name?: SortOrderInput | SortOrder
    event_date?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    event_participants?: EventParticipantOrderByRelationAggregateInput
    club?: ClubOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    event_id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    club_id?: UuidFilter<"Event"> | string
    event_name?: StringNullableFilter<"Event"> | string | null
    event_date?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    event_type?: StringNullableFilter<"Event"> | string | null
    created_at?: DateTimeFilter<"Event"> | Date | string
    event_participants?: EventParticipantListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
  }, "event_id">

  export type EventOrderByWithAggregationInput = {
    event_id?: SortOrder
    club_id?: SortOrder
    event_name?: SortOrderInput | SortOrder
    event_date?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    event_id?: UuidWithAggregatesFilter<"Event"> | string
    club_id?: UuidWithAggregatesFilter<"Event"> | string
    event_name?: StringNullableWithAggregatesFilter<"Event"> | string | null
    event_date?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    event_type?: StringNullableWithAggregatesFilter<"Event"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventParticipantWhereInput = {
    AND?: EventParticipantWhereInput | EventParticipantWhereInput[]
    OR?: EventParticipantWhereInput[]
    NOT?: EventParticipantWhereInput | EventParticipantWhereInput[]
    id?: UuidFilter<"EventParticipant"> | string
    event_id?: UuidFilter<"EventParticipant"> | string
    coach_id?: UuidNullableFilter<"EventParticipant"> | string | null
    player_id?: UuidNullableFilter<"EventParticipant"> | string | null
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type EventParticipantOrderByWithRelationInput = {
    id?: SortOrder
    event_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    player_id?: SortOrderInput | SortOrder
    coach?: CoachOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type EventParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventParticipantWhereInput | EventParticipantWhereInput[]
    OR?: EventParticipantWhereInput[]
    NOT?: EventParticipantWhereInput | EventParticipantWhereInput[]
    event_id?: UuidFilter<"EventParticipant"> | string
    coach_id?: UuidNullableFilter<"EventParticipant"> | string | null
    player_id?: UuidNullableFilter<"EventParticipant"> | string | null
    coach?: XOR<CoachNullableScalarRelationFilter, CoachWhereInput> | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id">

  export type EventParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    event_id?: SortOrder
    coach_id?: SortOrderInput | SortOrder
    player_id?: SortOrderInput | SortOrder
    _count?: EventParticipantCountOrderByAggregateInput
    _max?: EventParticipantMaxOrderByAggregateInput
    _min?: EventParticipantMinOrderByAggregateInput
  }

  export type EventParticipantScalarWhereWithAggregatesInput = {
    AND?: EventParticipantScalarWhereWithAggregatesInput | EventParticipantScalarWhereWithAggregatesInput[]
    OR?: EventParticipantScalarWhereWithAggregatesInput[]
    NOT?: EventParticipantScalarWhereWithAggregatesInput | EventParticipantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventParticipant"> | string
    event_id?: UuidWithAggregatesFilter<"EventParticipant"> | string
    coach_id?: UuidNullableWithAggregatesFilter<"EventParticipant"> | string | null
    player_id?: UuidNullableWithAggregatesFilter<"EventParticipant"> | string | null
  }

  export type PaymentPlanWhereInput = {
    AND?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    OR?: PaymentPlanWhereInput[]
    NOT?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    plan_id?: UuidFilter<"PaymentPlan"> | string
    name?: StringNullableFilter<"PaymentPlan"> | string | null
    price_cents?: IntNullableFilter<"PaymentPlan"> | number | null
    duration_days?: IntNullableFilter<"PaymentPlan"> | number | null
    description?: StringNullableFilter<"PaymentPlan"> | string | null
    created_at?: DateTimeFilter<"PaymentPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PaymentPlanOrderByWithRelationInput = {
    plan_id?: SortOrder
    name?: SortOrderInput | SortOrder
    price_cents?: SortOrderInput | SortOrder
    duration_days?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PaymentPlanWhereUniqueInput = Prisma.AtLeast<{
    plan_id?: string
    AND?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    OR?: PaymentPlanWhereInput[]
    NOT?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    name?: StringNullableFilter<"PaymentPlan"> | string | null
    price_cents?: IntNullableFilter<"PaymentPlan"> | number | null
    duration_days?: IntNullableFilter<"PaymentPlan"> | number | null
    description?: StringNullableFilter<"PaymentPlan"> | string | null
    created_at?: DateTimeFilter<"PaymentPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "plan_id">

  export type PaymentPlanOrderByWithAggregationInput = {
    plan_id?: SortOrder
    name?: SortOrderInput | SortOrder
    price_cents?: SortOrderInput | SortOrder
    duration_days?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PaymentPlanCountOrderByAggregateInput
    _avg?: PaymentPlanAvgOrderByAggregateInput
    _max?: PaymentPlanMaxOrderByAggregateInput
    _min?: PaymentPlanMinOrderByAggregateInput
    _sum?: PaymentPlanSumOrderByAggregateInput
  }

  export type PaymentPlanScalarWhereWithAggregatesInput = {
    AND?: PaymentPlanScalarWhereWithAggregatesInput | PaymentPlanScalarWhereWithAggregatesInput[]
    OR?: PaymentPlanScalarWhereWithAggregatesInput[]
    NOT?: PaymentPlanScalarWhereWithAggregatesInput | PaymentPlanScalarWhereWithAggregatesInput[]
    plan_id?: UuidWithAggregatesFilter<"PaymentPlan"> | string
    name?: StringNullableWithAggregatesFilter<"PaymentPlan"> | string | null
    price_cents?: IntNullableWithAggregatesFilter<"PaymentPlan"> | number | null
    duration_days?: IntNullableWithAggregatesFilter<"PaymentPlan"> | number | null
    description?: StringNullableWithAggregatesFilter<"PaymentPlan"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PaymentPlan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    subscription_id?: UuidFilter<"Subscription"> | string
    club_id?: UuidFilter<"Subscription"> | string
    plan_id?: UuidNullableFilter<"Subscription"> | string | null
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringNullableFilter<"Subscription"> | string | null
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    payments?: PaymentListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    plan?: XOR<PaymentPlanNullableScalarRelationFilter, PaymentPlanWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    subscription_id?: SortOrder
    club_id?: SortOrder
    plan_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    payments?: PaymentOrderByRelationAggregateInput
    club?: ClubOrderByWithRelationInput
    plan?: PaymentPlanOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    subscription_id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    club_id?: UuidFilter<"Subscription"> | string
    plan_id?: UuidNullableFilter<"Subscription"> | string | null
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringNullableFilter<"Subscription"> | string | null
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    payments?: PaymentListRelationFilter
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    plan?: XOR<PaymentPlanNullableScalarRelationFilter, PaymentPlanWhereInput> | null
  }, "subscription_id">

  export type SubscriptionOrderByWithAggregationInput = {
    subscription_id?: SortOrder
    club_id?: SortOrder
    plan_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    subscription_id?: UuidWithAggregatesFilter<"Subscription"> | string
    club_id?: UuidWithAggregatesFilter<"Subscription"> | string
    plan_id?: UuidNullableWithAggregatesFilter<"Subscription"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    payment_id?: UuidFilter<"Payment"> | string
    subscription_id?: UuidFilter<"Payment"> | string
    amount_cents?: IntNullableFilter<"Payment"> | number | null
    paid_at?: DateTimeFilter<"Payment"> | Date | string
    method?: StringNullableFilter<"Payment"> | string | null
    transaction_ref?: StringNullableFilter<"Payment"> | string | null
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    subscription_id?: SortOrder
    amount_cents?: SortOrderInput | SortOrder
    paid_at?: SortOrder
    method?: SortOrderInput | SortOrder
    transaction_ref?: SortOrderInput | SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: string
    transaction_ref?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    subscription_id?: UuidFilter<"Payment"> | string
    amount_cents?: IntNullableFilter<"Payment"> | number | null
    paid_at?: DateTimeFilter<"Payment"> | Date | string
    method?: StringNullableFilter<"Payment"> | string | null
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "payment_id" | "transaction_ref">

  export type PaymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    subscription_id?: SortOrder
    amount_cents?: SortOrderInput | SortOrder
    paid_at?: SortOrder
    method?: SortOrderInput | SortOrder
    transaction_ref?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    payment_id?: UuidWithAggregatesFilter<"Payment"> | string
    subscription_id?: UuidWithAggregatesFilter<"Payment"> | string
    amount_cents?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    paid_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    method?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transaction_ref?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type ServiceRequestWhereInput = {
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    request_id?: UuidFilter<"ServiceRequest"> | string
    club_id?: UuidNullableFilter<"ServiceRequest"> | string | null
    requester_id?: StringNullableFilter<"ServiceRequest"> | string | null
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: StringNullableFilter<"ServiceRequest"> | string | null
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
  }

  export type ServiceRequestOrderByWithRelationInput = {
    request_id?: SortOrder
    club_id?: SortOrderInput | SortOrder
    requester_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club?: ClubOrderByWithRelationInput
  }

  export type ServiceRequestWhereUniqueInput = Prisma.AtLeast<{
    request_id?: string
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    club_id?: UuidNullableFilter<"ServiceRequest"> | string | null
    requester_id?: StringNullableFilter<"ServiceRequest"> | string | null
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: StringNullableFilter<"ServiceRequest"> | string | null
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
  }, "request_id">

  export type ServiceRequestOrderByWithAggregationInput = {
    request_id?: SortOrder
    club_id?: SortOrderInput | SortOrder
    requester_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ServiceRequestCountOrderByAggregateInput
    _max?: ServiceRequestMaxOrderByAggregateInput
    _min?: ServiceRequestMinOrderByAggregateInput
  }

  export type ServiceRequestScalarWhereWithAggregatesInput = {
    AND?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    OR?: ServiceRequestScalarWhereWithAggregatesInput[]
    NOT?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    request_id?: UuidWithAggregatesFilter<"ServiceRequest"> | string
    club_id?: UuidNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    requester_id?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    description?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    status?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
  }

  export type ActivityMetricWhereInput = {
    AND?: ActivityMetricWhereInput | ActivityMetricWhereInput[]
    OR?: ActivityMetricWhereInput[]
    NOT?: ActivityMetricWhereInput | ActivityMetricWhereInput[]
    id?: UuidFilter<"ActivityMetric"> | string
    player_id?: UuidFilter<"ActivityMetric"> | string
    total_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    hsr_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    top_speed?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_count?: IntNullableFilter<"ActivityMetric"> | number | null
    acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    player_load?: FloatNullableFilter<"ActivityMetric"> | number | null
    power_score?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_max?: IntNullableFilter<"ActivityMetric"> | number | null
    time_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    percent_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_recovery_time?: FloatNullableFilter<"ActivityMetric"> | number | null
    recorded_at?: DateTimeFilter<"ActivityMetric"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type ActivityMetricOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    total_distance?: SortOrderInput | SortOrder
    hsr_distance?: SortOrderInput | SortOrder
    sprint_distance?: SortOrderInput | SortOrder
    top_speed?: SortOrderInput | SortOrder
    sprint_count?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    deceleration?: SortOrderInput | SortOrder
    max_acceleration?: SortOrderInput | SortOrder
    max_deceleration?: SortOrderInput | SortOrder
    player_load?: SortOrderInput | SortOrder
    power_score?: SortOrderInput | SortOrder
    hr_max?: SortOrderInput | SortOrder
    time_in_red_zone?: SortOrderInput | SortOrder
    percent_in_red_zone?: SortOrderInput | SortOrder
    hr_recovery_time?: SortOrderInput | SortOrder
    recorded_at?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type ActivityMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityMetricWhereInput | ActivityMetricWhereInput[]
    OR?: ActivityMetricWhereInput[]
    NOT?: ActivityMetricWhereInput | ActivityMetricWhereInput[]
    player_id?: UuidFilter<"ActivityMetric"> | string
    total_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    hsr_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    top_speed?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_count?: IntNullableFilter<"ActivityMetric"> | number | null
    acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    player_load?: FloatNullableFilter<"ActivityMetric"> | number | null
    power_score?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_max?: IntNullableFilter<"ActivityMetric"> | number | null
    time_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    percent_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_recovery_time?: FloatNullableFilter<"ActivityMetric"> | number | null
    recorded_at?: DateTimeFilter<"ActivityMetric"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type ActivityMetricOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    total_distance?: SortOrderInput | SortOrder
    hsr_distance?: SortOrderInput | SortOrder
    sprint_distance?: SortOrderInput | SortOrder
    top_speed?: SortOrderInput | SortOrder
    sprint_count?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    deceleration?: SortOrderInput | SortOrder
    max_acceleration?: SortOrderInput | SortOrder
    max_deceleration?: SortOrderInput | SortOrder
    player_load?: SortOrderInput | SortOrder
    power_score?: SortOrderInput | SortOrder
    hr_max?: SortOrderInput | SortOrder
    time_in_red_zone?: SortOrderInput | SortOrder
    percent_in_red_zone?: SortOrderInput | SortOrder
    hr_recovery_time?: SortOrderInput | SortOrder
    recorded_at?: SortOrder
    _count?: ActivityMetricCountOrderByAggregateInput
    _avg?: ActivityMetricAvgOrderByAggregateInput
    _max?: ActivityMetricMaxOrderByAggregateInput
    _min?: ActivityMetricMinOrderByAggregateInput
    _sum?: ActivityMetricSumOrderByAggregateInput
  }

  export type ActivityMetricScalarWhereWithAggregatesInput = {
    AND?: ActivityMetricScalarWhereWithAggregatesInput | ActivityMetricScalarWhereWithAggregatesInput[]
    OR?: ActivityMetricScalarWhereWithAggregatesInput[]
    NOT?: ActivityMetricScalarWhereWithAggregatesInput | ActivityMetricScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ActivityMetric"> | string
    player_id?: UuidWithAggregatesFilter<"ActivityMetric"> | string
    total_distance?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    hsr_distance?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    sprint_distance?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    top_speed?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    sprint_count?: IntNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    acceleration?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    deceleration?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    max_acceleration?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    max_deceleration?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    player_load?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    power_score?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    hr_max?: IntNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    time_in_red_zone?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    percent_in_red_zone?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    hr_recovery_time?: FloatNullableWithAggregatesFilter<"ActivityMetric"> | number | null
    recorded_at?: DateTimeWithAggregatesFilter<"ActivityMetric"> | Date | string
  }

  export type SuperAdminCreateInput = {
    super_admin_id?: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    clubs?: ClubCreateNestedManyWithoutSuper_adminInput
  }

  export type SuperAdminUncheckedCreateInput = {
    super_admin_id?: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    clubs?: ClubUncheckedCreateNestedManyWithoutSuper_adminInput
  }

  export type SuperAdminUpdateInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubs?: ClubUpdateManyWithoutSuper_adminNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clubs?: ClubUncheckedUpdateManyWithoutSuper_adminNestedInput
  }

  export type SuperAdminCreateManyInput = {
    super_admin_id?: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type SuperAdminUpdateManyMutationInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubCreateInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubUpdateInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubCreateManyInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
  }

  export type ClubUpdateManyMutationInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClubUncheckedUpdateManyInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClubAdminCreateInput = {
    admin_id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    club: ClubCreateNestedOneWithoutClub_adminsInput
  }

  export type ClubAdminUncheckedCreateInput = {
    admin_id?: string
    club_id: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type ClubAdminUpdateInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    club?: ClubUpdateOneRequiredWithoutClub_adminsNestedInput
  }

  export type ClubAdminUncheckedUpdateInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubAdminCreateManyInput = {
    admin_id?: string
    club_id: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type ClubAdminUpdateManyMutationInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubAdminUncheckedUpdateManyInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoachCreateInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutCoachInput
    club: ClubCreateNestedOneWithoutCoachesInput
    event_participants?: EventParticipantCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateInput = {
    coach_id?: string
    club_id: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutCoachInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachUpdateInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUpdateManyWithoutCoachNestedInput
    club?: ClubUpdateOneRequiredWithoutCoachesNestedInput
    event_participants?: EventParticipantUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutCoachNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachCreateManyInput = {
    coach_id?: string
    club_id: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type CoachUpdateManyMutationInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoachUncheckedUpdateManyInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlayerCreateInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodCreateInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusCreateNestedManyWithoutPodInput
    raw_data?: RawDataCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusUncheckedCreateNestedManyWithoutPodInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodUpdateInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUncheckedUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodCreateManyInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PodUpdateManyMutationInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodUncheckedUpdateManyInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderCreateInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutPod_holdersInput
    audits?: PodHolderAuditCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
    audits?: PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUpdateInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutPod_holdersNestedInput
    audits?: PodHolderAuditUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    audits?: PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderCreateManyInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
  }

  export type PodHolderUpdateManyMutationInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderUncheckedUpdateManyInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PodHolderAuditCreateInput = {
    audit_id?: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
    pod_holder: PodHolderCreateNestedOneWithoutAuditsInput
  }

  export type PodHolderAuditUncheckedCreateInput = {
    audit_id?: string
    pod_holder_id: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
  }

  export type PodHolderAuditUpdateInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pod_holder?: PodHolderUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type PodHolderAuditUncheckedUpdateInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderAuditCreateManyInput = {
    audit_id?: string
    pod_holder_id: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
  }

  export type PodHolderAuditUpdateManyMutationInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderAuditUncheckedUpdateManyInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationCreateInput = {
    allocation_id?: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutPod_allocationsInput
    pod: PodCreateNestedOneWithoutPod_allocationsInput
  }

  export type PodAllocationUncheckedCreateInput = {
    allocation_id?: string
    coach_id?: string | null
    pod_id: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type PodAllocationUpdateInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutPod_allocationsNestedInput
    pod?: PodUpdateOneRequiredWithoutPod_allocationsNestedInput
  }

  export type PodAllocationUncheckedUpdateInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationCreateManyInput = {
    allocation_id?: string
    coach_id?: string | null
    pod_id: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type PodAllocationUpdateManyMutationInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationUncheckedUpdateManyInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentCreateInput = {
    assignment_id?: string
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutCoach_assignmentsInput
    player?: PlayerCreateNestedOneWithoutCoach_assignmentsInput
    pod_holder?: PodHolderCreateNestedOneWithoutCoach_assignmentsInput
    pod?: PodCreateNestedOneWithoutCoach_assignmentsInput
  }

  export type CoachAssignmentUncheckedCreateInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentUpdateInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutCoach_assignmentsNestedInput
    player?: PlayerUpdateOneWithoutCoach_assignmentsNestedInput
    pod_holder?: PodHolderUpdateOneWithoutCoach_assignmentsNestedInput
    pod?: PodUpdateOneWithoutCoach_assignmentsNestedInput
  }

  export type CoachAssignmentUncheckedUpdateInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentCreateManyInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentUpdateManyMutationInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUncheckedUpdateManyInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodCreateInput = {
    id?: string
    assigned_date?: Date | string
    player: PlayerCreateNestedOneWithoutPlayer_podsInput
    pod: PodCreateNestedOneWithoutPlayer_podsInput
  }

  export type PlayerPodUncheckedCreateInput = {
    id?: string
    player_id: string
    pod_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPlayer_podsNestedInput
    pod?: PodUpdateOneRequiredWithoutPlayer_podsNestedInput
  }

  export type PlayerPodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodCreateManyInput = {
    id?: string
    player_id: string
    pod_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderCreateInput = {
    id?: string
    assigned_date?: Date | string
    player: PlayerCreateNestedOneWithoutPlayer_pod_holdersInput
    pod_holder: PodHolderCreateNestedOneWithoutPlayer_pod_holdersInput
  }

  export type PlayerPodHolderUncheckedCreateInput = {
    id?: string
    player_id: string
    pod_holder_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodHolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput
    pod_holder?: PodHolderUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput
  }

  export type PlayerPodHolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderCreateManyInput = {
    id?: string
    player_id: string
    pod_holder_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodHolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusCreateInput = {
    status_id?: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
    pod: PodCreateNestedOneWithoutPod_statusesInput
  }

  export type PodStatusUncheckedCreateInput = {
    status_id?: string
    pod_id: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
  }

  export type PodStatusUpdateInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutPod_statusesNestedInput
  }

  export type PodStatusUncheckedUpdateInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusCreateManyInput = {
    status_id?: string
    pod_id: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
  }

  export type PodStatusUpdateManyMutationInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusUncheckedUpdateManyInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusCreateInput = {
    status_id?: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
    pod_holder: PodHolderCreateNestedOneWithoutPod_holder_statusesInput
  }

  export type PodHolderStatusUncheckedCreateInput = {
    status_id?: string
    pod_holder_id: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
  }

  export type PodHolderStatusUpdateInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pod_holder?: PodHolderUpdateOneRequiredWithoutPod_holder_statusesNestedInput
  }

  export type PodHolderStatusUncheckedUpdateInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusCreateManyInput = {
    status_id?: string
    pod_holder_id: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
  }

  export type PodHolderStatusUpdateManyMutationInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusUncheckedUpdateManyInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataCreateInput = {
    raw_id?: string
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
    player?: PlayerCreateNestedOneWithoutRaw_dataInput
    pod: PodCreateNestedOneWithoutRaw_dataInput
  }

  export type RawDataUncheckedCreateInput = {
    raw_id?: string
    pod_id: string
    player_id?: string | null
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type RawDataUpdateInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutRaw_dataNestedInput
    pod?: PodUpdateOneRequiredWithoutRaw_dataNestedInput
  }

  export type RawDataUncheckedUpdateInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataCreateManyInput = {
    raw_id?: string
    pod_id: string
    player_id?: string | null
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type RawDataUpdateManyMutationInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataUncheckedUpdateManyInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    event_id?: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
    event_participants?: EventParticipantCreateNestedManyWithoutEventInput
    club: ClubCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    event_id?: string
    club_id: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_participants?: EventParticipantUpdateManyWithoutEventNestedInput
    club?: ClubUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    event_id?: string
    club_id: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantCreateInput = {
    id?: string
    coach?: CoachCreateNestedOneWithoutEvent_participantsInput
    event: EventCreateNestedOneWithoutEvent_participantsInput
    player?: PlayerCreateNestedOneWithoutEvent_participantsInput
  }

  export type EventParticipantUncheckedCreateInput = {
    id?: string
    event_id: string
    coach_id?: string | null
    player_id?: string | null
  }

  export type EventParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coach?: CoachUpdateOneWithoutEvent_participantsNestedInput
    event?: EventUpdateOneRequiredWithoutEvent_participantsNestedInput
    player?: PlayerUpdateOneWithoutEvent_participantsNestedInput
  }

  export type EventParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipantCreateManyInput = {
    id?: string
    event_id: string
    coach_id?: string | null
    player_id?: string | null
  }

  export type EventParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EventParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentPlanCreateInput = {
    plan_id?: string
    name?: string | null
    price_cents?: number | null
    duration_days?: number | null
    description?: string | null
    created_at?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PaymentPlanUncheckedCreateInput = {
    plan_id?: string
    name?: string | null
    price_cents?: number | null
    duration_days?: number | null
    description?: string | null
    created_at?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PaymentPlanUpdateInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PaymentPlanUncheckedUpdateInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PaymentPlanCreateManyInput = {
    plan_id?: string
    name?: string | null
    price_cents?: number | null
    duration_days?: number | null
    description?: string | null
    created_at?: Date | string
  }

  export type PaymentPlanUpdateManyMutationInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUncheckedUpdateManyInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    subscription_id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    club: ClubCreateNestedOneWithoutSubscriptionsInput
    plan?: PaymentPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    subscription_id?: string
    club_id: string
    plan_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    club?: ClubUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PaymentPlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    subscription_id?: string
    club_id: string
    plan_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    payment_id?: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
    subscription: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    payment_id?: string
    subscription_id: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
  }

  export type PaymentUpdateInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    payment_id?: string
    subscription_id: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceRequestCreateInput = {
    request_id?: string
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutServiceRequestsInput
  }

  export type ServiceRequestUncheckedCreateInput = {
    request_id?: string
    club_id?: string | null
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceRequestUpdateInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutServiceRequestsNestedInput
  }

  export type ServiceRequestUncheckedUpdateInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestCreateManyInput = {
    request_id?: string
    club_id?: string | null
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceRequestUpdateManyMutationInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricCreateInput = {
    id?: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
    player: PlayerCreateNestedOneWithoutActivity_metricsInput
  }

  export type ActivityMetricUncheckedCreateInput = {
    id?: string
    player_id: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
  }

  export type ActivityMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutActivity_metricsNestedInput
  }

  export type ActivityMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricCreateManyInput = {
    id?: string
    player_id: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
  }

  export type ActivityMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClubListRelationFilter = {
    every?: ClubWhereInput
    some?: ClubWhereInput
    none?: ClubWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminCountOrderByAggregateInput = {
    super_admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    super_admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    super_admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ClubAdminListRelationFilter = {
    every?: ClubAdminWhereInput
    some?: ClubAdminWhereInput
    none?: ClubAdminWhereInput
  }

  export type SuperAdminNullableScalarRelationFilter = {
    is?: SuperAdminWhereInput | null
    isNot?: SuperAdminWhereInput | null
  }

  export type PodHolderListRelationFilter = {
    every?: PodHolderWhereInput
    some?: PodHolderWhereInput
    none?: PodHolderWhereInput
  }

  export type CoachListRelationFilter = {
    every?: CoachWhereInput
    some?: CoachWhereInput
    none?: CoachWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type ServiceRequestListRelationFilter = {
    every?: ServiceRequestWhereInput
    some?: ServiceRequestWhereInput
    none?: ServiceRequestWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type ClubAdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodHolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubCountOrderByAggregateInput = {
    club_id?: SortOrder
    super_admin_id?: SortOrder
    club_name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sport?: SortOrder
  }

  export type ClubMaxOrderByAggregateInput = {
    club_id?: SortOrder
    super_admin_id?: SortOrder
    club_name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sport?: SortOrder
  }

  export type ClubMinOrderByAggregateInput = {
    club_id?: SortOrder
    super_admin_id?: SortOrder
    club_name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sport?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClubScalarRelationFilter = {
    is?: ClubWhereInput
    isNot?: ClubWhereInput
  }

  export type ClubAdminCountOrderByAggregateInput = {
    admin_id?: SortOrder
    club_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type ClubAdminMaxOrderByAggregateInput = {
    admin_id?: SortOrder
    club_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type ClubAdminMinOrderByAggregateInput = {
    admin_id?: SortOrder
    club_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    profile_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type CoachAssignmentListRelationFilter = {
    every?: CoachAssignmentWhereInput
    some?: CoachAssignmentWhereInput
    none?: CoachAssignmentWhereInput
  }

  export type EventParticipantListRelationFilter = {
    every?: EventParticipantWhereInput
    some?: EventParticipantWhereInput
    none?: EventParticipantWhereInput
  }

  export type PodAllocationListRelationFilter = {
    every?: PodAllocationWhereInput
    some?: PodAllocationWhereInput
    none?: PodAllocationWhereInput
  }

  export type CoachAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachCountOrderByAggregateInput = {
    coach_id?: SortOrder
    club_id?: SortOrder
    coach_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    coach_image?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type CoachMaxOrderByAggregateInput = {
    coach_id?: SortOrder
    club_id?: SortOrder
    coach_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    coach_image?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type CoachMinOrderByAggregateInput = {
    coach_id?: SortOrder
    club_id?: SortOrder
    coach_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    coach_image?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
    login_otp?: SortOrder
    login_otp_expires?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ActivityMetricListRelationFilter = {
    every?: ActivityMetricWhereInput
    some?: ActivityMetricWhereInput
    none?: ActivityMetricWhereInput
  }

  export type PlayerPodHolderListRelationFilter = {
    every?: PlayerPodHolderWhereInput
    some?: PlayerPodHolderWhereInput
    none?: PlayerPodHolderWhereInput
  }

  export type PlayerPodListRelationFilter = {
    every?: PlayerPodWhereInput
    some?: PlayerPodWhereInput
    none?: PlayerPodWhereInput
  }

  export type RawDataListRelationFilter = {
    every?: RawDataWhereInput
    some?: RawDataWhereInput
    none?: RawDataWhereInput
  }

  export type ActivityMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerPodHolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerPodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    player_id?: SortOrder
    club_id?: SortOrder
    player_name?: SortOrder
    jersey_number?: SortOrder
    age?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    player_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    jersey_number?: SortOrder
    age?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    player_id?: SortOrder
    club_id?: SortOrder
    player_name?: SortOrder
    jersey_number?: SortOrder
    age?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    player_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    player_id?: SortOrder
    club_id?: SortOrder
    player_name?: SortOrder
    jersey_number?: SortOrder
    age?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    player_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    jersey_number?: SortOrder
    age?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PodStatusListRelationFilter = {
    every?: PodStatusWhereInput
    some?: PodStatusWhereInput
    none?: PodStatusWhereInput
  }

  export type PodStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodCountOrderByAggregateInput = {
    pod_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    firmware?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PodMaxOrderByAggregateInput = {
    pod_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    firmware?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PodMinOrderByAggregateInput = {
    pod_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    firmware?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClubNullableScalarRelationFilter = {
    is?: ClubWhereInput | null
    isNot?: ClubWhereInput | null
  }

  export type PodHolderAuditListRelationFilter = {
    every?: PodHolderAuditWhereInput
    some?: PodHolderAuditWhereInput
    none?: PodHolderAuditWhereInput
  }

  export type PodHolderStatusListRelationFilter = {
    every?: PodHolderStatusWhereInput
    some?: PodHolderStatusWhereInput
    none?: PodHolderStatusWhereInput
  }

  export type PodHolderAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodHolderStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PodHolderCountOrderByAggregateInput = {
    pod_holder_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club_id?: SortOrder
  }

  export type PodHolderMaxOrderByAggregateInput = {
    pod_holder_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club_id?: SortOrder
  }

  export type PodHolderMinOrderByAggregateInput = {
    pod_holder_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    club_id?: SortOrder
  }

  export type PodHolderScalarRelationFilter = {
    is?: PodHolderWhereInput
    isNot?: PodHolderWhereInput
  }

  export type PodHolderAuditCountOrderByAggregateInput = {
    audit_id?: SortOrder
    pod_holder_id?: SortOrder
    from_club_id?: SortOrder
    to_club_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    created_at?: SortOrder
  }

  export type PodHolderAuditMaxOrderByAggregateInput = {
    audit_id?: SortOrder
    pod_holder_id?: SortOrder
    from_club_id?: SortOrder
    to_club_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    created_at?: SortOrder
  }

  export type PodHolderAuditMinOrderByAggregateInput = {
    audit_id?: SortOrder
    pod_holder_id?: SortOrder
    from_club_id?: SortOrder
    to_club_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    created_at?: SortOrder
  }

  export type CoachNullableScalarRelationFilter = {
    is?: CoachWhereInput | null
    isNot?: CoachWhereInput | null
  }

  export type PodScalarRelationFilter = {
    is?: PodWhereInput
    isNot?: PodWhereInput
  }

  export type PodAllocationCountOrderByAggregateInput = {
    allocation_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    battery_level?: SortOrder
    health_status?: SortOrder
    assigned_at?: SortOrder
  }

  export type PodAllocationAvgOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type PodAllocationMaxOrderByAggregateInput = {
    allocation_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    battery_level?: SortOrder
    health_status?: SortOrder
    assigned_at?: SortOrder
  }

  export type PodAllocationMinOrderByAggregateInput = {
    allocation_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    battery_level?: SortOrder
    health_status?: SortOrder
    assigned_at?: SortOrder
  }

  export type PodAllocationSumOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type PlayerNullableScalarRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type PodHolderNullableScalarRelationFilter = {
    is?: PodHolderWhereInput | null
    isNot?: PodHolderWhereInput | null
  }

  export type PodNullableScalarRelationFilter = {
    is?: PodWhereInput | null
    isNot?: PodWhereInput | null
  }

  export type CoachAssignmentCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    pod_holder_id?: SortOrder
    player_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type CoachAssignmentMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    pod_holder_id?: SortOrder
    player_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type CoachAssignmentMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    coach_id?: SortOrder
    pod_id?: SortOrder
    pod_holder_id?: SortOrder
    player_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type PlayerPodCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PlayerPodMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PlayerPodMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PlayerPodHolderCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_holder_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PlayerPodHolderMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_holder_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PlayerPodHolderMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    pod_holder_id?: SortOrder
    assigned_date?: SortOrder
  }

  export type PodStatusCountOrderByAggregateInput = {
    status_id?: SortOrder
    pod_id?: SortOrder
    working_status?: SortOrder
    battery_level?: SortOrder
    last_sync?: SortOrder
    health_status?: SortOrder
    created_at?: SortOrder
  }

  export type PodStatusAvgOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type PodStatusMaxOrderByAggregateInput = {
    status_id?: SortOrder
    pod_id?: SortOrder
    working_status?: SortOrder
    battery_level?: SortOrder
    last_sync?: SortOrder
    health_status?: SortOrder
    created_at?: SortOrder
  }

  export type PodStatusMinOrderByAggregateInput = {
    status_id?: SortOrder
    pod_id?: SortOrder
    working_status?: SortOrder
    battery_level?: SortOrder
    last_sync?: SortOrder
    health_status?: SortOrder
    created_at?: SortOrder
  }

  export type PodStatusSumOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type PodHolderStatusCountOrderByAggregateInput = {
    status_id?: SortOrder
    pod_holder_id?: SortOrder
    battery_level?: SortOrder
    working_status?: SortOrder
    last_sync?: SortOrder
    created_at?: SortOrder
  }

  export type PodHolderStatusAvgOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type PodHolderStatusMaxOrderByAggregateInput = {
    status_id?: SortOrder
    pod_holder_id?: SortOrder
    battery_level?: SortOrder
    working_status?: SortOrder
    last_sync?: SortOrder
    created_at?: SortOrder
  }

  export type PodHolderStatusMinOrderByAggregateInput = {
    status_id?: SortOrder
    pod_holder_id?: SortOrder
    battery_level?: SortOrder
    working_status?: SortOrder
    last_sync?: SortOrder
    created_at?: SortOrder
  }

  export type PodHolderStatusSumOrderByAggregateInput = {
    battery_level?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RawDataCountOrderByAggregateInput = {
    raw_id?: SortOrder
    pod_id?: SortOrder
    player_id?: SortOrder
    ts?: SortOrder
    acceleration_x?: SortOrder
    acceleration_y?: SortOrder
    acceleration_z?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    w?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    distance?: SortOrder
    speed?: SortOrder
    heart_rate?: SortOrder
    created_at?: SortOrder
  }

  export type RawDataAvgOrderByAggregateInput = {
    acceleration_x?: SortOrder
    acceleration_y?: SortOrder
    acceleration_z?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    w?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    distance?: SortOrder
    speed?: SortOrder
    heart_rate?: SortOrder
  }

  export type RawDataMaxOrderByAggregateInput = {
    raw_id?: SortOrder
    pod_id?: SortOrder
    player_id?: SortOrder
    ts?: SortOrder
    acceleration_x?: SortOrder
    acceleration_y?: SortOrder
    acceleration_z?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    w?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    distance?: SortOrder
    speed?: SortOrder
    heart_rate?: SortOrder
    created_at?: SortOrder
  }

  export type RawDataMinOrderByAggregateInput = {
    raw_id?: SortOrder
    pod_id?: SortOrder
    player_id?: SortOrder
    ts?: SortOrder
    acceleration_x?: SortOrder
    acceleration_y?: SortOrder
    acceleration_z?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    w?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    distance?: SortOrder
    speed?: SortOrder
    heart_rate?: SortOrder
    created_at?: SortOrder
  }

  export type RawDataSumOrderByAggregateInput = {
    acceleration_x?: SortOrder
    acceleration_y?: SortOrder
    acceleration_z?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    w?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    distance?: SortOrder
    speed?: SortOrder
    heart_rate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EventCountOrderByAggregateInput = {
    event_id?: SortOrder
    club_id?: SortOrder
    event_name?: SortOrder
    event_date?: SortOrder
    location?: SortOrder
    event_type?: SortOrder
    created_at?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    event_id?: SortOrder
    club_id?: SortOrder
    event_name?: SortOrder
    event_date?: SortOrder
    location?: SortOrder
    event_type?: SortOrder
    created_at?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    event_id?: SortOrder
    club_id?: SortOrder
    event_name?: SortOrder
    event_date?: SortOrder
    location?: SortOrder
    event_type?: SortOrder
    created_at?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    coach_id?: SortOrder
    player_id?: SortOrder
  }

  export type EventParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    coach_id?: SortOrder
    player_id?: SortOrder
  }

  export type EventParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    coach_id?: SortOrder
    player_id?: SortOrder
  }

  export type PaymentPlanCountOrderByAggregateInput = {
    plan_id?: SortOrder
    name?: SortOrder
    price_cents?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentPlanAvgOrderByAggregateInput = {
    price_cents?: SortOrder
    duration_days?: SortOrder
  }

  export type PaymentPlanMaxOrderByAggregateInput = {
    plan_id?: SortOrder
    name?: SortOrder
    price_cents?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentPlanMinOrderByAggregateInput = {
    plan_id?: SortOrder
    name?: SortOrder
    price_cents?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentPlanSumOrderByAggregateInput = {
    price_cents?: SortOrder
    duration_days?: SortOrder
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentPlanNullableScalarRelationFilter = {
    is?: PaymentPlanWhereInput | null
    isNot?: PaymentPlanWhereInput | null
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    subscription_id?: SortOrder
    club_id?: SortOrder
    plan_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    subscription_id?: SortOrder
    club_id?: SortOrder
    plan_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    subscription_id?: SortOrder
    club_id?: SortOrder
    plan_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    subscription_id?: SortOrder
    amount_cents?: SortOrder
    paid_at?: SortOrder
    method?: SortOrder
    transaction_ref?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount_cents?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    subscription_id?: SortOrder
    amount_cents?: SortOrder
    paid_at?: SortOrder
    method?: SortOrder
    transaction_ref?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    subscription_id?: SortOrder
    amount_cents?: SortOrder
    paid_at?: SortOrder
    method?: SortOrder
    transaction_ref?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount_cents?: SortOrder
  }

  export type ServiceRequestCountOrderByAggregateInput = {
    request_id?: SortOrder
    club_id?: SortOrder
    requester_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceRequestMaxOrderByAggregateInput = {
    request_id?: SortOrder
    club_id?: SortOrder
    requester_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceRequestMinOrderByAggregateInput = {
    request_id?: SortOrder
    club_id?: SortOrder
    requester_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityMetricCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    total_distance?: SortOrder
    hsr_distance?: SortOrder
    sprint_distance?: SortOrder
    top_speed?: SortOrder
    sprint_count?: SortOrder
    acceleration?: SortOrder
    deceleration?: SortOrder
    max_acceleration?: SortOrder
    max_deceleration?: SortOrder
    player_load?: SortOrder
    power_score?: SortOrder
    hr_max?: SortOrder
    time_in_red_zone?: SortOrder
    percent_in_red_zone?: SortOrder
    hr_recovery_time?: SortOrder
    recorded_at?: SortOrder
  }

  export type ActivityMetricAvgOrderByAggregateInput = {
    total_distance?: SortOrder
    hsr_distance?: SortOrder
    sprint_distance?: SortOrder
    top_speed?: SortOrder
    sprint_count?: SortOrder
    acceleration?: SortOrder
    deceleration?: SortOrder
    max_acceleration?: SortOrder
    max_deceleration?: SortOrder
    player_load?: SortOrder
    power_score?: SortOrder
    hr_max?: SortOrder
    time_in_red_zone?: SortOrder
    percent_in_red_zone?: SortOrder
    hr_recovery_time?: SortOrder
  }

  export type ActivityMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    total_distance?: SortOrder
    hsr_distance?: SortOrder
    sprint_distance?: SortOrder
    top_speed?: SortOrder
    sprint_count?: SortOrder
    acceleration?: SortOrder
    deceleration?: SortOrder
    max_acceleration?: SortOrder
    max_deceleration?: SortOrder
    player_load?: SortOrder
    power_score?: SortOrder
    hr_max?: SortOrder
    time_in_red_zone?: SortOrder
    percent_in_red_zone?: SortOrder
    hr_recovery_time?: SortOrder
    recorded_at?: SortOrder
  }

  export type ActivityMetricMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    total_distance?: SortOrder
    hsr_distance?: SortOrder
    sprint_distance?: SortOrder
    top_speed?: SortOrder
    sprint_count?: SortOrder
    acceleration?: SortOrder
    deceleration?: SortOrder
    max_acceleration?: SortOrder
    max_deceleration?: SortOrder
    player_load?: SortOrder
    power_score?: SortOrder
    hr_max?: SortOrder
    time_in_red_zone?: SortOrder
    percent_in_red_zone?: SortOrder
    hr_recovery_time?: SortOrder
    recorded_at?: SortOrder
  }

  export type ActivityMetricSumOrderByAggregateInput = {
    total_distance?: SortOrder
    hsr_distance?: SortOrder
    sprint_distance?: SortOrder
    top_speed?: SortOrder
    sprint_count?: SortOrder
    acceleration?: SortOrder
    deceleration?: SortOrder
    max_acceleration?: SortOrder
    max_deceleration?: SortOrder
    player_load?: SortOrder
    power_score?: SortOrder
    hr_max?: SortOrder
    time_in_red_zone?: SortOrder
    percent_in_red_zone?: SortOrder
    hr_recovery_time?: SortOrder
  }

  export type ClubCreateNestedManyWithoutSuper_adminInput = {
    create?: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput> | ClubCreateWithoutSuper_adminInput[] | ClubUncheckedCreateWithoutSuper_adminInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutSuper_adminInput | ClubCreateOrConnectWithoutSuper_adminInput[]
    createMany?: ClubCreateManySuper_adminInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type ClubUncheckedCreateNestedManyWithoutSuper_adminInput = {
    create?: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput> | ClubCreateWithoutSuper_adminInput[] | ClubUncheckedCreateWithoutSuper_adminInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutSuper_adminInput | ClubCreateOrConnectWithoutSuper_adminInput[]
    createMany?: ClubCreateManySuper_adminInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClubUpdateManyWithoutSuper_adminNestedInput = {
    create?: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput> | ClubCreateWithoutSuper_adminInput[] | ClubUncheckedCreateWithoutSuper_adminInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutSuper_adminInput | ClubCreateOrConnectWithoutSuper_adminInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutSuper_adminInput | ClubUpsertWithWhereUniqueWithoutSuper_adminInput[]
    createMany?: ClubCreateManySuper_adminInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutSuper_adminInput | ClubUpdateWithWhereUniqueWithoutSuper_adminInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutSuper_adminInput | ClubUpdateManyWithWhereWithoutSuper_adminInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type ClubUncheckedUpdateManyWithoutSuper_adminNestedInput = {
    create?: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput> | ClubCreateWithoutSuper_adminInput[] | ClubUncheckedCreateWithoutSuper_adminInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutSuper_adminInput | ClubCreateOrConnectWithoutSuper_adminInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutSuper_adminInput | ClubUpsertWithWhereUniqueWithoutSuper_adminInput[]
    createMany?: ClubCreateManySuper_adminInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutSuper_adminInput | ClubUpdateWithWhereUniqueWithoutSuper_adminInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutSuper_adminInput | ClubUpdateManyWithWhereWithoutSuper_adminInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type ClubAdminCreateNestedManyWithoutClubInput = {
    create?: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput> | ClubAdminCreateWithoutClubInput[] | ClubAdminUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubAdminCreateOrConnectWithoutClubInput | ClubAdminCreateOrConnectWithoutClubInput[]
    createMany?: ClubAdminCreateManyClubInputEnvelope
    connect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
  }

  export type SuperAdminCreateNestedOneWithoutClubsInput = {
    create?: XOR<SuperAdminCreateWithoutClubsInput, SuperAdminUncheckedCreateWithoutClubsInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutClubsInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type PodHolderCreateNestedManyWithoutClubInput = {
    create?: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput> | PodHolderCreateWithoutClubInput[] | PodHolderUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PodHolderCreateOrConnectWithoutClubInput | PodHolderCreateOrConnectWithoutClubInput[]
    createMany?: PodHolderCreateManyClubInputEnvelope
    connect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
  }

  export type CoachCreateNestedManyWithoutClubInput = {
    create?: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput> | CoachCreateWithoutClubInput[] | CoachUncheckedCreateWithoutClubInput[]
    connectOrCreate?: CoachCreateOrConnectWithoutClubInput | CoachCreateOrConnectWithoutClubInput[]
    createMany?: CoachCreateManyClubInputEnvelope
    connect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutClubInput = {
    create?: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput> | EventCreateWithoutClubInput[] | EventUncheckedCreateWithoutClubInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClubInput | EventCreateOrConnectWithoutClubInput[]
    createMany?: EventCreateManyClubInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutClubInput = {
    create?: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput> | PlayerCreateWithoutClubInput[] | PlayerUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutClubInput | PlayerCreateOrConnectWithoutClubInput[]
    createMany?: PlayerCreateManyClubInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutClubInput = {
    create?: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput> | ServiceRequestCreateWithoutClubInput[] | ServiceRequestUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutClubInput | ServiceRequestCreateOrConnectWithoutClubInput[]
    createMany?: ServiceRequestCreateManyClubInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutClubInput = {
    create?: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput> | SubscriptionCreateWithoutClubInput[] | SubscriptionUncheckedCreateWithoutClubInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClubInput | SubscriptionCreateOrConnectWithoutClubInput[]
    createMany?: SubscriptionCreateManyClubInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ClubAdminUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput> | ClubAdminCreateWithoutClubInput[] | ClubAdminUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubAdminCreateOrConnectWithoutClubInput | ClubAdminCreateOrConnectWithoutClubInput[]
    createMany?: ClubAdminCreateManyClubInputEnvelope
    connect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
  }

  export type PodHolderUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput> | PodHolderCreateWithoutClubInput[] | PodHolderUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PodHolderCreateOrConnectWithoutClubInput | PodHolderCreateOrConnectWithoutClubInput[]
    createMany?: PodHolderCreateManyClubInputEnvelope
    connect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
  }

  export type CoachUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput> | CoachCreateWithoutClubInput[] | CoachUncheckedCreateWithoutClubInput[]
    connectOrCreate?: CoachCreateOrConnectWithoutClubInput | CoachCreateOrConnectWithoutClubInput[]
    createMany?: CoachCreateManyClubInputEnvelope
    connect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput> | EventCreateWithoutClubInput[] | EventUncheckedCreateWithoutClubInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClubInput | EventCreateOrConnectWithoutClubInput[]
    createMany?: EventCreateManyClubInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput> | PlayerCreateWithoutClubInput[] | PlayerUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutClubInput | PlayerCreateOrConnectWithoutClubInput[]
    createMany?: PlayerCreateManyClubInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput> | ServiceRequestCreateWithoutClubInput[] | ServiceRequestUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutClubInput | ServiceRequestCreateOrConnectWithoutClubInput[]
    createMany?: ServiceRequestCreateManyClubInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput> | SubscriptionCreateWithoutClubInput[] | SubscriptionUncheckedCreateWithoutClubInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClubInput | SubscriptionCreateOrConnectWithoutClubInput[]
    createMany?: SubscriptionCreateManyClubInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ClubAdminUpdateManyWithoutClubNestedInput = {
    create?: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput> | ClubAdminCreateWithoutClubInput[] | ClubAdminUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubAdminCreateOrConnectWithoutClubInput | ClubAdminCreateOrConnectWithoutClubInput[]
    upsert?: ClubAdminUpsertWithWhereUniqueWithoutClubInput | ClubAdminUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ClubAdminCreateManyClubInputEnvelope
    set?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    disconnect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    delete?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    connect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    update?: ClubAdminUpdateWithWhereUniqueWithoutClubInput | ClubAdminUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ClubAdminUpdateManyWithWhereWithoutClubInput | ClubAdminUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ClubAdminScalarWhereInput | ClubAdminScalarWhereInput[]
  }

  export type SuperAdminUpdateOneWithoutClubsNestedInput = {
    create?: XOR<SuperAdminCreateWithoutClubsInput, SuperAdminUncheckedCreateWithoutClubsInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutClubsInput
    upsert?: SuperAdminUpsertWithoutClubsInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutClubsInput, SuperAdminUpdateWithoutClubsInput>, SuperAdminUncheckedUpdateWithoutClubsInput>
  }

  export type PodHolderUpdateManyWithoutClubNestedInput = {
    create?: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput> | PodHolderCreateWithoutClubInput[] | PodHolderUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PodHolderCreateOrConnectWithoutClubInput | PodHolderCreateOrConnectWithoutClubInput[]
    upsert?: PodHolderUpsertWithWhereUniqueWithoutClubInput | PodHolderUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: PodHolderCreateManyClubInputEnvelope
    set?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    disconnect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    delete?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    connect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    update?: PodHolderUpdateWithWhereUniqueWithoutClubInput | PodHolderUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: PodHolderUpdateManyWithWhereWithoutClubInput | PodHolderUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: PodHolderScalarWhereInput | PodHolderScalarWhereInput[]
  }

  export type CoachUpdateManyWithoutClubNestedInput = {
    create?: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput> | CoachCreateWithoutClubInput[] | CoachUncheckedCreateWithoutClubInput[]
    connectOrCreate?: CoachCreateOrConnectWithoutClubInput | CoachCreateOrConnectWithoutClubInput[]
    upsert?: CoachUpsertWithWhereUniqueWithoutClubInput | CoachUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: CoachCreateManyClubInputEnvelope
    set?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    disconnect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    delete?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    connect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    update?: CoachUpdateWithWhereUniqueWithoutClubInput | CoachUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: CoachUpdateManyWithWhereWithoutClubInput | CoachUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: CoachScalarWhereInput | CoachScalarWhereInput[]
  }

  export type EventUpdateManyWithoutClubNestedInput = {
    create?: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput> | EventCreateWithoutClubInput[] | EventUncheckedCreateWithoutClubInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClubInput | EventCreateOrConnectWithoutClubInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClubInput | EventUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: EventCreateManyClubInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClubInput | EventUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClubInput | EventUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutClubNestedInput = {
    create?: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput> | PlayerCreateWithoutClubInput[] | PlayerUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutClubInput | PlayerCreateOrConnectWithoutClubInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutClubInput | PlayerUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: PlayerCreateManyClubInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutClubInput | PlayerUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutClubInput | PlayerUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutClubNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput> | ServiceRequestCreateWithoutClubInput[] | ServiceRequestUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutClubInput | ServiceRequestCreateOrConnectWithoutClubInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutClubInput | ServiceRequestUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ServiceRequestCreateManyClubInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutClubInput | ServiceRequestUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutClubInput | ServiceRequestUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutClubNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput> | SubscriptionCreateWithoutClubInput[] | SubscriptionUncheckedCreateWithoutClubInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClubInput | SubscriptionCreateOrConnectWithoutClubInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutClubInput | SubscriptionUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: SubscriptionCreateManyClubInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutClubInput | SubscriptionUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutClubInput | SubscriptionUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ClubAdminUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput> | ClubAdminCreateWithoutClubInput[] | ClubAdminUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubAdminCreateOrConnectWithoutClubInput | ClubAdminCreateOrConnectWithoutClubInput[]
    upsert?: ClubAdminUpsertWithWhereUniqueWithoutClubInput | ClubAdminUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ClubAdminCreateManyClubInputEnvelope
    set?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    disconnect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    delete?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    connect?: ClubAdminWhereUniqueInput | ClubAdminWhereUniqueInput[]
    update?: ClubAdminUpdateWithWhereUniqueWithoutClubInput | ClubAdminUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ClubAdminUpdateManyWithWhereWithoutClubInput | ClubAdminUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ClubAdminScalarWhereInput | ClubAdminScalarWhereInput[]
  }

  export type PodHolderUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput> | PodHolderCreateWithoutClubInput[] | PodHolderUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PodHolderCreateOrConnectWithoutClubInput | PodHolderCreateOrConnectWithoutClubInput[]
    upsert?: PodHolderUpsertWithWhereUniqueWithoutClubInput | PodHolderUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: PodHolderCreateManyClubInputEnvelope
    set?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    disconnect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    delete?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    connect?: PodHolderWhereUniqueInput | PodHolderWhereUniqueInput[]
    update?: PodHolderUpdateWithWhereUniqueWithoutClubInput | PodHolderUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: PodHolderUpdateManyWithWhereWithoutClubInput | PodHolderUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: PodHolderScalarWhereInput | PodHolderScalarWhereInput[]
  }

  export type CoachUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput> | CoachCreateWithoutClubInput[] | CoachUncheckedCreateWithoutClubInput[]
    connectOrCreate?: CoachCreateOrConnectWithoutClubInput | CoachCreateOrConnectWithoutClubInput[]
    upsert?: CoachUpsertWithWhereUniqueWithoutClubInput | CoachUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: CoachCreateManyClubInputEnvelope
    set?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    disconnect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    delete?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    connect?: CoachWhereUniqueInput | CoachWhereUniqueInput[]
    update?: CoachUpdateWithWhereUniqueWithoutClubInput | CoachUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: CoachUpdateManyWithWhereWithoutClubInput | CoachUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: CoachScalarWhereInput | CoachScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput> | EventCreateWithoutClubInput[] | EventUncheckedCreateWithoutClubInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClubInput | EventCreateOrConnectWithoutClubInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClubInput | EventUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: EventCreateManyClubInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClubInput | EventUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClubInput | EventUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput> | PlayerCreateWithoutClubInput[] | PlayerUncheckedCreateWithoutClubInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutClubInput | PlayerCreateOrConnectWithoutClubInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutClubInput | PlayerUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: PlayerCreateManyClubInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutClubInput | PlayerUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutClubInput | PlayerUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput> | ServiceRequestCreateWithoutClubInput[] | ServiceRequestUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutClubInput | ServiceRequestCreateOrConnectWithoutClubInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutClubInput | ServiceRequestUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ServiceRequestCreateManyClubInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutClubInput | ServiceRequestUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutClubInput | ServiceRequestUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput> | SubscriptionCreateWithoutClubInput[] | SubscriptionUncheckedCreateWithoutClubInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClubInput | SubscriptionCreateOrConnectWithoutClubInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutClubInput | SubscriptionUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: SubscriptionCreateManyClubInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutClubInput | SubscriptionUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutClubInput | SubscriptionUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ClubCreateNestedOneWithoutClub_adminsInput = {
    create?: XOR<ClubCreateWithoutClub_adminsInput, ClubUncheckedCreateWithoutClub_adminsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutClub_adminsInput
    connect?: ClubWhereUniqueInput
  }

  export type ClubUpdateOneRequiredWithoutClub_adminsNestedInput = {
    create?: XOR<ClubCreateWithoutClub_adminsInput, ClubUncheckedCreateWithoutClub_adminsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutClub_adminsInput
    upsert?: ClubUpsertWithoutClub_adminsInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutClub_adminsInput, ClubUpdateWithoutClub_adminsInput>, ClubUncheckedUpdateWithoutClub_adminsInput>
  }

  export type CoachAssignmentCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput> | CoachAssignmentCreateWithoutCoachInput[] | CoachAssignmentUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutCoachInput | CoachAssignmentCreateOrConnectWithoutCoachInput[]
    createMany?: CoachAssignmentCreateManyCoachInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type ClubCreateNestedOneWithoutCoachesInput = {
    create?: XOR<ClubCreateWithoutCoachesInput, ClubUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: ClubCreateOrConnectWithoutCoachesInput
    connect?: ClubWhereUniqueInput
  }

  export type EventParticipantCreateNestedManyWithoutCoachInput = {
    create?: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput> | EventParticipantCreateWithoutCoachInput[] | EventParticipantUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutCoachInput | EventParticipantCreateOrConnectWithoutCoachInput[]
    createMany?: EventParticipantCreateManyCoachInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type PodAllocationCreateNestedManyWithoutCoachInput = {
    create?: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput> | PodAllocationCreateWithoutCoachInput[] | PodAllocationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutCoachInput | PodAllocationCreateOrConnectWithoutCoachInput[]
    createMany?: PodAllocationCreateManyCoachInputEnvelope
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
  }

  export type CoachAssignmentUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput> | CoachAssignmentCreateWithoutCoachInput[] | CoachAssignmentUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutCoachInput | CoachAssignmentCreateOrConnectWithoutCoachInput[]
    createMany?: CoachAssignmentCreateManyCoachInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type EventParticipantUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput> | EventParticipantCreateWithoutCoachInput[] | EventParticipantUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutCoachInput | EventParticipantCreateOrConnectWithoutCoachInput[]
    createMany?: EventParticipantCreateManyCoachInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type PodAllocationUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput> | PodAllocationCreateWithoutCoachInput[] | PodAllocationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutCoachInput | PodAllocationCreateOrConnectWithoutCoachInput[]
    createMany?: PodAllocationCreateManyCoachInputEnvelope
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
  }

  export type CoachAssignmentUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput> | CoachAssignmentCreateWithoutCoachInput[] | CoachAssignmentUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutCoachInput | CoachAssignmentCreateOrConnectWithoutCoachInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutCoachInput | CoachAssignmentUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachAssignmentCreateManyCoachInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutCoachInput | CoachAssignmentUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutCoachInput | CoachAssignmentUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type ClubUpdateOneRequiredWithoutCoachesNestedInput = {
    create?: XOR<ClubCreateWithoutCoachesInput, ClubUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: ClubCreateOrConnectWithoutCoachesInput
    upsert?: ClubUpsertWithoutCoachesInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutCoachesInput, ClubUpdateWithoutCoachesInput>, ClubUncheckedUpdateWithoutCoachesInput>
  }

  export type EventParticipantUpdateManyWithoutCoachNestedInput = {
    create?: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput> | EventParticipantCreateWithoutCoachInput[] | EventParticipantUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutCoachInput | EventParticipantCreateOrConnectWithoutCoachInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutCoachInput | EventParticipantUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: EventParticipantCreateManyCoachInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutCoachInput | EventParticipantUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutCoachInput | EventParticipantUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type PodAllocationUpdateManyWithoutCoachNestedInput = {
    create?: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput> | PodAllocationCreateWithoutCoachInput[] | PodAllocationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutCoachInput | PodAllocationCreateOrConnectWithoutCoachInput[]
    upsert?: PodAllocationUpsertWithWhereUniqueWithoutCoachInput | PodAllocationUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: PodAllocationCreateManyCoachInputEnvelope
    set?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    disconnect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    delete?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    update?: PodAllocationUpdateWithWhereUniqueWithoutCoachInput | PodAllocationUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: PodAllocationUpdateManyWithWhereWithoutCoachInput | PodAllocationUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput> | CoachAssignmentCreateWithoutCoachInput[] | CoachAssignmentUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutCoachInput | CoachAssignmentCreateOrConnectWithoutCoachInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutCoachInput | CoachAssignmentUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachAssignmentCreateManyCoachInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutCoachInput | CoachAssignmentUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutCoachInput | CoachAssignmentUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type EventParticipantUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput> | EventParticipantCreateWithoutCoachInput[] | EventParticipantUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutCoachInput | EventParticipantCreateOrConnectWithoutCoachInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutCoachInput | EventParticipantUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: EventParticipantCreateManyCoachInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutCoachInput | EventParticipantUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutCoachInput | EventParticipantUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type PodAllocationUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput> | PodAllocationCreateWithoutCoachInput[] | PodAllocationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutCoachInput | PodAllocationCreateOrConnectWithoutCoachInput[]
    upsert?: PodAllocationUpsertWithWhereUniqueWithoutCoachInput | PodAllocationUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: PodAllocationCreateManyCoachInputEnvelope
    set?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    disconnect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    delete?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    update?: PodAllocationUpdateWithWhereUniqueWithoutCoachInput | PodAllocationUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: PodAllocationUpdateManyWithWhereWithoutCoachInput | PodAllocationUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
  }

  export type ActivityMetricCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput> | ActivityMetricCreateWithoutPlayerInput[] | ActivityMetricUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActivityMetricCreateOrConnectWithoutPlayerInput | ActivityMetricCreateOrConnectWithoutPlayerInput[]
    createMany?: ActivityMetricCreateManyPlayerInputEnvelope
    connect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
  }

  export type CoachAssignmentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput> | CoachAssignmentCreateWithoutPlayerInput[] | CoachAssignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPlayerInput | CoachAssignmentCreateOrConnectWithoutPlayerInput[]
    createMany?: CoachAssignmentCreateManyPlayerInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type EventParticipantCreateNestedManyWithoutPlayerInput = {
    create?: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput> | EventParticipantCreateWithoutPlayerInput[] | EventParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutPlayerInput | EventParticipantCreateOrConnectWithoutPlayerInput[]
    createMany?: EventParticipantCreateManyPlayerInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type PlayerPodHolderCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput> | PlayerPodHolderCreateWithoutPlayerInput[] | PlayerPodHolderUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPlayerInput | PlayerPodHolderCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerPodHolderCreateManyPlayerInputEnvelope
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
  }

  export type PlayerPodCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput> | PlayerPodCreateWithoutPlayerInput[] | PlayerPodUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPlayerInput | PlayerPodCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerPodCreateManyPlayerInputEnvelope
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
  }

  export type ClubCreateNestedOneWithoutPlayersInput = {
    create?: XOR<ClubCreateWithoutPlayersInput, ClubUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ClubCreateOrConnectWithoutPlayersInput
    connect?: ClubWhereUniqueInput
  }

  export type RawDataCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput> | RawDataCreateWithoutPlayerInput[] | RawDataUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPlayerInput | RawDataCreateOrConnectWithoutPlayerInput[]
    createMany?: RawDataCreateManyPlayerInputEnvelope
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
  }

  export type ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput> | ActivityMetricCreateWithoutPlayerInput[] | ActivityMetricUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActivityMetricCreateOrConnectWithoutPlayerInput | ActivityMetricCreateOrConnectWithoutPlayerInput[]
    createMany?: ActivityMetricCreateManyPlayerInputEnvelope
    connect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
  }

  export type CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput> | CoachAssignmentCreateWithoutPlayerInput[] | CoachAssignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPlayerInput | CoachAssignmentCreateOrConnectWithoutPlayerInput[]
    createMany?: CoachAssignmentCreateManyPlayerInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type EventParticipantUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput> | EventParticipantCreateWithoutPlayerInput[] | EventParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutPlayerInput | EventParticipantCreateOrConnectWithoutPlayerInput[]
    createMany?: EventParticipantCreateManyPlayerInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput> | PlayerPodHolderCreateWithoutPlayerInput[] | PlayerPodHolderUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPlayerInput | PlayerPodHolderCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerPodHolderCreateManyPlayerInputEnvelope
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
  }

  export type PlayerPodUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput> | PlayerPodCreateWithoutPlayerInput[] | PlayerPodUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPlayerInput | PlayerPodCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerPodCreateManyPlayerInputEnvelope
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
  }

  export type RawDataUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput> | RawDataCreateWithoutPlayerInput[] | RawDataUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPlayerInput | RawDataCreateOrConnectWithoutPlayerInput[]
    createMany?: RawDataCreateManyPlayerInputEnvelope
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityMetricUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput> | ActivityMetricCreateWithoutPlayerInput[] | ActivityMetricUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActivityMetricCreateOrConnectWithoutPlayerInput | ActivityMetricCreateOrConnectWithoutPlayerInput[]
    upsert?: ActivityMetricUpsertWithWhereUniqueWithoutPlayerInput | ActivityMetricUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ActivityMetricCreateManyPlayerInputEnvelope
    set?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    disconnect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    delete?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    connect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    update?: ActivityMetricUpdateWithWhereUniqueWithoutPlayerInput | ActivityMetricUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ActivityMetricUpdateManyWithWhereWithoutPlayerInput | ActivityMetricUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ActivityMetricScalarWhereInput | ActivityMetricScalarWhereInput[]
  }

  export type CoachAssignmentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput> | CoachAssignmentCreateWithoutPlayerInput[] | CoachAssignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPlayerInput | CoachAssignmentCreateOrConnectWithoutPlayerInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPlayerInput | CoachAssignmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CoachAssignmentCreateManyPlayerInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPlayerInput | CoachAssignmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPlayerInput | CoachAssignmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type EventParticipantUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput> | EventParticipantCreateWithoutPlayerInput[] | EventParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutPlayerInput | EventParticipantCreateOrConnectWithoutPlayerInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutPlayerInput | EventParticipantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: EventParticipantCreateManyPlayerInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutPlayerInput | EventParticipantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutPlayerInput | EventParticipantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type PlayerPodHolderUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput> | PlayerPodHolderCreateWithoutPlayerInput[] | PlayerPodHolderUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPlayerInput | PlayerPodHolderCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerPodHolderUpsertWithWhereUniqueWithoutPlayerInput | PlayerPodHolderUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerPodHolderCreateManyPlayerInputEnvelope
    set?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    disconnect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    delete?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    update?: PlayerPodHolderUpdateWithWhereUniqueWithoutPlayerInput | PlayerPodHolderUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerPodHolderUpdateManyWithWhereWithoutPlayerInput | PlayerPodHolderUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
  }

  export type PlayerPodUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput> | PlayerPodCreateWithoutPlayerInput[] | PlayerPodUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPlayerInput | PlayerPodCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerPodUpsertWithWhereUniqueWithoutPlayerInput | PlayerPodUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerPodCreateManyPlayerInputEnvelope
    set?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    disconnect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    delete?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    update?: PlayerPodUpdateWithWhereUniqueWithoutPlayerInput | PlayerPodUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerPodUpdateManyWithWhereWithoutPlayerInput | PlayerPodUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
  }

  export type ClubUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<ClubCreateWithoutPlayersInput, ClubUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ClubCreateOrConnectWithoutPlayersInput
    upsert?: ClubUpsertWithoutPlayersInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutPlayersInput, ClubUpdateWithoutPlayersInput>, ClubUncheckedUpdateWithoutPlayersInput>
  }

  export type RawDataUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput> | RawDataCreateWithoutPlayerInput[] | RawDataUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPlayerInput | RawDataCreateOrConnectWithoutPlayerInput[]
    upsert?: RawDataUpsertWithWhereUniqueWithoutPlayerInput | RawDataUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RawDataCreateManyPlayerInputEnvelope
    set?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    disconnect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    delete?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    update?: RawDataUpdateWithWhereUniqueWithoutPlayerInput | RawDataUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RawDataUpdateManyWithWhereWithoutPlayerInput | RawDataUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
  }

  export type ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput> | ActivityMetricCreateWithoutPlayerInput[] | ActivityMetricUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ActivityMetricCreateOrConnectWithoutPlayerInput | ActivityMetricCreateOrConnectWithoutPlayerInput[]
    upsert?: ActivityMetricUpsertWithWhereUniqueWithoutPlayerInput | ActivityMetricUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ActivityMetricCreateManyPlayerInputEnvelope
    set?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    disconnect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    delete?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    connect?: ActivityMetricWhereUniqueInput | ActivityMetricWhereUniqueInput[]
    update?: ActivityMetricUpdateWithWhereUniqueWithoutPlayerInput | ActivityMetricUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ActivityMetricUpdateManyWithWhereWithoutPlayerInput | ActivityMetricUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ActivityMetricScalarWhereInput | ActivityMetricScalarWhereInput[]
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput> | CoachAssignmentCreateWithoutPlayerInput[] | CoachAssignmentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPlayerInput | CoachAssignmentCreateOrConnectWithoutPlayerInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPlayerInput | CoachAssignmentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CoachAssignmentCreateManyPlayerInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPlayerInput | CoachAssignmentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPlayerInput | CoachAssignmentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput> | EventParticipantCreateWithoutPlayerInput[] | EventParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutPlayerInput | EventParticipantCreateOrConnectWithoutPlayerInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutPlayerInput | EventParticipantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: EventParticipantCreateManyPlayerInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutPlayerInput | EventParticipantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutPlayerInput | EventParticipantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput> | PlayerPodHolderCreateWithoutPlayerInput[] | PlayerPodHolderUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPlayerInput | PlayerPodHolderCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerPodHolderUpsertWithWhereUniqueWithoutPlayerInput | PlayerPodHolderUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerPodHolderCreateManyPlayerInputEnvelope
    set?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    disconnect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    delete?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    update?: PlayerPodHolderUpdateWithWhereUniqueWithoutPlayerInput | PlayerPodHolderUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerPodHolderUpdateManyWithWhereWithoutPlayerInput | PlayerPodHolderUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
  }

  export type PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput> | PlayerPodCreateWithoutPlayerInput[] | PlayerPodUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPlayerInput | PlayerPodCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerPodUpsertWithWhereUniqueWithoutPlayerInput | PlayerPodUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerPodCreateManyPlayerInputEnvelope
    set?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    disconnect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    delete?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    update?: PlayerPodUpdateWithWhereUniqueWithoutPlayerInput | PlayerPodUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerPodUpdateManyWithWhereWithoutPlayerInput | PlayerPodUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
  }

  export type RawDataUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput> | RawDataCreateWithoutPlayerInput[] | RawDataUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPlayerInput | RawDataCreateOrConnectWithoutPlayerInput[]
    upsert?: RawDataUpsertWithWhereUniqueWithoutPlayerInput | RawDataUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RawDataCreateManyPlayerInputEnvelope
    set?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    disconnect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    delete?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    update?: RawDataUpdateWithWhereUniqueWithoutPlayerInput | RawDataUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RawDataUpdateManyWithWhereWithoutPlayerInput | RawDataUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
  }

  export type CoachAssignmentCreateNestedManyWithoutPodInput = {
    create?: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput> | CoachAssignmentCreateWithoutPodInput[] | CoachAssignmentUncheckedCreateWithoutPodInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPodInput | CoachAssignmentCreateOrConnectWithoutPodInput[]
    createMany?: CoachAssignmentCreateManyPodInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type PlayerPodCreateNestedManyWithoutPodInput = {
    create?: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput> | PlayerPodCreateWithoutPodInput[] | PlayerPodUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPodInput | PlayerPodCreateOrConnectWithoutPodInput[]
    createMany?: PlayerPodCreateManyPodInputEnvelope
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
  }

  export type PodAllocationCreateNestedManyWithoutPodInput = {
    create?: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput> | PodAllocationCreateWithoutPodInput[] | PodAllocationUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutPodInput | PodAllocationCreateOrConnectWithoutPodInput[]
    createMany?: PodAllocationCreateManyPodInputEnvelope
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
  }

  export type PodStatusCreateNestedManyWithoutPodInput = {
    create?: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput> | PodStatusCreateWithoutPodInput[] | PodStatusUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodStatusCreateOrConnectWithoutPodInput | PodStatusCreateOrConnectWithoutPodInput[]
    createMany?: PodStatusCreateManyPodInputEnvelope
    connect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
  }

  export type RawDataCreateNestedManyWithoutPodInput = {
    create?: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput> | RawDataCreateWithoutPodInput[] | RawDataUncheckedCreateWithoutPodInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPodInput | RawDataCreateOrConnectWithoutPodInput[]
    createMany?: RawDataCreateManyPodInputEnvelope
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
  }

  export type CoachAssignmentUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput> | CoachAssignmentCreateWithoutPodInput[] | CoachAssignmentUncheckedCreateWithoutPodInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPodInput | CoachAssignmentCreateOrConnectWithoutPodInput[]
    createMany?: CoachAssignmentCreateManyPodInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type PlayerPodUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput> | PlayerPodCreateWithoutPodInput[] | PlayerPodUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPodInput | PlayerPodCreateOrConnectWithoutPodInput[]
    createMany?: PlayerPodCreateManyPodInputEnvelope
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
  }

  export type PodAllocationUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput> | PodAllocationCreateWithoutPodInput[] | PodAllocationUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutPodInput | PodAllocationCreateOrConnectWithoutPodInput[]
    createMany?: PodAllocationCreateManyPodInputEnvelope
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
  }

  export type PodStatusUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput> | PodStatusCreateWithoutPodInput[] | PodStatusUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodStatusCreateOrConnectWithoutPodInput | PodStatusCreateOrConnectWithoutPodInput[]
    createMany?: PodStatusCreateManyPodInputEnvelope
    connect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
  }

  export type RawDataUncheckedCreateNestedManyWithoutPodInput = {
    create?: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput> | RawDataCreateWithoutPodInput[] | RawDataUncheckedCreateWithoutPodInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPodInput | RawDataCreateOrConnectWithoutPodInput[]
    createMany?: RawDataCreateManyPodInputEnvelope
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
  }

  export type CoachAssignmentUpdateManyWithoutPodNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput> | CoachAssignmentCreateWithoutPodInput[] | CoachAssignmentUncheckedCreateWithoutPodInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPodInput | CoachAssignmentCreateOrConnectWithoutPodInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPodInput | CoachAssignmentUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: CoachAssignmentCreateManyPodInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPodInput | CoachAssignmentUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPodInput | CoachAssignmentUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type PlayerPodUpdateManyWithoutPodNestedInput = {
    create?: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput> | PlayerPodCreateWithoutPodInput[] | PlayerPodUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPodInput | PlayerPodCreateOrConnectWithoutPodInput[]
    upsert?: PlayerPodUpsertWithWhereUniqueWithoutPodInput | PlayerPodUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PlayerPodCreateManyPodInputEnvelope
    set?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    disconnect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    delete?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    update?: PlayerPodUpdateWithWhereUniqueWithoutPodInput | PlayerPodUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PlayerPodUpdateManyWithWhereWithoutPodInput | PlayerPodUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
  }

  export type PodAllocationUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput> | PodAllocationCreateWithoutPodInput[] | PodAllocationUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutPodInput | PodAllocationCreateOrConnectWithoutPodInput[]
    upsert?: PodAllocationUpsertWithWhereUniqueWithoutPodInput | PodAllocationUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodAllocationCreateManyPodInputEnvelope
    set?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    disconnect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    delete?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    update?: PodAllocationUpdateWithWhereUniqueWithoutPodInput | PodAllocationUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodAllocationUpdateManyWithWhereWithoutPodInput | PodAllocationUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
  }

  export type PodStatusUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput> | PodStatusCreateWithoutPodInput[] | PodStatusUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodStatusCreateOrConnectWithoutPodInput | PodStatusCreateOrConnectWithoutPodInput[]
    upsert?: PodStatusUpsertWithWhereUniqueWithoutPodInput | PodStatusUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodStatusCreateManyPodInputEnvelope
    set?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    disconnect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    delete?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    connect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    update?: PodStatusUpdateWithWhereUniqueWithoutPodInput | PodStatusUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodStatusUpdateManyWithWhereWithoutPodInput | PodStatusUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodStatusScalarWhereInput | PodStatusScalarWhereInput[]
  }

  export type RawDataUpdateManyWithoutPodNestedInput = {
    create?: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput> | RawDataCreateWithoutPodInput[] | RawDataUncheckedCreateWithoutPodInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPodInput | RawDataCreateOrConnectWithoutPodInput[]
    upsert?: RawDataUpsertWithWhereUniqueWithoutPodInput | RawDataUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: RawDataCreateManyPodInputEnvelope
    set?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    disconnect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    delete?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    update?: RawDataUpdateWithWhereUniqueWithoutPodInput | RawDataUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: RawDataUpdateManyWithWhereWithoutPodInput | RawDataUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput> | CoachAssignmentCreateWithoutPodInput[] | CoachAssignmentUncheckedCreateWithoutPodInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPodInput | CoachAssignmentCreateOrConnectWithoutPodInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPodInput | CoachAssignmentUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: CoachAssignmentCreateManyPodInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPodInput | CoachAssignmentUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPodInput | CoachAssignmentUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type PlayerPodUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput> | PlayerPodCreateWithoutPodInput[] | PlayerPodUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PlayerPodCreateOrConnectWithoutPodInput | PlayerPodCreateOrConnectWithoutPodInput[]
    upsert?: PlayerPodUpsertWithWhereUniqueWithoutPodInput | PlayerPodUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PlayerPodCreateManyPodInputEnvelope
    set?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    disconnect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    delete?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    connect?: PlayerPodWhereUniqueInput | PlayerPodWhereUniqueInput[]
    update?: PlayerPodUpdateWithWhereUniqueWithoutPodInput | PlayerPodUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PlayerPodUpdateManyWithWhereWithoutPodInput | PlayerPodUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
  }

  export type PodAllocationUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput> | PodAllocationCreateWithoutPodInput[] | PodAllocationUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodAllocationCreateOrConnectWithoutPodInput | PodAllocationCreateOrConnectWithoutPodInput[]
    upsert?: PodAllocationUpsertWithWhereUniqueWithoutPodInput | PodAllocationUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodAllocationCreateManyPodInputEnvelope
    set?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    disconnect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    delete?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    connect?: PodAllocationWhereUniqueInput | PodAllocationWhereUniqueInput[]
    update?: PodAllocationUpdateWithWhereUniqueWithoutPodInput | PodAllocationUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodAllocationUpdateManyWithWhereWithoutPodInput | PodAllocationUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
  }

  export type PodStatusUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput> | PodStatusCreateWithoutPodInput[] | PodStatusUncheckedCreateWithoutPodInput[]
    connectOrCreate?: PodStatusCreateOrConnectWithoutPodInput | PodStatusCreateOrConnectWithoutPodInput[]
    upsert?: PodStatusUpsertWithWhereUniqueWithoutPodInput | PodStatusUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: PodStatusCreateManyPodInputEnvelope
    set?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    disconnect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    delete?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    connect?: PodStatusWhereUniqueInput | PodStatusWhereUniqueInput[]
    update?: PodStatusUpdateWithWhereUniqueWithoutPodInput | PodStatusUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: PodStatusUpdateManyWithWhereWithoutPodInput | PodStatusUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: PodStatusScalarWhereInput | PodStatusScalarWhereInput[]
  }

  export type RawDataUncheckedUpdateManyWithoutPodNestedInput = {
    create?: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput> | RawDataCreateWithoutPodInput[] | RawDataUncheckedCreateWithoutPodInput[]
    connectOrCreate?: RawDataCreateOrConnectWithoutPodInput | RawDataCreateOrConnectWithoutPodInput[]
    upsert?: RawDataUpsertWithWhereUniqueWithoutPodInput | RawDataUpsertWithWhereUniqueWithoutPodInput[]
    createMany?: RawDataCreateManyPodInputEnvelope
    set?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    disconnect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    delete?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    connect?: RawDataWhereUniqueInput | RawDataWhereUniqueInput[]
    update?: RawDataUpdateWithWhereUniqueWithoutPodInput | RawDataUpdateWithWhereUniqueWithoutPodInput[]
    updateMany?: RawDataUpdateManyWithWhereWithoutPodInput | RawDataUpdateManyWithWhereWithoutPodInput[]
    deleteMany?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
  }

  export type ClubCreateNestedOneWithoutPod_holdersInput = {
    create?: XOR<ClubCreateWithoutPod_holdersInput, ClubUncheckedCreateWithoutPod_holdersInput>
    connectOrCreate?: ClubCreateOrConnectWithoutPod_holdersInput
    connect?: ClubWhereUniqueInput
  }

  export type PodHolderAuditCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput> | PodHolderAuditCreateWithoutPod_holderInput[] | PodHolderAuditUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderAuditCreateOrConnectWithoutPod_holderInput | PodHolderAuditCreateOrConnectWithoutPod_holderInput[]
    createMany?: PodHolderAuditCreateManyPod_holderInputEnvelope
    connect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
  }

  export type CoachAssignmentCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput> | CoachAssignmentCreateWithoutPod_holderInput[] | CoachAssignmentUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPod_holderInput | CoachAssignmentCreateOrConnectWithoutPod_holderInput[]
    createMany?: CoachAssignmentCreateManyPod_holderInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type PlayerPodHolderCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput> | PlayerPodHolderCreateWithoutPod_holderInput[] | PlayerPodHolderUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPod_holderInput | PlayerPodHolderCreateOrConnectWithoutPod_holderInput[]
    createMany?: PlayerPodHolderCreateManyPod_holderInputEnvelope
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
  }

  export type PodHolderStatusCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput> | PodHolderStatusCreateWithoutPod_holderInput[] | PodHolderStatusUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderStatusCreateOrConnectWithoutPod_holderInput | PodHolderStatusCreateOrConnectWithoutPod_holderInput[]
    createMany?: PodHolderStatusCreateManyPod_holderInputEnvelope
    connect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
  }

  export type PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput> | PodHolderAuditCreateWithoutPod_holderInput[] | PodHolderAuditUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderAuditCreateOrConnectWithoutPod_holderInput | PodHolderAuditCreateOrConnectWithoutPod_holderInput[]
    createMany?: PodHolderAuditCreateManyPod_holderInputEnvelope
    connect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
  }

  export type CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput> | CoachAssignmentCreateWithoutPod_holderInput[] | CoachAssignmentUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPod_holderInput | CoachAssignmentCreateOrConnectWithoutPod_holderInput[]
    createMany?: CoachAssignmentCreateManyPod_holderInputEnvelope
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
  }

  export type PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput> | PlayerPodHolderCreateWithoutPod_holderInput[] | PlayerPodHolderUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPod_holderInput | PlayerPodHolderCreateOrConnectWithoutPod_holderInput[]
    createMany?: PlayerPodHolderCreateManyPod_holderInputEnvelope
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
  }

  export type PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput = {
    create?: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput> | PodHolderStatusCreateWithoutPod_holderInput[] | PodHolderStatusUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderStatusCreateOrConnectWithoutPod_holderInput | PodHolderStatusCreateOrConnectWithoutPod_holderInput[]
    createMany?: PodHolderStatusCreateManyPod_holderInputEnvelope
    connect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
  }

  export type ClubUpdateOneWithoutPod_holdersNestedInput = {
    create?: XOR<ClubCreateWithoutPod_holdersInput, ClubUncheckedCreateWithoutPod_holdersInput>
    connectOrCreate?: ClubCreateOrConnectWithoutPod_holdersInput
    upsert?: ClubUpsertWithoutPod_holdersInput
    disconnect?: ClubWhereInput | boolean
    delete?: ClubWhereInput | boolean
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutPod_holdersInput, ClubUpdateWithoutPod_holdersInput>, ClubUncheckedUpdateWithoutPod_holdersInput>
  }

  export type PodHolderAuditUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput> | PodHolderAuditCreateWithoutPod_holderInput[] | PodHolderAuditUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderAuditCreateOrConnectWithoutPod_holderInput | PodHolderAuditCreateOrConnectWithoutPod_holderInput[]
    upsert?: PodHolderAuditUpsertWithWhereUniqueWithoutPod_holderInput | PodHolderAuditUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PodHolderAuditCreateManyPod_holderInputEnvelope
    set?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    disconnect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    delete?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    connect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    update?: PodHolderAuditUpdateWithWhereUniqueWithoutPod_holderInput | PodHolderAuditUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PodHolderAuditUpdateManyWithWhereWithoutPod_holderInput | PodHolderAuditUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PodHolderAuditScalarWhereInput | PodHolderAuditScalarWhereInput[]
  }

  export type CoachAssignmentUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput> | CoachAssignmentCreateWithoutPod_holderInput[] | CoachAssignmentUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPod_holderInput | CoachAssignmentCreateOrConnectWithoutPod_holderInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPod_holderInput | CoachAssignmentUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: CoachAssignmentCreateManyPod_holderInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPod_holderInput | CoachAssignmentUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPod_holderInput | CoachAssignmentUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type PlayerPodHolderUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput> | PlayerPodHolderCreateWithoutPod_holderInput[] | PlayerPodHolderUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPod_holderInput | PlayerPodHolderCreateOrConnectWithoutPod_holderInput[]
    upsert?: PlayerPodHolderUpsertWithWhereUniqueWithoutPod_holderInput | PlayerPodHolderUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PlayerPodHolderCreateManyPod_holderInputEnvelope
    set?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    disconnect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    delete?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    update?: PlayerPodHolderUpdateWithWhereUniqueWithoutPod_holderInput | PlayerPodHolderUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PlayerPodHolderUpdateManyWithWhereWithoutPod_holderInput | PlayerPodHolderUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
  }

  export type PodHolderStatusUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput> | PodHolderStatusCreateWithoutPod_holderInput[] | PodHolderStatusUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderStatusCreateOrConnectWithoutPod_holderInput | PodHolderStatusCreateOrConnectWithoutPod_holderInput[]
    upsert?: PodHolderStatusUpsertWithWhereUniqueWithoutPod_holderInput | PodHolderStatusUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PodHolderStatusCreateManyPod_holderInputEnvelope
    set?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    disconnect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    delete?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    connect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    update?: PodHolderStatusUpdateWithWhereUniqueWithoutPod_holderInput | PodHolderStatusUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PodHolderStatusUpdateManyWithWhereWithoutPod_holderInput | PodHolderStatusUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PodHolderStatusScalarWhereInput | PodHolderStatusScalarWhereInput[]
  }

  export type PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput> | PodHolderAuditCreateWithoutPod_holderInput[] | PodHolderAuditUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderAuditCreateOrConnectWithoutPod_holderInput | PodHolderAuditCreateOrConnectWithoutPod_holderInput[]
    upsert?: PodHolderAuditUpsertWithWhereUniqueWithoutPod_holderInput | PodHolderAuditUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PodHolderAuditCreateManyPod_holderInputEnvelope
    set?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    disconnect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    delete?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    connect?: PodHolderAuditWhereUniqueInput | PodHolderAuditWhereUniqueInput[]
    update?: PodHolderAuditUpdateWithWhereUniqueWithoutPod_holderInput | PodHolderAuditUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PodHolderAuditUpdateManyWithWhereWithoutPod_holderInput | PodHolderAuditUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PodHolderAuditScalarWhereInput | PodHolderAuditScalarWhereInput[]
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput> | CoachAssignmentCreateWithoutPod_holderInput[] | CoachAssignmentUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: CoachAssignmentCreateOrConnectWithoutPod_holderInput | CoachAssignmentCreateOrConnectWithoutPod_holderInput[]
    upsert?: CoachAssignmentUpsertWithWhereUniqueWithoutPod_holderInput | CoachAssignmentUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: CoachAssignmentCreateManyPod_holderInputEnvelope
    set?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    disconnect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    delete?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    connect?: CoachAssignmentWhereUniqueInput | CoachAssignmentWhereUniqueInput[]
    update?: CoachAssignmentUpdateWithWhereUniqueWithoutPod_holderInput | CoachAssignmentUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: CoachAssignmentUpdateManyWithWhereWithoutPod_holderInput | CoachAssignmentUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
  }

  export type PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput> | PlayerPodHolderCreateWithoutPod_holderInput[] | PlayerPodHolderUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PlayerPodHolderCreateOrConnectWithoutPod_holderInput | PlayerPodHolderCreateOrConnectWithoutPod_holderInput[]
    upsert?: PlayerPodHolderUpsertWithWhereUniqueWithoutPod_holderInput | PlayerPodHolderUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PlayerPodHolderCreateManyPod_holderInputEnvelope
    set?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    disconnect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    delete?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    connect?: PlayerPodHolderWhereUniqueInput | PlayerPodHolderWhereUniqueInput[]
    update?: PlayerPodHolderUpdateWithWhereUniqueWithoutPod_holderInput | PlayerPodHolderUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PlayerPodHolderUpdateManyWithWhereWithoutPod_holderInput | PlayerPodHolderUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
  }

  export type PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput = {
    create?: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput> | PodHolderStatusCreateWithoutPod_holderInput[] | PodHolderStatusUncheckedCreateWithoutPod_holderInput[]
    connectOrCreate?: PodHolderStatusCreateOrConnectWithoutPod_holderInput | PodHolderStatusCreateOrConnectWithoutPod_holderInput[]
    upsert?: PodHolderStatusUpsertWithWhereUniqueWithoutPod_holderInput | PodHolderStatusUpsertWithWhereUniqueWithoutPod_holderInput[]
    createMany?: PodHolderStatusCreateManyPod_holderInputEnvelope
    set?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    disconnect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    delete?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    connect?: PodHolderStatusWhereUniqueInput | PodHolderStatusWhereUniqueInput[]
    update?: PodHolderStatusUpdateWithWhereUniqueWithoutPod_holderInput | PodHolderStatusUpdateWithWhereUniqueWithoutPod_holderInput[]
    updateMany?: PodHolderStatusUpdateManyWithWhereWithoutPod_holderInput | PodHolderStatusUpdateManyWithWhereWithoutPod_holderInput[]
    deleteMany?: PodHolderStatusScalarWhereInput | PodHolderStatusScalarWhereInput[]
  }

  export type PodHolderCreateNestedOneWithoutAuditsInput = {
    create?: XOR<PodHolderCreateWithoutAuditsInput, PodHolderUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutAuditsInput
    connect?: PodHolderWhereUniqueInput
  }

  export type PodHolderUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<PodHolderCreateWithoutAuditsInput, PodHolderUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutAuditsInput
    upsert?: PodHolderUpsertWithoutAuditsInput
    connect?: PodHolderWhereUniqueInput
    update?: XOR<XOR<PodHolderUpdateToOneWithWhereWithoutAuditsInput, PodHolderUpdateWithoutAuditsInput>, PodHolderUncheckedUpdateWithoutAuditsInput>
  }

  export type CoachCreateNestedOneWithoutPod_allocationsInput = {
    create?: XOR<CoachCreateWithoutPod_allocationsInput, CoachUncheckedCreateWithoutPod_allocationsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutPod_allocationsInput
    connect?: CoachWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutPod_allocationsInput = {
    create?: XOR<PodCreateWithoutPod_allocationsInput, PodUncheckedCreateWithoutPod_allocationsInput>
    connectOrCreate?: PodCreateOrConnectWithoutPod_allocationsInput
    connect?: PodWhereUniqueInput
  }

  export type CoachUpdateOneWithoutPod_allocationsNestedInput = {
    create?: XOR<CoachCreateWithoutPod_allocationsInput, CoachUncheckedCreateWithoutPod_allocationsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutPod_allocationsInput
    upsert?: CoachUpsertWithoutPod_allocationsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutPod_allocationsInput, CoachUpdateWithoutPod_allocationsInput>, CoachUncheckedUpdateWithoutPod_allocationsInput>
  }

  export type PodUpdateOneRequiredWithoutPod_allocationsNestedInput = {
    create?: XOR<PodCreateWithoutPod_allocationsInput, PodUncheckedCreateWithoutPod_allocationsInput>
    connectOrCreate?: PodCreateOrConnectWithoutPod_allocationsInput
    upsert?: PodUpsertWithoutPod_allocationsInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutPod_allocationsInput, PodUpdateWithoutPod_allocationsInput>, PodUncheckedUpdateWithoutPod_allocationsInput>
  }

  export type CoachCreateNestedOneWithoutCoach_assignmentsInput = {
    create?: XOR<CoachCreateWithoutCoach_assignmentsInput, CoachUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCoach_assignmentsInput
    connect?: CoachWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutCoach_assignmentsInput = {
    create?: XOR<PlayerCreateWithoutCoach_assignmentsInput, PlayerUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCoach_assignmentsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PodHolderCreateNestedOneWithoutCoach_assignmentsInput = {
    create?: XOR<PodHolderCreateWithoutCoach_assignmentsInput, PodHolderUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutCoach_assignmentsInput
    connect?: PodHolderWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutCoach_assignmentsInput = {
    create?: XOR<PodCreateWithoutCoach_assignmentsInput, PodUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PodCreateOrConnectWithoutCoach_assignmentsInput
    connect?: PodWhereUniqueInput
  }

  export type CoachUpdateOneWithoutCoach_assignmentsNestedInput = {
    create?: XOR<CoachCreateWithoutCoach_assignmentsInput, CoachUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCoach_assignmentsInput
    upsert?: CoachUpsertWithoutCoach_assignmentsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutCoach_assignmentsInput, CoachUpdateWithoutCoach_assignmentsInput>, CoachUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PlayerUpdateOneWithoutCoach_assignmentsNestedInput = {
    create?: XOR<PlayerCreateWithoutCoach_assignmentsInput, PlayerUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCoach_assignmentsInput
    upsert?: PlayerUpsertWithoutCoach_assignmentsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCoach_assignmentsInput, PlayerUpdateWithoutCoach_assignmentsInput>, PlayerUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PodHolderUpdateOneWithoutCoach_assignmentsNestedInput = {
    create?: XOR<PodHolderCreateWithoutCoach_assignmentsInput, PodHolderUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutCoach_assignmentsInput
    upsert?: PodHolderUpsertWithoutCoach_assignmentsInput
    disconnect?: PodHolderWhereInput | boolean
    delete?: PodHolderWhereInput | boolean
    connect?: PodHolderWhereUniqueInput
    update?: XOR<XOR<PodHolderUpdateToOneWithWhereWithoutCoach_assignmentsInput, PodHolderUpdateWithoutCoach_assignmentsInput>, PodHolderUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PodUpdateOneWithoutCoach_assignmentsNestedInput = {
    create?: XOR<PodCreateWithoutCoach_assignmentsInput, PodUncheckedCreateWithoutCoach_assignmentsInput>
    connectOrCreate?: PodCreateOrConnectWithoutCoach_assignmentsInput
    upsert?: PodUpsertWithoutCoach_assignmentsInput
    disconnect?: PodWhereInput | boolean
    delete?: PodWhereInput | boolean
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutCoach_assignmentsInput, PodUpdateWithoutCoach_assignmentsInput>, PodUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_podsInput = {
    create?: XOR<PlayerCreateWithoutPlayer_podsInput, PlayerUncheckedCreateWithoutPlayer_podsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_podsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutPlayer_podsInput = {
    create?: XOR<PodCreateWithoutPlayer_podsInput, PodUncheckedCreateWithoutPlayer_podsInput>
    connectOrCreate?: PodCreateOrConnectWithoutPlayer_podsInput
    connect?: PodWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_podsNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_podsInput, PlayerUncheckedCreateWithoutPlayer_podsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_podsInput
    upsert?: PlayerUpsertWithoutPlayer_podsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPlayer_podsInput, PlayerUpdateWithoutPlayer_podsInput>, PlayerUncheckedUpdateWithoutPlayer_podsInput>
  }

  export type PodUpdateOneRequiredWithoutPlayer_podsNestedInput = {
    create?: XOR<PodCreateWithoutPlayer_podsInput, PodUncheckedCreateWithoutPlayer_podsInput>
    connectOrCreate?: PodCreateOrConnectWithoutPlayer_podsInput
    upsert?: PodUpsertWithoutPlayer_podsInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutPlayer_podsInput, PodUpdateWithoutPlayer_podsInput>, PodUncheckedUpdateWithoutPlayer_podsInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_pod_holdersInput = {
    create?: XOR<PlayerCreateWithoutPlayer_pod_holdersInput, PlayerUncheckedCreateWithoutPlayer_pod_holdersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_pod_holdersInput
    connect?: PlayerWhereUniqueInput
  }

  export type PodHolderCreateNestedOneWithoutPlayer_pod_holdersInput = {
    create?: XOR<PodHolderCreateWithoutPlayer_pod_holdersInput, PodHolderUncheckedCreateWithoutPlayer_pod_holdersInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutPlayer_pod_holdersInput
    connect?: PodHolderWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_pod_holdersInput, PlayerUncheckedCreateWithoutPlayer_pod_holdersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_pod_holdersInput
    upsert?: PlayerUpsertWithoutPlayer_pod_holdersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPlayer_pod_holdersInput, PlayerUpdateWithoutPlayer_pod_holdersInput>, PlayerUncheckedUpdateWithoutPlayer_pod_holdersInput>
  }

  export type PodHolderUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput = {
    create?: XOR<PodHolderCreateWithoutPlayer_pod_holdersInput, PodHolderUncheckedCreateWithoutPlayer_pod_holdersInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutPlayer_pod_holdersInput
    upsert?: PodHolderUpsertWithoutPlayer_pod_holdersInput
    connect?: PodHolderWhereUniqueInput
    update?: XOR<XOR<PodHolderUpdateToOneWithWhereWithoutPlayer_pod_holdersInput, PodHolderUpdateWithoutPlayer_pod_holdersInput>, PodHolderUncheckedUpdateWithoutPlayer_pod_holdersInput>
  }

  export type PodCreateNestedOneWithoutPod_statusesInput = {
    create?: XOR<PodCreateWithoutPod_statusesInput, PodUncheckedCreateWithoutPod_statusesInput>
    connectOrCreate?: PodCreateOrConnectWithoutPod_statusesInput
    connect?: PodWhereUniqueInput
  }

  export type PodUpdateOneRequiredWithoutPod_statusesNestedInput = {
    create?: XOR<PodCreateWithoutPod_statusesInput, PodUncheckedCreateWithoutPod_statusesInput>
    connectOrCreate?: PodCreateOrConnectWithoutPod_statusesInput
    upsert?: PodUpsertWithoutPod_statusesInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutPod_statusesInput, PodUpdateWithoutPod_statusesInput>, PodUncheckedUpdateWithoutPod_statusesInput>
  }

  export type PodHolderCreateNestedOneWithoutPod_holder_statusesInput = {
    create?: XOR<PodHolderCreateWithoutPod_holder_statusesInput, PodHolderUncheckedCreateWithoutPod_holder_statusesInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutPod_holder_statusesInput
    connect?: PodHolderWhereUniqueInput
  }

  export type PodHolderUpdateOneRequiredWithoutPod_holder_statusesNestedInput = {
    create?: XOR<PodHolderCreateWithoutPod_holder_statusesInput, PodHolderUncheckedCreateWithoutPod_holder_statusesInput>
    connectOrCreate?: PodHolderCreateOrConnectWithoutPod_holder_statusesInput
    upsert?: PodHolderUpsertWithoutPod_holder_statusesInput
    connect?: PodHolderWhereUniqueInput
    update?: XOR<XOR<PodHolderUpdateToOneWithWhereWithoutPod_holder_statusesInput, PodHolderUpdateWithoutPod_holder_statusesInput>, PodHolderUncheckedUpdateWithoutPod_holder_statusesInput>
  }

  export type PlayerCreateNestedOneWithoutRaw_dataInput = {
    create?: XOR<PlayerCreateWithoutRaw_dataInput, PlayerUncheckedCreateWithoutRaw_dataInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRaw_dataInput
    connect?: PlayerWhereUniqueInput
  }

  export type PodCreateNestedOneWithoutRaw_dataInput = {
    create?: XOR<PodCreateWithoutRaw_dataInput, PodUncheckedCreateWithoutRaw_dataInput>
    connectOrCreate?: PodCreateOrConnectWithoutRaw_dataInput
    connect?: PodWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlayerUpdateOneWithoutRaw_dataNestedInput = {
    create?: XOR<PlayerCreateWithoutRaw_dataInput, PlayerUncheckedCreateWithoutRaw_dataInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRaw_dataInput
    upsert?: PlayerUpsertWithoutRaw_dataInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRaw_dataInput, PlayerUpdateWithoutRaw_dataInput>, PlayerUncheckedUpdateWithoutRaw_dataInput>
  }

  export type PodUpdateOneRequiredWithoutRaw_dataNestedInput = {
    create?: XOR<PodCreateWithoutRaw_dataInput, PodUncheckedCreateWithoutRaw_dataInput>
    connectOrCreate?: PodCreateOrConnectWithoutRaw_dataInput
    upsert?: PodUpsertWithoutRaw_dataInput
    connect?: PodWhereUniqueInput
    update?: XOR<XOR<PodUpdateToOneWithWhereWithoutRaw_dataInput, PodUpdateWithoutRaw_dataInput>, PodUncheckedUpdateWithoutRaw_dataInput>
  }

  export type EventParticipantCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type ClubCreateNestedOneWithoutEventsInput = {
    create?: XOR<ClubCreateWithoutEventsInput, ClubUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutEventsInput
    connect?: ClubWhereUniqueInput
  }

  export type EventParticipantUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
  }

  export type EventParticipantUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutEventInput | EventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutEventInput | EventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutEventInput | EventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type ClubUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ClubCreateWithoutEventsInput, ClubUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutEventsInput
    upsert?: ClubUpsertWithoutEventsInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutEventsInput, ClubUpdateWithoutEventsInput>, ClubUncheckedUpdateWithoutEventsInput>
  }

  export type EventParticipantUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput> | EventParticipantCreateWithoutEventInput[] | EventParticipantUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipantCreateOrConnectWithoutEventInput | EventParticipantCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipantUpsertWithWhereUniqueWithoutEventInput | EventParticipantUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipantCreateManyEventInputEnvelope
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    disconnect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    delete?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    connect?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[]
    update?: EventParticipantUpdateWithWhereUniqueWithoutEventInput | EventParticipantUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipantUpdateManyWithWhereWithoutEventInput | EventParticipantUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
  }

  export type CoachCreateNestedOneWithoutEvent_participantsInput = {
    create?: XOR<CoachCreateWithoutEvent_participantsInput, CoachUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutEvent_participantsInput
    connect?: CoachWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutEvent_participantsInput = {
    create?: XOR<EventCreateWithoutEvent_participantsInput, EventUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEvent_participantsInput
    connect?: EventWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutEvent_participantsInput = {
    create?: XOR<PlayerCreateWithoutEvent_participantsInput, PlayerUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEvent_participantsInput
    connect?: PlayerWhereUniqueInput
  }

  export type CoachUpdateOneWithoutEvent_participantsNestedInput = {
    create?: XOR<CoachCreateWithoutEvent_participantsInput, CoachUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutEvent_participantsInput
    upsert?: CoachUpsertWithoutEvent_participantsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutEvent_participantsInput, CoachUpdateWithoutEvent_participantsInput>, CoachUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type EventUpdateOneRequiredWithoutEvent_participantsNestedInput = {
    create?: XOR<EventCreateWithoutEvent_participantsInput, EventUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEvent_participantsInput
    upsert?: EventUpsertWithoutEvent_participantsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEvent_participantsInput, EventUpdateWithoutEvent_participantsInput>, EventUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type PlayerUpdateOneWithoutEvent_participantsNestedInput = {
    create?: XOR<PlayerCreateWithoutEvent_participantsInput, PlayerUncheckedCreateWithoutEvent_participantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEvent_participantsInput
    upsert?: PlayerUpsertWithoutEvent_participantsInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutEvent_participantsInput, PlayerUpdateWithoutEvent_participantsInput>, PlayerUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ClubCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ClubCreateWithoutSubscriptionsInput, ClubUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutSubscriptionsInput
    connect?: ClubWhereUniqueInput
  }

  export type PaymentPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PaymentPlanCreateWithoutSubscriptionsInput, PaymentPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PaymentPlanWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ClubUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ClubCreateWithoutSubscriptionsInput, ClubUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutSubscriptionsInput
    upsert?: ClubUpsertWithoutSubscriptionsInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutSubscriptionsInput, ClubUpdateWithoutSubscriptionsInput>, ClubUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentPlanUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<PaymentPlanCreateWithoutSubscriptionsInput, PaymentPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PaymentPlanUpsertWithoutSubscriptionsInput
    disconnect?: PaymentPlanWhereInput | boolean
    delete?: PaymentPlanWhereInput | boolean
    connect?: PaymentPlanWhereUniqueInput
    update?: XOR<XOR<PaymentPlanUpdateToOneWithWhereWithoutSubscriptionsInput, PaymentPlanUpdateWithoutSubscriptionsInput>, PaymentPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type ClubCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<ClubCreateWithoutServiceRequestsInput, ClubUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutServiceRequestsInput
    connect?: ClubWhereUniqueInput
  }

  export type ClubUpdateOneWithoutServiceRequestsNestedInput = {
    create?: XOR<ClubCreateWithoutServiceRequestsInput, ClubUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: ClubCreateOrConnectWithoutServiceRequestsInput
    upsert?: ClubUpsertWithoutServiceRequestsInput
    disconnect?: ClubWhereInput | boolean
    delete?: ClubWhereInput | boolean
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutServiceRequestsInput, ClubUpdateWithoutServiceRequestsInput>, ClubUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type PlayerCreateNestedOneWithoutActivity_metricsInput = {
    create?: XOR<PlayerCreateWithoutActivity_metricsInput, PlayerUncheckedCreateWithoutActivity_metricsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutActivity_metricsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutActivity_metricsNestedInput = {
    create?: XOR<PlayerCreateWithoutActivity_metricsInput, PlayerUncheckedCreateWithoutActivity_metricsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutActivity_metricsInput
    upsert?: PlayerUpsertWithoutActivity_metricsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutActivity_metricsInput, PlayerUpdateWithoutActivity_metricsInput>, PlayerUncheckedUpdateWithoutActivity_metricsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ClubCreateWithoutSuper_adminInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutSuper_adminInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutSuper_adminInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput>
  }

  export type ClubCreateManySuper_adminInputEnvelope = {
    data: ClubCreateManySuper_adminInput | ClubCreateManySuper_adminInput[]
    skipDuplicates?: boolean
  }

  export type ClubUpsertWithWhereUniqueWithoutSuper_adminInput = {
    where: ClubWhereUniqueInput
    update: XOR<ClubUpdateWithoutSuper_adminInput, ClubUncheckedUpdateWithoutSuper_adminInput>
    create: XOR<ClubCreateWithoutSuper_adminInput, ClubUncheckedCreateWithoutSuper_adminInput>
  }

  export type ClubUpdateWithWhereUniqueWithoutSuper_adminInput = {
    where: ClubWhereUniqueInput
    data: XOR<ClubUpdateWithoutSuper_adminInput, ClubUncheckedUpdateWithoutSuper_adminInput>
  }

  export type ClubUpdateManyWithWhereWithoutSuper_adminInput = {
    where: ClubScalarWhereInput
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyWithoutSuper_adminInput>
  }

  export type ClubScalarWhereInput = {
    AND?: ClubScalarWhereInput | ClubScalarWhereInput[]
    OR?: ClubScalarWhereInput[]
    NOT?: ClubScalarWhereInput | ClubScalarWhereInput[]
    club_id?: UuidFilter<"Club"> | string
    super_admin_id?: UuidNullableFilter<"Club"> | string | null
    club_name?: StringNullableFilter<"Club"> | string | null
    address?: StringNullableFilter<"Club"> | string | null
    status?: StringNullableFilter<"Club"> | string | null
    created_at?: DateTimeFilter<"Club"> | Date | string
    updated_at?: DateTimeFilter<"Club"> | Date | string
    sport?: StringNullableFilter<"Club"> | string | null
  }

  export type ClubAdminCreateWithoutClubInput = {
    admin_id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type ClubAdminUncheckedCreateWithoutClubInput = {
    admin_id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type ClubAdminCreateOrConnectWithoutClubInput = {
    where: ClubAdminWhereUniqueInput
    create: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput>
  }

  export type ClubAdminCreateManyClubInputEnvelope = {
    data: ClubAdminCreateManyClubInput | ClubAdminCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminCreateWithoutClubsInput = {
    super_admin_id?: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type SuperAdminUncheckedCreateWithoutClubsInput = {
    super_admin_id?: string
    name?: string | null
    email: string
    phone?: string | null
    password_hash: string
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type SuperAdminCreateOrConnectWithoutClubsInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutClubsInput, SuperAdminUncheckedCreateWithoutClubsInput>
  }

  export type PodHolderCreateWithoutClubInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    audits?: PodHolderAuditCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateWithoutClubInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    audits?: PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderCreateOrConnectWithoutClubInput = {
    where: PodHolderWhereUniqueInput
    create: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput>
  }

  export type PodHolderCreateManyClubInputEnvelope = {
    data: PodHolderCreateManyClubInput | PodHolderCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type CoachCreateWithoutClubInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutCoachInput
    event_participants?: EventParticipantCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutClubInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutCoachInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutClubInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput>
  }

  export type CoachCreateManyClubInputEnvelope = {
    data: CoachCreateManyClubInput | CoachCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutClubInput = {
    event_id?: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
    event_participants?: EventParticipantCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutClubInput = {
    event_id?: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutClubInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput>
  }

  export type EventCreateManyClubInputEnvelope = {
    data: EventCreateManyClubInput | EventCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutClubInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutClubInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutClubInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput>
  }

  export type PlayerCreateManyClubInputEnvelope = {
    data: PlayerCreateManyClubInput | PlayerCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutClubInput = {
    request_id?: string
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceRequestUncheckedCreateWithoutClubInput = {
    request_id?: string
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceRequestCreateOrConnectWithoutClubInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput>
  }

  export type ServiceRequestCreateManyClubInputEnvelope = {
    data: ServiceRequestCreateManyClubInput | ServiceRequestCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutClubInput = {
    subscription_id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    plan?: PaymentPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutClubInput = {
    subscription_id?: string
    plan_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutClubInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput>
  }

  export type SubscriptionCreateManyClubInputEnvelope = {
    data: SubscriptionCreateManyClubInput | SubscriptionCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type ClubAdminUpsertWithWhereUniqueWithoutClubInput = {
    where: ClubAdminWhereUniqueInput
    update: XOR<ClubAdminUpdateWithoutClubInput, ClubAdminUncheckedUpdateWithoutClubInput>
    create: XOR<ClubAdminCreateWithoutClubInput, ClubAdminUncheckedCreateWithoutClubInput>
  }

  export type ClubAdminUpdateWithWhereUniqueWithoutClubInput = {
    where: ClubAdminWhereUniqueInput
    data: XOR<ClubAdminUpdateWithoutClubInput, ClubAdminUncheckedUpdateWithoutClubInput>
  }

  export type ClubAdminUpdateManyWithWhereWithoutClubInput = {
    where: ClubAdminScalarWhereInput
    data: XOR<ClubAdminUpdateManyMutationInput, ClubAdminUncheckedUpdateManyWithoutClubInput>
  }

  export type ClubAdminScalarWhereInput = {
    AND?: ClubAdminScalarWhereInput | ClubAdminScalarWhereInput[]
    OR?: ClubAdminScalarWhereInput[]
    NOT?: ClubAdminScalarWhereInput | ClubAdminScalarWhereInput[]
    admin_id?: UuidFilter<"ClubAdmin"> | string
    club_id?: UuidFilter<"ClubAdmin"> | string
    name?: StringNullableFilter<"ClubAdmin"> | string | null
    phone?: StringNullableFilter<"ClubAdmin"> | string | null
    email?: StringNullableFilter<"ClubAdmin"> | string | null
    password_hash?: StringNullableFilter<"ClubAdmin"> | string | null
    profile_image?: StringNullableFilter<"ClubAdmin"> | string | null
    created_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    updated_at?: DateTimeFilter<"ClubAdmin"> | Date | string
    reset_token?: StringNullableFilter<"ClubAdmin"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
    login_otp?: StringNullableFilter<"ClubAdmin"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"ClubAdmin"> | Date | string | null
  }

  export type SuperAdminUpsertWithoutClubsInput = {
    update: XOR<SuperAdminUpdateWithoutClubsInput, SuperAdminUncheckedUpdateWithoutClubsInput>
    create: XOR<SuperAdminCreateWithoutClubsInput, SuperAdminUncheckedCreateWithoutClubsInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutClubsInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutClubsInput, SuperAdminUncheckedUpdateWithoutClubsInput>
  }

  export type SuperAdminUpdateWithoutClubsInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuperAdminUncheckedUpdateWithoutClubsInput = {
    super_admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PodHolderUpsertWithWhereUniqueWithoutClubInput = {
    where: PodHolderWhereUniqueInput
    update: XOR<PodHolderUpdateWithoutClubInput, PodHolderUncheckedUpdateWithoutClubInput>
    create: XOR<PodHolderCreateWithoutClubInput, PodHolderUncheckedCreateWithoutClubInput>
  }

  export type PodHolderUpdateWithWhereUniqueWithoutClubInput = {
    where: PodHolderWhereUniqueInput
    data: XOR<PodHolderUpdateWithoutClubInput, PodHolderUncheckedUpdateWithoutClubInput>
  }

  export type PodHolderUpdateManyWithWhereWithoutClubInput = {
    where: PodHolderScalarWhereInput
    data: XOR<PodHolderUpdateManyMutationInput, PodHolderUncheckedUpdateManyWithoutClubInput>
  }

  export type PodHolderScalarWhereInput = {
    AND?: PodHolderScalarWhereInput | PodHolderScalarWhereInput[]
    OR?: PodHolderScalarWhereInput[]
    NOT?: PodHolderScalarWhereInput | PodHolderScalarWhereInput[]
    pod_holder_id?: UuidFilter<"PodHolder"> | string
    serial_number?: StringNullableFilter<"PodHolder"> | string | null
    model?: StringNullableFilter<"PodHolder"> | string | null
    created_at?: DateTimeFilter<"PodHolder"> | Date | string
    updated_at?: DateTimeFilter<"PodHolder"> | Date | string
    club_id?: UuidNullableFilter<"PodHolder"> | string | null
  }

  export type CoachUpsertWithWhereUniqueWithoutClubInput = {
    where: CoachWhereUniqueInput
    update: XOR<CoachUpdateWithoutClubInput, CoachUncheckedUpdateWithoutClubInput>
    create: XOR<CoachCreateWithoutClubInput, CoachUncheckedCreateWithoutClubInput>
  }

  export type CoachUpdateWithWhereUniqueWithoutClubInput = {
    where: CoachWhereUniqueInput
    data: XOR<CoachUpdateWithoutClubInput, CoachUncheckedUpdateWithoutClubInput>
  }

  export type CoachUpdateManyWithWhereWithoutClubInput = {
    where: CoachScalarWhereInput
    data: XOR<CoachUpdateManyMutationInput, CoachUncheckedUpdateManyWithoutClubInput>
  }

  export type CoachScalarWhereInput = {
    AND?: CoachScalarWhereInput | CoachScalarWhereInput[]
    OR?: CoachScalarWhereInput[]
    NOT?: CoachScalarWhereInput | CoachScalarWhereInput[]
    coach_id?: UuidFilter<"Coach"> | string
    club_id?: UuidFilter<"Coach"> | string
    coach_name?: StringNullableFilter<"Coach"> | string | null
    phone?: StringNullableFilter<"Coach"> | string | null
    email?: StringNullableFilter<"Coach"> | string | null
    password_hash?: StringNullableFilter<"Coach"> | string | null
    role?: StringNullableFilter<"Coach"> | string | null
    coach_image?: StringNullableFilter<"Coach"> | string | null
    location?: StringNullableFilter<"Coach"> | string | null
    created_at?: DateTimeFilter<"Coach"> | Date | string
    updated_at?: DateTimeFilter<"Coach"> | Date | string
    reset_token?: StringNullableFilter<"Coach"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
    login_otp?: StringNullableFilter<"Coach"> | string | null
    login_otp_expires?: DateTimeNullableFilter<"Coach"> | Date | string | null
  }

  export type EventUpsertWithWhereUniqueWithoutClubInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutClubInput, EventUncheckedUpdateWithoutClubInput>
    create: XOR<EventCreateWithoutClubInput, EventUncheckedCreateWithoutClubInput>
  }

  export type EventUpdateWithWhereUniqueWithoutClubInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutClubInput, EventUncheckedUpdateWithoutClubInput>
  }

  export type EventUpdateManyWithWhereWithoutClubInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutClubInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    event_id?: UuidFilter<"Event"> | string
    club_id?: UuidFilter<"Event"> | string
    event_name?: StringNullableFilter<"Event"> | string | null
    event_date?: DateTimeNullableFilter<"Event"> | Date | string | null
    location?: StringNullableFilter<"Event"> | string | null
    event_type?: StringNullableFilter<"Event"> | string | null
    created_at?: DateTimeFilter<"Event"> | Date | string
  }

  export type PlayerUpsertWithWhereUniqueWithoutClubInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutClubInput, PlayerUncheckedUpdateWithoutClubInput>
    create: XOR<PlayerCreateWithoutClubInput, PlayerUncheckedCreateWithoutClubInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutClubInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutClubInput, PlayerUncheckedUpdateWithoutClubInput>
  }

  export type PlayerUpdateManyWithWhereWithoutClubInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutClubInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    player_id?: UuidFilter<"Player"> | string
    club_id?: UuidFilter<"Player"> | string
    player_name?: StringNullableFilter<"Player"> | string | null
    jersey_number?: IntNullableFilter<"Player"> | number | null
    age?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    phone?: StringNullableFilter<"Player"> | string | null
    player_image?: StringNullableFilter<"Player"> | string | null
    created_at?: DateTimeFilter<"Player"> | Date | string
    updated_at?: DateTimeFilter<"Player"> | Date | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutClubInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutClubInput, ServiceRequestUncheckedUpdateWithoutClubInput>
    create: XOR<ServiceRequestCreateWithoutClubInput, ServiceRequestUncheckedCreateWithoutClubInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutClubInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutClubInput, ServiceRequestUncheckedUpdateWithoutClubInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutClubInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutClubInput>
  }

  export type ServiceRequestScalarWhereInput = {
    AND?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    OR?: ServiceRequestScalarWhereInput[]
    NOT?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    request_id?: UuidFilter<"ServiceRequest"> | string
    club_id?: UuidNullableFilter<"ServiceRequest"> | string | null
    requester_id?: StringNullableFilter<"ServiceRequest"> | string | null
    description?: StringNullableFilter<"ServiceRequest"> | string | null
    status?: StringNullableFilter<"ServiceRequest"> | string | null
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutClubInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutClubInput, SubscriptionUncheckedUpdateWithoutClubInput>
    create: XOR<SubscriptionCreateWithoutClubInput, SubscriptionUncheckedCreateWithoutClubInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutClubInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutClubInput, SubscriptionUncheckedUpdateWithoutClubInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutClubInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutClubInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    subscription_id?: UuidFilter<"Subscription"> | string
    club_id?: UuidFilter<"Subscription"> | string
    plan_id?: UuidNullableFilter<"Subscription"> | string | null
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringNullableFilter<"Subscription"> | string | null
    created_at?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type ClubCreateWithoutClub_adminsInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutClub_adminsInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutClub_adminsInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutClub_adminsInput, ClubUncheckedCreateWithoutClub_adminsInput>
  }

  export type ClubUpsertWithoutClub_adminsInput = {
    update: XOR<ClubUpdateWithoutClub_adminsInput, ClubUncheckedUpdateWithoutClub_adminsInput>
    create: XOR<ClubCreateWithoutClub_adminsInput, ClubUncheckedCreateWithoutClub_adminsInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutClub_adminsInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutClub_adminsInput, ClubUncheckedUpdateWithoutClub_adminsInput>
  }

  export type ClubUpdateWithoutClub_adminsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutClub_adminsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type CoachAssignmentCreateWithoutCoachInput = {
    assignment_id?: string
    assigned_at?: Date | string
    player?: PlayerCreateNestedOneWithoutCoach_assignmentsInput
    pod_holder?: PodHolderCreateNestedOneWithoutCoach_assignmentsInput
    pod?: PodCreateNestedOneWithoutCoach_assignmentsInput
  }

  export type CoachAssignmentUncheckedCreateWithoutCoachInput = {
    assignment_id?: string
    pod_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentCreateOrConnectWithoutCoachInput = {
    where: CoachAssignmentWhereUniqueInput
    create: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput>
  }

  export type CoachAssignmentCreateManyCoachInputEnvelope = {
    data: CoachAssignmentCreateManyCoachInput | CoachAssignmentCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutCoachesInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutCoachesInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutCoachesInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutCoachesInput, ClubUncheckedCreateWithoutCoachesInput>
  }

  export type EventParticipantCreateWithoutCoachInput = {
    id?: string
    event: EventCreateNestedOneWithoutEvent_participantsInput
    player?: PlayerCreateNestedOneWithoutEvent_participantsInput
  }

  export type EventParticipantUncheckedCreateWithoutCoachInput = {
    id?: string
    event_id: string
    player_id?: string | null
  }

  export type EventParticipantCreateOrConnectWithoutCoachInput = {
    where: EventParticipantWhereUniqueInput
    create: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput>
  }

  export type EventParticipantCreateManyCoachInputEnvelope = {
    data: EventParticipantCreateManyCoachInput | EventParticipantCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type PodAllocationCreateWithoutCoachInput = {
    allocation_id?: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
    pod: PodCreateNestedOneWithoutPod_allocationsInput
  }

  export type PodAllocationUncheckedCreateWithoutCoachInput = {
    allocation_id?: string
    pod_id: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type PodAllocationCreateOrConnectWithoutCoachInput = {
    where: PodAllocationWhereUniqueInput
    create: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput>
  }

  export type PodAllocationCreateManyCoachInputEnvelope = {
    data: PodAllocationCreateManyCoachInput | PodAllocationCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachAssignmentUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachAssignmentWhereUniqueInput
    update: XOR<CoachAssignmentUpdateWithoutCoachInput, CoachAssignmentUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachAssignmentCreateWithoutCoachInput, CoachAssignmentUncheckedCreateWithoutCoachInput>
  }

  export type CoachAssignmentUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachAssignmentWhereUniqueInput
    data: XOR<CoachAssignmentUpdateWithoutCoachInput, CoachAssignmentUncheckedUpdateWithoutCoachInput>
  }

  export type CoachAssignmentUpdateManyWithWhereWithoutCoachInput = {
    where: CoachAssignmentScalarWhereInput
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachAssignmentScalarWhereInput = {
    AND?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
    OR?: CoachAssignmentScalarWhereInput[]
    NOT?: CoachAssignmentScalarWhereInput | CoachAssignmentScalarWhereInput[]
    assignment_id?: UuidFilter<"CoachAssignment"> | string
    coach_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    pod_holder_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    player_id?: UuidNullableFilter<"CoachAssignment"> | string | null
    assigned_at?: DateTimeFilter<"CoachAssignment"> | Date | string
  }

  export type ClubUpsertWithoutCoachesInput = {
    update: XOR<ClubUpdateWithoutCoachesInput, ClubUncheckedUpdateWithoutCoachesInput>
    create: XOR<ClubCreateWithoutCoachesInput, ClubUncheckedCreateWithoutCoachesInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutCoachesInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutCoachesInput, ClubUncheckedUpdateWithoutCoachesInput>
  }

  export type ClubUpdateWithoutCoachesInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutCoachesInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type EventParticipantUpsertWithWhereUniqueWithoutCoachInput = {
    where: EventParticipantWhereUniqueInput
    update: XOR<EventParticipantUpdateWithoutCoachInput, EventParticipantUncheckedUpdateWithoutCoachInput>
    create: XOR<EventParticipantCreateWithoutCoachInput, EventParticipantUncheckedCreateWithoutCoachInput>
  }

  export type EventParticipantUpdateWithWhereUniqueWithoutCoachInput = {
    where: EventParticipantWhereUniqueInput
    data: XOR<EventParticipantUpdateWithoutCoachInput, EventParticipantUncheckedUpdateWithoutCoachInput>
  }

  export type EventParticipantUpdateManyWithWhereWithoutCoachInput = {
    where: EventParticipantScalarWhereInput
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyWithoutCoachInput>
  }

  export type EventParticipantScalarWhereInput = {
    AND?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
    OR?: EventParticipantScalarWhereInput[]
    NOT?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[]
    id?: UuidFilter<"EventParticipant"> | string
    event_id?: UuidFilter<"EventParticipant"> | string
    coach_id?: UuidNullableFilter<"EventParticipant"> | string | null
    player_id?: UuidNullableFilter<"EventParticipant"> | string | null
  }

  export type PodAllocationUpsertWithWhereUniqueWithoutCoachInput = {
    where: PodAllocationWhereUniqueInput
    update: XOR<PodAllocationUpdateWithoutCoachInput, PodAllocationUncheckedUpdateWithoutCoachInput>
    create: XOR<PodAllocationCreateWithoutCoachInput, PodAllocationUncheckedCreateWithoutCoachInput>
  }

  export type PodAllocationUpdateWithWhereUniqueWithoutCoachInput = {
    where: PodAllocationWhereUniqueInput
    data: XOR<PodAllocationUpdateWithoutCoachInput, PodAllocationUncheckedUpdateWithoutCoachInput>
  }

  export type PodAllocationUpdateManyWithWhereWithoutCoachInput = {
    where: PodAllocationScalarWhereInput
    data: XOR<PodAllocationUpdateManyMutationInput, PodAllocationUncheckedUpdateManyWithoutCoachInput>
  }

  export type PodAllocationScalarWhereInput = {
    AND?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
    OR?: PodAllocationScalarWhereInput[]
    NOT?: PodAllocationScalarWhereInput | PodAllocationScalarWhereInput[]
    allocation_id?: UuidFilter<"PodAllocation"> | string
    coach_id?: UuidNullableFilter<"PodAllocation"> | string | null
    pod_id?: UuidFilter<"PodAllocation"> | string
    battery_level?: IntNullableFilter<"PodAllocation"> | number | null
    health_status?: StringNullableFilter<"PodAllocation"> | string | null
    assigned_at?: DateTimeFilter<"PodAllocation"> | Date | string
  }

  export type ActivityMetricCreateWithoutPlayerInput = {
    id?: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
  }

  export type ActivityMetricUncheckedCreateWithoutPlayerInput = {
    id?: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
  }

  export type ActivityMetricCreateOrConnectWithoutPlayerInput = {
    where: ActivityMetricWhereUniqueInput
    create: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput>
  }

  export type ActivityMetricCreateManyPlayerInputEnvelope = {
    data: ActivityMetricCreateManyPlayerInput | ActivityMetricCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type CoachAssignmentCreateWithoutPlayerInput = {
    assignment_id?: string
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutCoach_assignmentsInput
    pod_holder?: PodHolderCreateNestedOneWithoutCoach_assignmentsInput
    pod?: PodCreateNestedOneWithoutCoach_assignmentsInput
  }

  export type CoachAssignmentUncheckedCreateWithoutPlayerInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    pod_holder_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentCreateOrConnectWithoutPlayerInput = {
    where: CoachAssignmentWhereUniqueInput
    create: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput>
  }

  export type CoachAssignmentCreateManyPlayerInputEnvelope = {
    data: CoachAssignmentCreateManyPlayerInput | CoachAssignmentCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type EventParticipantCreateWithoutPlayerInput = {
    id?: string
    coach?: CoachCreateNestedOneWithoutEvent_participantsInput
    event: EventCreateNestedOneWithoutEvent_participantsInput
  }

  export type EventParticipantUncheckedCreateWithoutPlayerInput = {
    id?: string
    event_id: string
    coach_id?: string | null
  }

  export type EventParticipantCreateOrConnectWithoutPlayerInput = {
    where: EventParticipantWhereUniqueInput
    create: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput>
  }

  export type EventParticipantCreateManyPlayerInputEnvelope = {
    data: EventParticipantCreateManyPlayerInput | EventParticipantCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerPodHolderCreateWithoutPlayerInput = {
    id?: string
    assigned_date?: Date | string
    pod_holder: PodHolderCreateNestedOneWithoutPlayer_pod_holdersInput
  }

  export type PlayerPodHolderUncheckedCreateWithoutPlayerInput = {
    id?: string
    pod_holder_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodHolderCreateOrConnectWithoutPlayerInput = {
    where: PlayerPodHolderWhereUniqueInput
    create: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerPodHolderCreateManyPlayerInputEnvelope = {
    data: PlayerPodHolderCreateManyPlayerInput | PlayerPodHolderCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerPodCreateWithoutPlayerInput = {
    id?: string
    assigned_date?: Date | string
    pod: PodCreateNestedOneWithoutPlayer_podsInput
  }

  export type PlayerPodUncheckedCreateWithoutPlayerInput = {
    id?: string
    pod_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodCreateOrConnectWithoutPlayerInput = {
    where: PlayerPodWhereUniqueInput
    create: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerPodCreateManyPlayerInputEnvelope = {
    data: PlayerPodCreateManyPlayerInput | PlayerPodCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutPlayersInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutPlayersInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutPlayersInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutPlayersInput, ClubUncheckedCreateWithoutPlayersInput>
  }

  export type RawDataCreateWithoutPlayerInput = {
    raw_id?: string
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
    pod: PodCreateNestedOneWithoutRaw_dataInput
  }

  export type RawDataUncheckedCreateWithoutPlayerInput = {
    raw_id?: string
    pod_id: string
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type RawDataCreateOrConnectWithoutPlayerInput = {
    where: RawDataWhereUniqueInput
    create: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput>
  }

  export type RawDataCreateManyPlayerInputEnvelope = {
    data: RawDataCreateManyPlayerInput | RawDataCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityMetricUpsertWithWhereUniqueWithoutPlayerInput = {
    where: ActivityMetricWhereUniqueInput
    update: XOR<ActivityMetricUpdateWithoutPlayerInput, ActivityMetricUncheckedUpdateWithoutPlayerInput>
    create: XOR<ActivityMetricCreateWithoutPlayerInput, ActivityMetricUncheckedCreateWithoutPlayerInput>
  }

  export type ActivityMetricUpdateWithWhereUniqueWithoutPlayerInput = {
    where: ActivityMetricWhereUniqueInput
    data: XOR<ActivityMetricUpdateWithoutPlayerInput, ActivityMetricUncheckedUpdateWithoutPlayerInput>
  }

  export type ActivityMetricUpdateManyWithWhereWithoutPlayerInput = {
    where: ActivityMetricScalarWhereInput
    data: XOR<ActivityMetricUpdateManyMutationInput, ActivityMetricUncheckedUpdateManyWithoutPlayerInput>
  }

  export type ActivityMetricScalarWhereInput = {
    AND?: ActivityMetricScalarWhereInput | ActivityMetricScalarWhereInput[]
    OR?: ActivityMetricScalarWhereInput[]
    NOT?: ActivityMetricScalarWhereInput | ActivityMetricScalarWhereInput[]
    id?: UuidFilter<"ActivityMetric"> | string
    player_id?: UuidFilter<"ActivityMetric"> | string
    total_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    hsr_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_distance?: FloatNullableFilter<"ActivityMetric"> | number | null
    top_speed?: FloatNullableFilter<"ActivityMetric"> | number | null
    sprint_count?: IntNullableFilter<"ActivityMetric"> | number | null
    acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_acceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    max_deceleration?: FloatNullableFilter<"ActivityMetric"> | number | null
    player_load?: FloatNullableFilter<"ActivityMetric"> | number | null
    power_score?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_max?: IntNullableFilter<"ActivityMetric"> | number | null
    time_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    percent_in_red_zone?: FloatNullableFilter<"ActivityMetric"> | number | null
    hr_recovery_time?: FloatNullableFilter<"ActivityMetric"> | number | null
    recorded_at?: DateTimeFilter<"ActivityMetric"> | Date | string
  }

  export type CoachAssignmentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CoachAssignmentWhereUniqueInput
    update: XOR<CoachAssignmentUpdateWithoutPlayerInput, CoachAssignmentUncheckedUpdateWithoutPlayerInput>
    create: XOR<CoachAssignmentCreateWithoutPlayerInput, CoachAssignmentUncheckedCreateWithoutPlayerInput>
  }

  export type CoachAssignmentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CoachAssignmentWhereUniqueInput
    data: XOR<CoachAssignmentUpdateWithoutPlayerInput, CoachAssignmentUncheckedUpdateWithoutPlayerInput>
  }

  export type CoachAssignmentUpdateManyWithWhereWithoutPlayerInput = {
    where: CoachAssignmentScalarWhereInput
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type EventParticipantUpsertWithWhereUniqueWithoutPlayerInput = {
    where: EventParticipantWhereUniqueInput
    update: XOR<EventParticipantUpdateWithoutPlayerInput, EventParticipantUncheckedUpdateWithoutPlayerInput>
    create: XOR<EventParticipantCreateWithoutPlayerInput, EventParticipantUncheckedCreateWithoutPlayerInput>
  }

  export type EventParticipantUpdateWithWhereUniqueWithoutPlayerInput = {
    where: EventParticipantWhereUniqueInput
    data: XOR<EventParticipantUpdateWithoutPlayerInput, EventParticipantUncheckedUpdateWithoutPlayerInput>
  }

  export type EventParticipantUpdateManyWithWhereWithoutPlayerInput = {
    where: EventParticipantScalarWhereInput
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerPodHolderUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerPodHolderWhereUniqueInput
    update: XOR<PlayerPodHolderUpdateWithoutPlayerInput, PlayerPodHolderUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerPodHolderCreateWithoutPlayerInput, PlayerPodHolderUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerPodHolderUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerPodHolderWhereUniqueInput
    data: XOR<PlayerPodHolderUpdateWithoutPlayerInput, PlayerPodHolderUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerPodHolderUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerPodHolderScalarWhereInput
    data: XOR<PlayerPodHolderUpdateManyMutationInput, PlayerPodHolderUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerPodHolderScalarWhereInput = {
    AND?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
    OR?: PlayerPodHolderScalarWhereInput[]
    NOT?: PlayerPodHolderScalarWhereInput | PlayerPodHolderScalarWhereInput[]
    id?: UuidFilter<"PlayerPodHolder"> | string
    player_id?: UuidFilter<"PlayerPodHolder"> | string
    pod_holder_id?: UuidFilter<"PlayerPodHolder"> | string
    assigned_date?: DateTimeFilter<"PlayerPodHolder"> | Date | string
  }

  export type PlayerPodUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerPodWhereUniqueInput
    update: XOR<PlayerPodUpdateWithoutPlayerInput, PlayerPodUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerPodCreateWithoutPlayerInput, PlayerPodUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerPodUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerPodWhereUniqueInput
    data: XOR<PlayerPodUpdateWithoutPlayerInput, PlayerPodUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerPodUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerPodScalarWhereInput
    data: XOR<PlayerPodUpdateManyMutationInput, PlayerPodUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerPodScalarWhereInput = {
    AND?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
    OR?: PlayerPodScalarWhereInput[]
    NOT?: PlayerPodScalarWhereInput | PlayerPodScalarWhereInput[]
    id?: UuidFilter<"PlayerPod"> | string
    player_id?: UuidFilter<"PlayerPod"> | string
    pod_id?: UuidFilter<"PlayerPod"> | string
    assigned_date?: DateTimeFilter<"PlayerPod"> | Date | string
  }

  export type ClubUpsertWithoutPlayersInput = {
    update: XOR<ClubUpdateWithoutPlayersInput, ClubUncheckedUpdateWithoutPlayersInput>
    create: XOR<ClubCreateWithoutPlayersInput, ClubUncheckedCreateWithoutPlayersInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutPlayersInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutPlayersInput, ClubUncheckedUpdateWithoutPlayersInput>
  }

  export type ClubUpdateWithoutPlayersInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutPlayersInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type RawDataUpsertWithWhereUniqueWithoutPlayerInput = {
    where: RawDataWhereUniqueInput
    update: XOR<RawDataUpdateWithoutPlayerInput, RawDataUncheckedUpdateWithoutPlayerInput>
    create: XOR<RawDataCreateWithoutPlayerInput, RawDataUncheckedCreateWithoutPlayerInput>
  }

  export type RawDataUpdateWithWhereUniqueWithoutPlayerInput = {
    where: RawDataWhereUniqueInput
    data: XOR<RawDataUpdateWithoutPlayerInput, RawDataUncheckedUpdateWithoutPlayerInput>
  }

  export type RawDataUpdateManyWithWhereWithoutPlayerInput = {
    where: RawDataScalarWhereInput
    data: XOR<RawDataUpdateManyMutationInput, RawDataUncheckedUpdateManyWithoutPlayerInput>
  }

  export type RawDataScalarWhereInput = {
    AND?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
    OR?: RawDataScalarWhereInput[]
    NOT?: RawDataScalarWhereInput | RawDataScalarWhereInput[]
    raw_id?: UuidFilter<"RawData"> | string
    pod_id?: UuidFilter<"RawData"> | string
    player_id?: UuidNullableFilter<"RawData"> | string | null
    ts?: DateTimeNullableFilter<"RawData"> | Date | string | null
    acceleration_x?: FloatNullableFilter<"RawData"> | number | null
    acceleration_y?: FloatNullableFilter<"RawData"> | number | null
    acceleration_z?: FloatNullableFilter<"RawData"> | number | null
    latitude?: FloatNullableFilter<"RawData"> | number | null
    longitude?: FloatNullableFilter<"RawData"> | number | null
    w?: FloatNullableFilter<"RawData"> | number | null
    x?: FloatNullableFilter<"RawData"> | number | null
    y?: FloatNullableFilter<"RawData"> | number | null
    z?: FloatNullableFilter<"RawData"> | number | null
    distance?: FloatNullableFilter<"RawData"> | number | null
    speed?: FloatNullableFilter<"RawData"> | number | null
    heart_rate?: IntNullableFilter<"RawData"> | number | null
    created_at?: DateTimeFilter<"RawData"> | Date | string
  }

  export type CoachAssignmentCreateWithoutPodInput = {
    assignment_id?: string
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutCoach_assignmentsInput
    player?: PlayerCreateNestedOneWithoutCoach_assignmentsInput
    pod_holder?: PodHolderCreateNestedOneWithoutCoach_assignmentsInput
  }

  export type CoachAssignmentUncheckedCreateWithoutPodInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentCreateOrConnectWithoutPodInput = {
    where: CoachAssignmentWhereUniqueInput
    create: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput>
  }

  export type CoachAssignmentCreateManyPodInputEnvelope = {
    data: CoachAssignmentCreateManyPodInput | CoachAssignmentCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type PlayerPodCreateWithoutPodInput = {
    id?: string
    assigned_date?: Date | string
    player: PlayerCreateNestedOneWithoutPlayer_podsInput
  }

  export type PlayerPodUncheckedCreateWithoutPodInput = {
    id?: string
    player_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodCreateOrConnectWithoutPodInput = {
    where: PlayerPodWhereUniqueInput
    create: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput>
  }

  export type PlayerPodCreateManyPodInputEnvelope = {
    data: PlayerPodCreateManyPodInput | PlayerPodCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type PodAllocationCreateWithoutPodInput = {
    allocation_id?: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutPod_allocationsInput
  }

  export type PodAllocationUncheckedCreateWithoutPodInput = {
    allocation_id?: string
    coach_id?: string | null
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type PodAllocationCreateOrConnectWithoutPodInput = {
    where: PodAllocationWhereUniqueInput
    create: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput>
  }

  export type PodAllocationCreateManyPodInputEnvelope = {
    data: PodAllocationCreateManyPodInput | PodAllocationCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type PodStatusCreateWithoutPodInput = {
    status_id?: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
  }

  export type PodStatusUncheckedCreateWithoutPodInput = {
    status_id?: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
  }

  export type PodStatusCreateOrConnectWithoutPodInput = {
    where: PodStatusWhereUniqueInput
    create: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput>
  }

  export type PodStatusCreateManyPodInputEnvelope = {
    data: PodStatusCreateManyPodInput | PodStatusCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type RawDataCreateWithoutPodInput = {
    raw_id?: string
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
    player?: PlayerCreateNestedOneWithoutRaw_dataInput
  }

  export type RawDataUncheckedCreateWithoutPodInput = {
    raw_id?: string
    player_id?: string | null
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type RawDataCreateOrConnectWithoutPodInput = {
    where: RawDataWhereUniqueInput
    create: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput>
  }

  export type RawDataCreateManyPodInputEnvelope = {
    data: RawDataCreateManyPodInput | RawDataCreateManyPodInput[]
    skipDuplicates?: boolean
  }

  export type CoachAssignmentUpsertWithWhereUniqueWithoutPodInput = {
    where: CoachAssignmentWhereUniqueInput
    update: XOR<CoachAssignmentUpdateWithoutPodInput, CoachAssignmentUncheckedUpdateWithoutPodInput>
    create: XOR<CoachAssignmentCreateWithoutPodInput, CoachAssignmentUncheckedCreateWithoutPodInput>
  }

  export type CoachAssignmentUpdateWithWhereUniqueWithoutPodInput = {
    where: CoachAssignmentWhereUniqueInput
    data: XOR<CoachAssignmentUpdateWithoutPodInput, CoachAssignmentUncheckedUpdateWithoutPodInput>
  }

  export type CoachAssignmentUpdateManyWithWhereWithoutPodInput = {
    where: CoachAssignmentScalarWhereInput
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyWithoutPodInput>
  }

  export type PlayerPodUpsertWithWhereUniqueWithoutPodInput = {
    where: PlayerPodWhereUniqueInput
    update: XOR<PlayerPodUpdateWithoutPodInput, PlayerPodUncheckedUpdateWithoutPodInput>
    create: XOR<PlayerPodCreateWithoutPodInput, PlayerPodUncheckedCreateWithoutPodInput>
  }

  export type PlayerPodUpdateWithWhereUniqueWithoutPodInput = {
    where: PlayerPodWhereUniqueInput
    data: XOR<PlayerPodUpdateWithoutPodInput, PlayerPodUncheckedUpdateWithoutPodInput>
  }

  export type PlayerPodUpdateManyWithWhereWithoutPodInput = {
    where: PlayerPodScalarWhereInput
    data: XOR<PlayerPodUpdateManyMutationInput, PlayerPodUncheckedUpdateManyWithoutPodInput>
  }

  export type PodAllocationUpsertWithWhereUniqueWithoutPodInput = {
    where: PodAllocationWhereUniqueInput
    update: XOR<PodAllocationUpdateWithoutPodInput, PodAllocationUncheckedUpdateWithoutPodInput>
    create: XOR<PodAllocationCreateWithoutPodInput, PodAllocationUncheckedCreateWithoutPodInput>
  }

  export type PodAllocationUpdateWithWhereUniqueWithoutPodInput = {
    where: PodAllocationWhereUniqueInput
    data: XOR<PodAllocationUpdateWithoutPodInput, PodAllocationUncheckedUpdateWithoutPodInput>
  }

  export type PodAllocationUpdateManyWithWhereWithoutPodInput = {
    where: PodAllocationScalarWhereInput
    data: XOR<PodAllocationUpdateManyMutationInput, PodAllocationUncheckedUpdateManyWithoutPodInput>
  }

  export type PodStatusUpsertWithWhereUniqueWithoutPodInput = {
    where: PodStatusWhereUniqueInput
    update: XOR<PodStatusUpdateWithoutPodInput, PodStatusUncheckedUpdateWithoutPodInput>
    create: XOR<PodStatusCreateWithoutPodInput, PodStatusUncheckedCreateWithoutPodInput>
  }

  export type PodStatusUpdateWithWhereUniqueWithoutPodInput = {
    where: PodStatusWhereUniqueInput
    data: XOR<PodStatusUpdateWithoutPodInput, PodStatusUncheckedUpdateWithoutPodInput>
  }

  export type PodStatusUpdateManyWithWhereWithoutPodInput = {
    where: PodStatusScalarWhereInput
    data: XOR<PodStatusUpdateManyMutationInput, PodStatusUncheckedUpdateManyWithoutPodInput>
  }

  export type PodStatusScalarWhereInput = {
    AND?: PodStatusScalarWhereInput | PodStatusScalarWhereInput[]
    OR?: PodStatusScalarWhereInput[]
    NOT?: PodStatusScalarWhereInput | PodStatusScalarWhereInput[]
    status_id?: UuidFilter<"PodStatus"> | string
    pod_id?: UuidFilter<"PodStatus"> | string
    working_status?: StringNullableFilter<"PodStatus"> | string | null
    battery_level?: IntNullableFilter<"PodStatus"> | number | null
    last_sync?: DateTimeNullableFilter<"PodStatus"> | Date | string | null
    health_status?: StringNullableFilter<"PodStatus"> | string | null
    created_at?: DateTimeFilter<"PodStatus"> | Date | string
  }

  export type RawDataUpsertWithWhereUniqueWithoutPodInput = {
    where: RawDataWhereUniqueInput
    update: XOR<RawDataUpdateWithoutPodInput, RawDataUncheckedUpdateWithoutPodInput>
    create: XOR<RawDataCreateWithoutPodInput, RawDataUncheckedCreateWithoutPodInput>
  }

  export type RawDataUpdateWithWhereUniqueWithoutPodInput = {
    where: RawDataWhereUniqueInput
    data: XOR<RawDataUpdateWithoutPodInput, RawDataUncheckedUpdateWithoutPodInput>
  }

  export type RawDataUpdateManyWithWhereWithoutPodInput = {
    where: RawDataScalarWhereInput
    data: XOR<RawDataUpdateManyMutationInput, RawDataUncheckedUpdateManyWithoutPodInput>
  }

  export type ClubCreateWithoutPod_holdersInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutPod_holdersInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutPod_holdersInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutPod_holdersInput, ClubUncheckedCreateWithoutPod_holdersInput>
  }

  export type PodHolderAuditCreateWithoutPod_holderInput = {
    audit_id?: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
  }

  export type PodHolderAuditUncheckedCreateWithoutPod_holderInput = {
    audit_id?: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
  }

  export type PodHolderAuditCreateOrConnectWithoutPod_holderInput = {
    where: PodHolderAuditWhereUniqueInput
    create: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput>
  }

  export type PodHolderAuditCreateManyPod_holderInputEnvelope = {
    data: PodHolderAuditCreateManyPod_holderInput | PodHolderAuditCreateManyPod_holderInput[]
    skipDuplicates?: boolean
  }

  export type CoachAssignmentCreateWithoutPod_holderInput = {
    assignment_id?: string
    assigned_at?: Date | string
    coach?: CoachCreateNestedOneWithoutCoach_assignmentsInput
    player?: PlayerCreateNestedOneWithoutCoach_assignmentsInput
    pod?: PodCreateNestedOneWithoutCoach_assignmentsInput
  }

  export type CoachAssignmentUncheckedCreateWithoutPod_holderInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentCreateOrConnectWithoutPod_holderInput = {
    where: CoachAssignmentWhereUniqueInput
    create: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput>
  }

  export type CoachAssignmentCreateManyPod_holderInputEnvelope = {
    data: CoachAssignmentCreateManyPod_holderInput | CoachAssignmentCreateManyPod_holderInput[]
    skipDuplicates?: boolean
  }

  export type PlayerPodHolderCreateWithoutPod_holderInput = {
    id?: string
    assigned_date?: Date | string
    player: PlayerCreateNestedOneWithoutPlayer_pod_holdersInput
  }

  export type PlayerPodHolderUncheckedCreateWithoutPod_holderInput = {
    id?: string
    player_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodHolderCreateOrConnectWithoutPod_holderInput = {
    where: PlayerPodHolderWhereUniqueInput
    create: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput>
  }

  export type PlayerPodHolderCreateManyPod_holderInputEnvelope = {
    data: PlayerPodHolderCreateManyPod_holderInput | PlayerPodHolderCreateManyPod_holderInput[]
    skipDuplicates?: boolean
  }

  export type PodHolderStatusCreateWithoutPod_holderInput = {
    status_id?: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
  }

  export type PodHolderStatusUncheckedCreateWithoutPod_holderInput = {
    status_id?: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
  }

  export type PodHolderStatusCreateOrConnectWithoutPod_holderInput = {
    where: PodHolderStatusWhereUniqueInput
    create: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput>
  }

  export type PodHolderStatusCreateManyPod_holderInputEnvelope = {
    data: PodHolderStatusCreateManyPod_holderInput | PodHolderStatusCreateManyPod_holderInput[]
    skipDuplicates?: boolean
  }

  export type ClubUpsertWithoutPod_holdersInput = {
    update: XOR<ClubUpdateWithoutPod_holdersInput, ClubUncheckedUpdateWithoutPod_holdersInput>
    create: XOR<ClubCreateWithoutPod_holdersInput, ClubUncheckedCreateWithoutPod_holdersInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutPod_holdersInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutPod_holdersInput, ClubUncheckedUpdateWithoutPod_holdersInput>
  }

  export type ClubUpdateWithoutPod_holdersInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutPod_holdersInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type PodHolderAuditUpsertWithWhereUniqueWithoutPod_holderInput = {
    where: PodHolderAuditWhereUniqueInput
    update: XOR<PodHolderAuditUpdateWithoutPod_holderInput, PodHolderAuditUncheckedUpdateWithoutPod_holderInput>
    create: XOR<PodHolderAuditCreateWithoutPod_holderInput, PodHolderAuditUncheckedCreateWithoutPod_holderInput>
  }

  export type PodHolderAuditUpdateWithWhereUniqueWithoutPod_holderInput = {
    where: PodHolderAuditWhereUniqueInput
    data: XOR<PodHolderAuditUpdateWithoutPod_holderInput, PodHolderAuditUncheckedUpdateWithoutPod_holderInput>
  }

  export type PodHolderAuditUpdateManyWithWhereWithoutPod_holderInput = {
    where: PodHolderAuditScalarWhereInput
    data: XOR<PodHolderAuditUpdateManyMutationInput, PodHolderAuditUncheckedUpdateManyWithoutPod_holderInput>
  }

  export type PodHolderAuditScalarWhereInput = {
    AND?: PodHolderAuditScalarWhereInput | PodHolderAuditScalarWhereInput[]
    OR?: PodHolderAuditScalarWhereInput[]
    NOT?: PodHolderAuditScalarWhereInput | PodHolderAuditScalarWhereInput[]
    audit_id?: UuidFilter<"PodHolderAudit"> | string
    pod_holder_id?: UuidFilter<"PodHolderAudit"> | string
    from_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    to_club_id?: UuidNullableFilter<"PodHolderAudit"> | string | null
    action?: StringFilter<"PodHolderAudit"> | string
    performed_by?: UuidFilter<"PodHolderAudit"> | string
    created_at?: DateTimeFilter<"PodHolderAudit"> | Date | string
  }

  export type CoachAssignmentUpsertWithWhereUniqueWithoutPod_holderInput = {
    where: CoachAssignmentWhereUniqueInput
    update: XOR<CoachAssignmentUpdateWithoutPod_holderInput, CoachAssignmentUncheckedUpdateWithoutPod_holderInput>
    create: XOR<CoachAssignmentCreateWithoutPod_holderInput, CoachAssignmentUncheckedCreateWithoutPod_holderInput>
  }

  export type CoachAssignmentUpdateWithWhereUniqueWithoutPod_holderInput = {
    where: CoachAssignmentWhereUniqueInput
    data: XOR<CoachAssignmentUpdateWithoutPod_holderInput, CoachAssignmentUncheckedUpdateWithoutPod_holderInput>
  }

  export type CoachAssignmentUpdateManyWithWhereWithoutPod_holderInput = {
    where: CoachAssignmentScalarWhereInput
    data: XOR<CoachAssignmentUpdateManyMutationInput, CoachAssignmentUncheckedUpdateManyWithoutPod_holderInput>
  }

  export type PlayerPodHolderUpsertWithWhereUniqueWithoutPod_holderInput = {
    where: PlayerPodHolderWhereUniqueInput
    update: XOR<PlayerPodHolderUpdateWithoutPod_holderInput, PlayerPodHolderUncheckedUpdateWithoutPod_holderInput>
    create: XOR<PlayerPodHolderCreateWithoutPod_holderInput, PlayerPodHolderUncheckedCreateWithoutPod_holderInput>
  }

  export type PlayerPodHolderUpdateWithWhereUniqueWithoutPod_holderInput = {
    where: PlayerPodHolderWhereUniqueInput
    data: XOR<PlayerPodHolderUpdateWithoutPod_holderInput, PlayerPodHolderUncheckedUpdateWithoutPod_holderInput>
  }

  export type PlayerPodHolderUpdateManyWithWhereWithoutPod_holderInput = {
    where: PlayerPodHolderScalarWhereInput
    data: XOR<PlayerPodHolderUpdateManyMutationInput, PlayerPodHolderUncheckedUpdateManyWithoutPod_holderInput>
  }

  export type PodHolderStatusUpsertWithWhereUniqueWithoutPod_holderInput = {
    where: PodHolderStatusWhereUniqueInput
    update: XOR<PodHolderStatusUpdateWithoutPod_holderInput, PodHolderStatusUncheckedUpdateWithoutPod_holderInput>
    create: XOR<PodHolderStatusCreateWithoutPod_holderInput, PodHolderStatusUncheckedCreateWithoutPod_holderInput>
  }

  export type PodHolderStatusUpdateWithWhereUniqueWithoutPod_holderInput = {
    where: PodHolderStatusWhereUniqueInput
    data: XOR<PodHolderStatusUpdateWithoutPod_holderInput, PodHolderStatusUncheckedUpdateWithoutPod_holderInput>
  }

  export type PodHolderStatusUpdateManyWithWhereWithoutPod_holderInput = {
    where: PodHolderStatusScalarWhereInput
    data: XOR<PodHolderStatusUpdateManyMutationInput, PodHolderStatusUncheckedUpdateManyWithoutPod_holderInput>
  }

  export type PodHolderStatusScalarWhereInput = {
    AND?: PodHolderStatusScalarWhereInput | PodHolderStatusScalarWhereInput[]
    OR?: PodHolderStatusScalarWhereInput[]
    NOT?: PodHolderStatusScalarWhereInput | PodHolderStatusScalarWhereInput[]
    status_id?: UuidFilter<"PodHolderStatus"> | string
    pod_holder_id?: UuidFilter<"PodHolderStatus"> | string
    battery_level?: IntNullableFilter<"PodHolderStatus"> | number | null
    working_status?: StringNullableFilter<"PodHolderStatus"> | string | null
    last_sync?: DateTimeNullableFilter<"PodHolderStatus"> | Date | string | null
    created_at?: DateTimeFilter<"PodHolderStatus"> | Date | string
  }

  export type PodHolderCreateWithoutAuditsInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutPod_holdersInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateWithoutAuditsInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderCreateOrConnectWithoutAuditsInput = {
    where: PodHolderWhereUniqueInput
    create: XOR<PodHolderCreateWithoutAuditsInput, PodHolderUncheckedCreateWithoutAuditsInput>
  }

  export type PodHolderUpsertWithoutAuditsInput = {
    update: XOR<PodHolderUpdateWithoutAuditsInput, PodHolderUncheckedUpdateWithoutAuditsInput>
    create: XOR<PodHolderCreateWithoutAuditsInput, PodHolderUncheckedCreateWithoutAuditsInput>
    where?: PodHolderWhereInput
  }

  export type PodHolderUpdateToOneWithWhereWithoutAuditsInput = {
    where?: PodHolderWhereInput
    data: XOR<PodHolderUpdateWithoutAuditsInput, PodHolderUncheckedUpdateWithoutAuditsInput>
  }

  export type PodHolderUpdateWithoutAuditsInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutPod_holdersNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateWithoutAuditsInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type CoachCreateWithoutPod_allocationsInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutCoachInput
    club: ClubCreateNestedOneWithoutCoachesInput
    event_participants?: EventParticipantCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutPod_allocationsInput = {
    coach_id?: string
    club_id: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutCoachInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutPod_allocationsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutPod_allocationsInput, CoachUncheckedCreateWithoutPod_allocationsInput>
  }

  export type PodCreateWithoutPod_allocationsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusCreateNestedManyWithoutPodInput
    raw_data?: RawDataCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutPod_allocationsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusUncheckedCreateNestedManyWithoutPodInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutPod_allocationsInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutPod_allocationsInput, PodUncheckedCreateWithoutPod_allocationsInput>
  }

  export type CoachUpsertWithoutPod_allocationsInput = {
    update: XOR<CoachUpdateWithoutPod_allocationsInput, CoachUncheckedUpdateWithoutPod_allocationsInput>
    create: XOR<CoachCreateWithoutPod_allocationsInput, CoachUncheckedCreateWithoutPod_allocationsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutPod_allocationsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutPod_allocationsInput, CoachUncheckedUpdateWithoutPod_allocationsInput>
  }

  export type CoachUpdateWithoutPod_allocationsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUpdateManyWithoutCoachNestedInput
    club?: ClubUpdateOneRequiredWithoutCoachesNestedInput
    event_participants?: EventParticipantUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutPod_allocationsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutCoachNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type PodUpsertWithoutPod_allocationsInput = {
    update: XOR<PodUpdateWithoutPod_allocationsInput, PodUncheckedUpdateWithoutPod_allocationsInput>
    create: XOR<PodCreateWithoutPod_allocationsInput, PodUncheckedCreateWithoutPod_allocationsInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutPod_allocationsInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutPod_allocationsInput, PodUncheckedUpdateWithoutPod_allocationsInput>
  }

  export type PodUpdateWithoutPod_allocationsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutPod_allocationsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUncheckedUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPodNestedInput
  }

  export type CoachCreateWithoutCoach_assignmentsInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    club: ClubCreateNestedOneWithoutCoachesInput
    event_participants?: EventParticipantCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutCoach_assignmentsInput = {
    coach_id?: string
    club_id: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutCoach_assignmentsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutCoach_assignmentsInput, CoachUncheckedCreateWithoutCoach_assignmentsInput>
  }

  export type PlayerCreateWithoutCoach_assignmentsInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCoach_assignmentsInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCoach_assignmentsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCoach_assignmentsInput, PlayerUncheckedCreateWithoutCoach_assignmentsInput>
  }

  export type PodHolderCreateWithoutCoach_assignmentsInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutPod_holdersInput
    audits?: PodHolderAuditCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateWithoutCoach_assignmentsInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
    audits?: PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderCreateOrConnectWithoutCoach_assignmentsInput = {
    where: PodHolderWhereUniqueInput
    create: XOR<PodHolderCreateWithoutCoach_assignmentsInput, PodHolderUncheckedCreateWithoutCoach_assignmentsInput>
  }

  export type PodCreateWithoutCoach_assignmentsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    player_pods?: PlayerPodCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusCreateNestedManyWithoutPodInput
    raw_data?: RawDataCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutCoach_assignmentsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusUncheckedCreateNestedManyWithoutPodInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutCoach_assignmentsInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutCoach_assignmentsInput, PodUncheckedCreateWithoutCoach_assignmentsInput>
  }

  export type CoachUpsertWithoutCoach_assignmentsInput = {
    update: XOR<CoachUpdateWithoutCoach_assignmentsInput, CoachUncheckedUpdateWithoutCoach_assignmentsInput>
    create: XOR<CoachCreateWithoutCoach_assignmentsInput, CoachUncheckedCreateWithoutCoach_assignmentsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutCoach_assignmentsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutCoach_assignmentsInput, CoachUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type CoachUpdateWithoutCoach_assignmentsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    club?: ClubUpdateOneRequiredWithoutCoachesNestedInput
    event_participants?: EventParticipantUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutCoach_assignmentsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event_participants?: EventParticipantUncheckedUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type PlayerUpsertWithoutCoach_assignmentsInput = {
    update: XOR<PlayerUpdateWithoutCoach_assignmentsInput, PlayerUncheckedUpdateWithoutCoach_assignmentsInput>
    create: XOR<PlayerCreateWithoutCoach_assignmentsInput, PlayerUncheckedCreateWithoutCoach_assignmentsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCoach_assignmentsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCoach_assignmentsInput, PlayerUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PlayerUpdateWithoutCoach_assignmentsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCoach_assignmentsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PodHolderUpsertWithoutCoach_assignmentsInput = {
    update: XOR<PodHolderUpdateWithoutCoach_assignmentsInput, PodHolderUncheckedUpdateWithoutCoach_assignmentsInput>
    create: XOR<PodHolderCreateWithoutCoach_assignmentsInput, PodHolderUncheckedCreateWithoutCoach_assignmentsInput>
    where?: PodHolderWhereInput
  }

  export type PodHolderUpdateToOneWithWhereWithoutCoach_assignmentsInput = {
    where?: PodHolderWhereInput
    data: XOR<PodHolderUpdateWithoutCoach_assignmentsInput, PodHolderUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PodHolderUpdateWithoutCoach_assignmentsInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutPod_holdersNestedInput
    audits?: PodHolderAuditUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateWithoutCoach_assignmentsInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    audits?: PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type PodUpsertWithoutCoach_assignmentsInput = {
    update: XOR<PodUpdateWithoutCoach_assignmentsInput, PodUncheckedUpdateWithoutCoach_assignmentsInput>
    create: XOR<PodCreateWithoutCoach_assignmentsInput, PodUncheckedCreateWithoutCoach_assignmentsInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutCoach_assignmentsInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutCoach_assignmentsInput, PodUncheckedUpdateWithoutCoach_assignmentsInput>
  }

  export type PodUpdateWithoutCoach_assignmentsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player_pods?: PlayerPodUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutCoach_assignmentsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUncheckedUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PlayerCreateWithoutPlayer_podsInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_podsInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_podsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_podsInput, PlayerUncheckedCreateWithoutPlayer_podsInput>
  }

  export type PodCreateWithoutPlayer_podsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusCreateNestedManyWithoutPodInput
    raw_data?: RawDataCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutPlayer_podsInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusUncheckedCreateNestedManyWithoutPodInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutPlayer_podsInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutPlayer_podsInput, PodUncheckedCreateWithoutPlayer_podsInput>
  }

  export type PlayerUpsertWithoutPlayer_podsInput = {
    update: XOR<PlayerUpdateWithoutPlayer_podsInput, PlayerUncheckedUpdateWithoutPlayer_podsInput>
    create: XOR<PlayerCreateWithoutPlayer_podsInput, PlayerUncheckedCreateWithoutPlayer_podsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPlayer_podsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPlayer_podsInput, PlayerUncheckedUpdateWithoutPlayer_podsInput>
  }

  export type PlayerUpdateWithoutPlayer_podsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_podsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PodUpsertWithoutPlayer_podsInput = {
    update: XOR<PodUpdateWithoutPlayer_podsInput, PodUncheckedUpdateWithoutPlayer_podsInput>
    create: XOR<PodCreateWithoutPlayer_podsInput, PodUncheckedCreateWithoutPlayer_podsInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutPlayer_podsInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutPlayer_podsInput, PodUncheckedUpdateWithoutPlayer_podsInput>
  }

  export type PodUpdateWithoutPlayer_podsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutPlayer_podsInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUncheckedUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PlayerCreateWithoutPlayer_pod_holdersInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_pod_holdersInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_pod_holdersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_pod_holdersInput, PlayerUncheckedCreateWithoutPlayer_pod_holdersInput>
  }

  export type PodHolderCreateWithoutPlayer_pod_holdersInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutPod_holdersInput
    audits?: PodHolderAuditCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateWithoutPlayer_pod_holdersInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
    audits?: PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput
    pod_holder_statuses?: PodHolderStatusUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderCreateOrConnectWithoutPlayer_pod_holdersInput = {
    where: PodHolderWhereUniqueInput
    create: XOR<PodHolderCreateWithoutPlayer_pod_holdersInput, PodHolderUncheckedCreateWithoutPlayer_pod_holdersInput>
  }

  export type PlayerUpsertWithoutPlayer_pod_holdersInput = {
    update: XOR<PlayerUpdateWithoutPlayer_pod_holdersInput, PlayerUncheckedUpdateWithoutPlayer_pod_holdersInput>
    create: XOR<PlayerCreateWithoutPlayer_pod_holdersInput, PlayerUncheckedCreateWithoutPlayer_pod_holdersInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPlayer_pod_holdersInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPlayer_pod_holdersInput, PlayerUncheckedUpdateWithoutPlayer_pod_holdersInput>
  }

  export type PlayerUpdateWithoutPlayer_pod_holdersInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_pod_holdersInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PodHolderUpsertWithoutPlayer_pod_holdersInput = {
    update: XOR<PodHolderUpdateWithoutPlayer_pod_holdersInput, PodHolderUncheckedUpdateWithoutPlayer_pod_holdersInput>
    create: XOR<PodHolderCreateWithoutPlayer_pod_holdersInput, PodHolderUncheckedCreateWithoutPlayer_pod_holdersInput>
    where?: PodHolderWhereInput
  }

  export type PodHolderUpdateToOneWithWhereWithoutPlayer_pod_holdersInput = {
    where?: PodHolderWhereInput
    data: XOR<PodHolderUpdateWithoutPlayer_pod_holdersInput, PodHolderUncheckedUpdateWithoutPlayer_pod_holdersInput>
  }

  export type PodHolderUpdateWithoutPlayer_pod_holdersInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutPod_holdersNestedInput
    audits?: PodHolderAuditUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateWithoutPlayer_pod_holdersInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    audits?: PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type PodCreateWithoutPod_statusesInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutPodInput
    raw_data?: RawDataCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutPod_statusesInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutPodInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutPod_statusesInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutPod_statusesInput, PodUncheckedCreateWithoutPod_statusesInput>
  }

  export type PodUpsertWithoutPod_statusesInput = {
    update: XOR<PodUpdateWithoutPod_statusesInput, PodUncheckedUpdateWithoutPod_statusesInput>
    create: XOR<PodCreateWithoutPod_statusesInput, PodUncheckedCreateWithoutPod_statusesInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutPod_statusesInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutPod_statusesInput, PodUncheckedUpdateWithoutPod_statusesInput>
  }

  export type PodUpdateWithoutPod_statusesInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutPod_statusesInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutPodNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPodNestedInput
  }

  export type PodHolderCreateWithoutPod_holder_statusesInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club?: ClubCreateNestedOneWithoutPod_holdersInput
    audits?: PodHolderAuditCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderUncheckedCreateWithoutPod_holder_statusesInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    club_id?: string | null
    audits?: PodHolderAuditUncheckedCreateNestedManyWithoutPod_holderInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPod_holderInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPod_holderInput
  }

  export type PodHolderCreateOrConnectWithoutPod_holder_statusesInput = {
    where: PodHolderWhereUniqueInput
    create: XOR<PodHolderCreateWithoutPod_holder_statusesInput, PodHolderUncheckedCreateWithoutPod_holder_statusesInput>
  }

  export type PodHolderUpsertWithoutPod_holder_statusesInput = {
    update: XOR<PodHolderUpdateWithoutPod_holder_statusesInput, PodHolderUncheckedUpdateWithoutPod_holder_statusesInput>
    create: XOR<PodHolderCreateWithoutPod_holder_statusesInput, PodHolderUncheckedCreateWithoutPod_holder_statusesInput>
    where?: PodHolderWhereInput
  }

  export type PodHolderUpdateToOneWithWhereWithoutPod_holder_statusesInput = {
    where?: PodHolderWhereInput
    data: XOR<PodHolderUpdateWithoutPod_holder_statusesInput, PodHolderUncheckedUpdateWithoutPod_holder_statusesInput>
  }

  export type PodHolderUpdateWithoutPod_holder_statusesInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutPod_holdersNestedInput
    audits?: PodHolderAuditUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateWithoutPod_holder_statusesInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club_id?: NullableStringFieldUpdateOperationsInput | string | null
    audits?: PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type PlayerCreateWithoutRaw_dataInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutRaw_dataInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRaw_dataInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRaw_dataInput, PlayerUncheckedCreateWithoutRaw_dataInput>
  }

  export type PodCreateWithoutRaw_dataInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusCreateNestedManyWithoutPodInput
  }

  export type PodUncheckedCreateWithoutRaw_dataInput = {
    pod_id?: string
    serial_number?: string | null
    model?: string | null
    firmware?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPodInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPodInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutPodInput
    pod_statuses?: PodStatusUncheckedCreateNestedManyWithoutPodInput
  }

  export type PodCreateOrConnectWithoutRaw_dataInput = {
    where: PodWhereUniqueInput
    create: XOR<PodCreateWithoutRaw_dataInput, PodUncheckedCreateWithoutRaw_dataInput>
  }

  export type PlayerUpsertWithoutRaw_dataInput = {
    update: XOR<PlayerUpdateWithoutRaw_dataInput, PlayerUncheckedUpdateWithoutRaw_dataInput>
    create: XOR<PlayerCreateWithoutRaw_dataInput, PlayerUncheckedCreateWithoutRaw_dataInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRaw_dataInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRaw_dataInput, PlayerUncheckedUpdateWithoutRaw_dataInput>
  }

  export type PlayerUpdateWithoutRaw_dataInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRaw_dataInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PodUpsertWithoutRaw_dataInput = {
    update: XOR<PodUpdateWithoutRaw_dataInput, PodUncheckedUpdateWithoutRaw_dataInput>
    create: XOR<PodCreateWithoutRaw_dataInput, PodUncheckedCreateWithoutRaw_dataInput>
    where?: PodWhereInput
  }

  export type PodUpdateToOneWithWhereWithoutRaw_dataInput = {
    where?: PodWhereInput
    data: XOR<PodUpdateWithoutRaw_dataInput, PodUncheckedUpdateWithoutRaw_dataInput>
  }

  export type PodUpdateWithoutRaw_dataInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUpdateManyWithoutPodNestedInput
  }

  export type PodUncheckedUpdateWithoutRaw_dataInput = {
    pod_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    firmware?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPodNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPodNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutPodNestedInput
    pod_statuses?: PodStatusUncheckedUpdateManyWithoutPodNestedInput
  }

  export type EventParticipantCreateWithoutEventInput = {
    id?: string
    coach?: CoachCreateNestedOneWithoutEvent_participantsInput
    player?: PlayerCreateNestedOneWithoutEvent_participantsInput
  }

  export type EventParticipantUncheckedCreateWithoutEventInput = {
    id?: string
    coach_id?: string | null
    player_id?: string | null
  }

  export type EventParticipantCreateOrConnectWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    create: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput>
  }

  export type EventParticipantCreateManyEventInputEnvelope = {
    data: EventParticipantCreateManyEventInput | EventParticipantCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutEventsInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutEventsInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutEventsInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutEventsInput, ClubUncheckedCreateWithoutEventsInput>
  }

  export type EventParticipantUpsertWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    update: XOR<EventParticipantUpdateWithoutEventInput, EventParticipantUncheckedUpdateWithoutEventInput>
    create: XOR<EventParticipantCreateWithoutEventInput, EventParticipantUncheckedCreateWithoutEventInput>
  }

  export type EventParticipantUpdateWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput
    data: XOR<EventParticipantUpdateWithoutEventInput, EventParticipantUncheckedUpdateWithoutEventInput>
  }

  export type EventParticipantUpdateManyWithWhereWithoutEventInput = {
    where: EventParticipantScalarWhereInput
    data: XOR<EventParticipantUpdateManyMutationInput, EventParticipantUncheckedUpdateManyWithoutEventInput>
  }

  export type ClubUpsertWithoutEventsInput = {
    update: XOR<ClubUpdateWithoutEventsInput, ClubUncheckedUpdateWithoutEventsInput>
    create: XOR<ClubCreateWithoutEventsInput, ClubUncheckedCreateWithoutEventsInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutEventsInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutEventsInput, ClubUncheckedUpdateWithoutEventsInput>
  }

  export type ClubUpdateWithoutEventsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutEventsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type CoachCreateWithoutEvent_participantsInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutCoachInput
    club: ClubCreateNestedOneWithoutCoachesInput
    pod_allocations?: PodAllocationCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutEvent_participantsInput = {
    coach_id?: string
    club_id: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutCoachInput
    pod_allocations?: PodAllocationUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutEvent_participantsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutEvent_participantsInput, CoachUncheckedCreateWithoutEvent_participantsInput>
  }

  export type EventCreateWithoutEvent_participantsInput = {
    event_id?: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
    club: ClubCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutEvent_participantsInput = {
    event_id?: string
    club_id: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
  }

  export type EventCreateOrConnectWithoutEvent_participantsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEvent_participantsInput, EventUncheckedCreateWithoutEvent_participantsInput>
  }

  export type PlayerCreateWithoutEvent_participantsInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutEvent_participantsInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    activity_metrics?: ActivityMetricUncheckedCreateNestedManyWithoutPlayerInput
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutEvent_participantsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutEvent_participantsInput, PlayerUncheckedCreateWithoutEvent_participantsInput>
  }

  export type CoachUpsertWithoutEvent_participantsInput = {
    update: XOR<CoachUpdateWithoutEvent_participantsInput, CoachUncheckedUpdateWithoutEvent_participantsInput>
    create: XOR<CoachCreateWithoutEvent_participantsInput, CoachUncheckedCreateWithoutEvent_participantsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutEvent_participantsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutEvent_participantsInput, CoachUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type CoachUpdateWithoutEvent_participantsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUpdateManyWithoutCoachNestedInput
    club?: ClubUpdateOneRequiredWithoutCoachesNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutEvent_participantsInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type EventUpsertWithoutEvent_participantsInput = {
    update: XOR<EventUpdateWithoutEvent_participantsInput, EventUncheckedUpdateWithoutEvent_participantsInput>
    create: XOR<EventCreateWithoutEvent_participantsInput, EventUncheckedCreateWithoutEvent_participantsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEvent_participantsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEvent_participantsInput, EventUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type EventUpdateWithoutEvent_participantsInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutEvent_participantsInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpsertWithoutEvent_participantsInput = {
    update: XOR<PlayerUpdateWithoutEvent_participantsInput, PlayerUncheckedUpdateWithoutEvent_participantsInput>
    create: XOR<PlayerCreateWithoutEvent_participantsInput, PlayerUncheckedCreateWithoutEvent_participantsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutEvent_participantsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutEvent_participantsInput, PlayerUncheckedUpdateWithoutEvent_participantsInput>
  }

  export type PlayerUpdateWithoutEvent_participantsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutEvent_participantsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    subscription_id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
    club: ClubCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    subscription_id?: string
    club_id: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    payment_id?: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    payment_id?: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutSubscriptionsInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutSubscriptionsInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutSubscriptionsInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutSubscriptionsInput, ClubUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentPlanCreateWithoutSubscriptionsInput = {
    plan_id?: string
    name?: string | null
    price_cents?: number | null
    duration_days?: number | null
    description?: string | null
    created_at?: Date | string
  }

  export type PaymentPlanUncheckedCreateWithoutSubscriptionsInput = {
    plan_id?: string
    name?: string | null
    price_cents?: number | null
    duration_days?: number | null
    description?: string | null
    created_at?: Date | string
  }

  export type PaymentPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PaymentPlanWhereUniqueInput
    create: XOR<PaymentPlanCreateWithoutSubscriptionsInput, PaymentPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    payment_id?: UuidFilter<"Payment"> | string
    subscription_id?: UuidFilter<"Payment"> | string
    amount_cents?: IntNullableFilter<"Payment"> | number | null
    paid_at?: DateTimeFilter<"Payment"> | Date | string
    method?: StringNullableFilter<"Payment"> | string | null
    transaction_ref?: StringNullableFilter<"Payment"> | string | null
  }

  export type ClubUpsertWithoutSubscriptionsInput = {
    update: XOR<ClubUpdateWithoutSubscriptionsInput, ClubUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ClubCreateWithoutSubscriptionsInput, ClubUncheckedCreateWithoutSubscriptionsInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutSubscriptionsInput, ClubUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ClubUpdateWithoutSubscriptionsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutSubscriptionsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
  }

  export type PaymentPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PaymentPlanUpdateWithoutSubscriptionsInput, PaymentPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PaymentPlanCreateWithoutSubscriptionsInput, PaymentPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PaymentPlanWhereInput
  }

  export type PaymentPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PaymentPlanWhereInput
    data: XOR<PaymentPlanUpdateWithoutSubscriptionsInput, PaymentPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentPlanUpdateWithoutSubscriptionsInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUncheckedUpdateWithoutSubscriptionsInput = {
    plan_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    subscription_id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
    club: ClubCreateNestedOneWithoutSubscriptionsInput
    plan?: PaymentPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    subscription_id?: string
    club_id: string
    plan_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PaymentPlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubCreateWithoutServiceRequestsInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminCreateNestedManyWithoutClubInput
    super_admin?: SuperAdminCreateNestedOneWithoutClubsInput
    pod_holders?: PodHolderCreateNestedManyWithoutClubInput
    coaches?: CoachCreateNestedManyWithoutClubInput
    events?: EventCreateNestedManyWithoutClubInput
    players?: PlayerCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutServiceRequestsInput = {
    club_id?: string
    super_admin_id?: string | null
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
    club_admins?: ClubAdminUncheckedCreateNestedManyWithoutClubInput
    pod_holders?: PodHolderUncheckedCreateNestedManyWithoutClubInput
    coaches?: CoachUncheckedCreateNestedManyWithoutClubInput
    events?: EventUncheckedCreateNestedManyWithoutClubInput
    players?: PlayerUncheckedCreateNestedManyWithoutClubInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutServiceRequestsInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutServiceRequestsInput, ClubUncheckedCreateWithoutServiceRequestsInput>
  }

  export type ClubUpsertWithoutServiceRequestsInput = {
    update: XOR<ClubUpdateWithoutServiceRequestsInput, ClubUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<ClubCreateWithoutServiceRequestsInput, ClubUncheckedCreateWithoutServiceRequestsInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutServiceRequestsInput, ClubUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type ClubUpdateWithoutServiceRequestsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    super_admin?: SuperAdminUpdateOneWithoutClubsNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutServiceRequestsInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    super_admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type PlayerCreateWithoutActivity_metricsInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodCreateNestedManyWithoutPlayerInput
    club: ClubCreateNestedOneWithoutPlayersInput
    raw_data?: RawDataCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutActivity_metricsInput = {
    player_id?: string
    club_id: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    coach_assignments?: CoachAssignmentUncheckedCreateNestedManyWithoutPlayerInput
    event_participants?: EventParticipantUncheckedCreateNestedManyWithoutPlayerInput
    player_pod_holders?: PlayerPodHolderUncheckedCreateNestedManyWithoutPlayerInput
    player_pods?: PlayerPodUncheckedCreateNestedManyWithoutPlayerInput
    raw_data?: RawDataUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutActivity_metricsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutActivity_metricsInput, PlayerUncheckedCreateWithoutActivity_metricsInput>
  }

  export type PlayerUpsertWithoutActivity_metricsInput = {
    update: XOR<PlayerUpdateWithoutActivity_metricsInput, PlayerUncheckedUpdateWithoutActivity_metricsInput>
    create: XOR<PlayerCreateWithoutActivity_metricsInput, PlayerUncheckedCreateWithoutActivity_metricsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutActivity_metricsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutActivity_metricsInput, PlayerUncheckedUpdateWithoutActivity_metricsInput>
  }

  export type PlayerUpdateWithoutActivity_metricsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    club?: ClubUpdateOneRequiredWithoutPlayersNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutActivity_metricsInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ClubCreateManySuper_adminInput = {
    club_id?: string
    club_name?: string | null
    address?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sport?: string | null
  }

  export type ClubUpdateWithoutSuper_adminInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUpdateManyWithoutClubNestedInput
    coaches?: CoachUpdateManyWithoutClubNestedInput
    events?: EventUpdateManyWithoutClubNestedInput
    players?: PlayerUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutSuper_adminInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
    club_admins?: ClubAdminUncheckedUpdateManyWithoutClubNestedInput
    pod_holders?: PodHolderUncheckedUpdateManyWithoutClubNestedInput
    coaches?: CoachUncheckedUpdateManyWithoutClubNestedInput
    events?: EventUncheckedUpdateManyWithoutClubNestedInput
    players?: PlayerUncheckedUpdateManyWithoutClubNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutClubNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateManyWithoutSuper_adminInput = {
    club_id?: StringFieldUpdateOperationsInput | string
    club_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClubAdminCreateManyClubInput = {
    admin_id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    profile_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type PodHolderCreateManyClubInput = {
    pod_holder_id?: string
    serial_number?: string | null
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CoachCreateManyClubInput = {
    coach_id?: string
    coach_name?: string | null
    phone?: string | null
    email?: string | null
    password_hash?: string | null
    role?: string | null
    coach_image?: string | null
    location?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    login_otp?: string | null
    login_otp_expires?: Date | string | null
  }

  export type EventCreateManyClubInput = {
    event_id?: string
    event_name?: string | null
    event_date?: Date | string | null
    location?: string | null
    event_type?: string | null
    created_at?: Date | string
  }

  export type PlayerCreateManyClubInput = {
    player_id?: string
    player_name?: string | null
    jersey_number?: number | null
    age?: number | null
    position?: string | null
    phone?: string | null
    player_image?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceRequestCreateManyClubInput = {
    request_id?: string
    requester_id?: string | null
    description?: string | null
    status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateManyClubInput = {
    subscription_id?: string
    plan_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
  }

  export type ClubAdminUpdateWithoutClubInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubAdminUncheckedUpdateWithoutClubInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClubAdminUncheckedUpdateManyWithoutClubInput = {
    admin_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PodHolderUpdateWithoutClubInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: PodHolderAuditUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateWithoutClubInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: PodHolderAuditUncheckedUpdateManyWithoutPod_holderNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPod_holderNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPod_holderNestedInput
    pod_holder_statuses?: PodHolderStatusUncheckedUpdateManyWithoutPod_holderNestedInput
  }

  export type PodHolderUncheckedUpdateManyWithoutClubInput = {
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachUpdateWithoutClubInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUpdateManyWithoutCoachNestedInput
    event_participants?: EventParticipantUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutClubInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutCoachNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutCoachNestedInput
    pod_allocations?: PodAllocationUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateManyWithoutClubInput = {
    coach_id?: StringFieldUpdateOperationsInput | string
    coach_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    coach_image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_otp?: NullableStringFieldUpdateOperationsInput | string | null
    login_otp_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUpdateWithoutClubInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_participants?: EventParticipantUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutClubInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutClubInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutClubInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutClubInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    activity_metrics?: ActivityMetricUncheckedUpdateManyWithoutPlayerNestedInput
    coach_assignments?: CoachAssignmentUncheckedUpdateManyWithoutPlayerNestedInput
    event_participants?: EventParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    player_pod_holders?: PlayerPodHolderUncheckedUpdateManyWithoutPlayerNestedInput
    player_pods?: PlayerPodUncheckedUpdateManyWithoutPlayerNestedInput
    raw_data?: RawDataUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutClubInput = {
    player_id?: StringFieldUpdateOperationsInput | string
    player_name?: NullableStringFieldUpdateOperationsInput | string | null
    jersey_number?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    player_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpdateWithoutClubInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateWithoutClubInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyWithoutClubInput = {
    request_id?: StringFieldUpdateOperationsInput | string
    requester_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutClubInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    plan?: PaymentPlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutClubInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutClubInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentCreateManyCoachInput = {
    assignment_id?: string
    pod_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type EventParticipantCreateManyCoachInput = {
    id?: string
    event_id: string
    player_id?: string | null
  }

  export type PodAllocationCreateManyCoachInput = {
    allocation_id?: string
    pod_id: string
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type CoachAssignmentUpdateWithoutCoachInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutCoach_assignmentsNestedInput
    pod_holder?: PodHolderUpdateOneWithoutCoach_assignmentsNestedInput
    pod?: PodUpdateOneWithoutCoach_assignmentsNestedInput
  }

  export type CoachAssignmentUncheckedUpdateWithoutCoachInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutCoachInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutEvent_participantsNestedInput
    player?: PlayerUpdateOneWithoutEvent_participantsNestedInput
  }

  export type EventParticipantUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipantUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PodAllocationUpdateWithoutCoachInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutPod_allocationsNestedInput
  }

  export type PodAllocationUncheckedUpdateWithoutCoachInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationUncheckedUpdateManyWithoutCoachInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricCreateManyPlayerInput = {
    id?: string
    total_distance?: number | null
    hsr_distance?: number | null
    sprint_distance?: number | null
    top_speed?: number | null
    sprint_count?: number | null
    acceleration?: number | null
    deceleration?: number | null
    max_acceleration?: number | null
    max_deceleration?: number | null
    player_load?: number | null
    power_score?: number | null
    hr_max?: number | null
    time_in_red_zone?: number | null
    percent_in_red_zone?: number | null
    hr_recovery_time?: number | null
    recorded_at?: Date | string
  }

  export type CoachAssignmentCreateManyPlayerInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    pod_holder_id?: string | null
    assigned_at?: Date | string
  }

  export type EventParticipantCreateManyPlayerInput = {
    id?: string
    event_id: string
    coach_id?: string | null
  }

  export type PlayerPodHolderCreateManyPlayerInput = {
    id?: string
    pod_holder_id: string
    assigned_date?: Date | string
  }

  export type PlayerPodCreateManyPlayerInput = {
    id?: string
    pod_id: string
    assigned_date?: Date | string
  }

  export type RawDataCreateManyPlayerInput = {
    raw_id?: string
    pod_id: string
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type ActivityMetricUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityMetricUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    hsr_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    top_speed?: NullableFloatFieldUpdateOperationsInput | number | null
    sprint_count?: NullableIntFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    max_deceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    player_load?: NullableFloatFieldUpdateOperationsInput | number | null
    power_score?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_max?: NullableIntFieldUpdateOperationsInput | number | null
    time_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_in_red_zone?: NullableFloatFieldUpdateOperationsInput | number | null
    hr_recovery_time?: NullableFloatFieldUpdateOperationsInput | number | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUpdateWithoutPlayerInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutCoach_assignmentsNestedInput
    pod_holder?: PodHolderUpdateOneWithoutCoach_assignmentsNestedInput
    pod?: PodUpdateOneWithoutCoach_assignmentsNestedInput
  }

  export type CoachAssignmentUncheckedUpdateWithoutPlayerInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPlayerInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    coach?: CoachUpdateOneWithoutEvent_participantsNestedInput
    event?: EventUpdateOneRequiredWithoutEvent_participantsNestedInput
  }

  export type EventParticipantUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipantUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerPodHolderUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pod_holder?: PodHolderUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput
  }

  export type PlayerPodHolderUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pod_holder_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutPlayer_podsNestedInput
  }

  export type PlayerPodUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataUpdateWithoutPlayerInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pod?: PodUpdateOneRequiredWithoutRaw_dataNestedInput
  }

  export type RawDataUncheckedUpdateWithoutPlayerInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataUncheckedUpdateManyWithoutPlayerInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    pod_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentCreateManyPodInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_holder_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type PlayerPodCreateManyPodInput = {
    id?: string
    player_id: string
    assigned_date?: Date | string
  }

  export type PodAllocationCreateManyPodInput = {
    allocation_id?: string
    coach_id?: string | null
    battery_level?: number | null
    health_status?: string | null
    assigned_at?: Date | string
  }

  export type PodStatusCreateManyPodInput = {
    status_id?: string
    working_status?: string | null
    battery_level?: number | null
    last_sync?: Date | string | null
    health_status?: string | null
    created_at?: Date | string
  }

  export type RawDataCreateManyPodInput = {
    raw_id?: string
    player_id?: string | null
    ts?: Date | string | null
    acceleration_x?: number | null
    acceleration_y?: number | null
    acceleration_z?: number | null
    latitude?: number | null
    longitude?: number | null
    w?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    distance?: number | null
    speed?: number | null
    heart_rate?: number | null
    created_at?: Date | string
  }

  export type CoachAssignmentUpdateWithoutPodInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutCoach_assignmentsNestedInput
    player?: PlayerUpdateOneWithoutCoach_assignmentsNestedInput
    pod_holder?: PodHolderUpdateOneWithoutCoach_assignmentsNestedInput
  }

  export type CoachAssignmentUncheckedUpdateWithoutPodInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPodInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_holder_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPlayer_podsNestedInput
  }

  export type PlayerPodUncheckedUpdateWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodUncheckedUpdateManyWithoutPodInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationUpdateWithoutPodInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutPod_allocationsNestedInput
  }

  export type PodAllocationUncheckedUpdateWithoutPodInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodAllocationUncheckedUpdateManyWithoutPodInput = {
    allocation_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusUpdateWithoutPodInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusUncheckedUpdateWithoutPodInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodStatusUncheckedUpdateManyWithoutPodInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    health_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataUpdateWithoutPodInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneWithoutRaw_dataNestedInput
  }

  export type RawDataUncheckedUpdateWithoutPodInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDataUncheckedUpdateManyWithoutPodInput = {
    raw_id?: StringFieldUpdateOperationsInput | string
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    ts?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceleration_x?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_y?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration_z?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    w?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heart_rate?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderAuditCreateManyPod_holderInput = {
    audit_id?: string
    from_club_id?: string | null
    to_club_id?: string | null
    action: string
    performed_by: string
    created_at?: Date | string
  }

  export type CoachAssignmentCreateManyPod_holderInput = {
    assignment_id?: string
    coach_id?: string | null
    pod_id?: string | null
    player_id?: string | null
    assigned_at?: Date | string
  }

  export type PlayerPodHolderCreateManyPod_holderInput = {
    id?: string
    player_id: string
    assigned_date?: Date | string
  }

  export type PodHolderStatusCreateManyPod_holderInput = {
    status_id?: string
    battery_level?: number | null
    working_status?: string | null
    last_sync?: Date | string | null
    created_at?: Date | string
  }

  export type PodHolderAuditUpdateWithoutPod_holderInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderAuditUncheckedUpdateWithoutPod_holderInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderAuditUncheckedUpdateManyWithoutPod_holderInput = {
    audit_id?: StringFieldUpdateOperationsInput | string
    from_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    to_club_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUpdateWithoutPod_holderInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutCoach_assignmentsNestedInput
    player?: PlayerUpdateOneWithoutCoach_assignmentsNestedInput
    pod?: PodUpdateOneWithoutCoach_assignmentsNestedInput
  }

  export type CoachAssignmentUncheckedUpdateWithoutPod_holderInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAssignmentUncheckedUpdateManyWithoutPod_holderInput = {
    assignment_id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    pod_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderUpdateWithoutPod_holderInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPlayer_pod_holdersNestedInput
  }

  export type PlayerPodHolderUncheckedUpdateWithoutPod_holderInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerPodHolderUncheckedUpdateManyWithoutPod_holderInput = {
    id?: StringFieldUpdateOperationsInput | string
    player_id?: StringFieldUpdateOperationsInput | string
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusUpdateWithoutPod_holderInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusUncheckedUpdateWithoutPod_holderInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PodHolderStatusUncheckedUpdateManyWithoutPod_holderInput = {
    status_id?: StringFieldUpdateOperationsInput | string
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    working_status?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipantCreateManyEventInput = {
    id?: string
    coach_id?: string | null
    player_id?: string | null
  }

  export type EventParticipantUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    coach?: CoachUpdateOneWithoutEvent_participantsNestedInput
    player?: PlayerUpdateOneWithoutEvent_participantsNestedInput
  }

  export type EventParticipantUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipantUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    coach_id?: NullableStringFieldUpdateOperationsInput | string | null
    player_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateManyPlanInput = {
    subscription_id?: string
    club_id: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: string | null
    created_at?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
    club?: ClubUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    subscription_id?: StringFieldUpdateOperationsInput | string
    club_id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    payment_id?: string
    amount_cents?: number | null
    paid_at?: Date | string
    method?: string | null
    transaction_ref?: string | null
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    payment_id?: StringFieldUpdateOperationsInput | string
    amount_cents?: NullableIntFieldUpdateOperationsInput | number | null
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_ref?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}